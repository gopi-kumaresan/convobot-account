{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{\"305l\":function(t,e,i){\"use strict\";i.r(e),i.d(e,\"AuthModule\",function(){return xn});var s=i(\"ofXK\"),n=i(\"tyNb\"),o=i(\"fXoL\"),r=i(\"XNiG\"),a=i(\"quSY\"),l=i(\"LRne\");function c(t,...e){return e.length?e.some(e=>t[e]):t.altKey||t.shiftKey||t.ctrlKey||t.metaKey}var h=i(\"vkgz\"),d=i(\"7o/Q\");class u extends a.a{constructor(t,e){super()}schedule(t,e=0){return this}}class p extends u{constructor(t,e){super(t,e),this.scheduler=t,this.work=e,this.pending=!1}schedule(t,e=0){if(this.closed)return this;this.state=t;const i=this.id,s=this.scheduler;return null!=i&&(this.id=this.recycleAsyncId(s,i,e)),this.pending=!0,this.delay=e,this.id=this.id||this.requestAsyncId(s,this.id,e),this}requestAsyncId(t,e,i=0){return setInterval(t.flush.bind(t,this),i)}recycleAsyncId(t,e,i=0){if(null!==i&&this.delay===i&&!1===this.pending)return e;clearInterval(e)}execute(t,e){if(this.closed)return new Error(\"executing a cancelled action\");this.pending=!1;const i=this._execute(t,e);if(i)return i;!1===this.pending&&null!=this.id&&(this.id=this.recycleAsyncId(this.scheduler,this.id,null))}_execute(t,e){let i=!1,s=void 0;try{this.work(t)}catch(n){i=!0,s=!!n&&n||new Error(n)}if(i)return this.unsubscribe(),s}_unsubscribe(){const t=this.id,e=this.scheduler,i=e.actions,s=i.indexOf(this);this.work=null,this.state=null,this.pending=!1,this.scheduler=null,-1!==s&&i.splice(s,1),null!=t&&(this.id=this.recycleAsyncId(e,t,null)),this.delay=null}}let b=(()=>{class t{constructor(e,i=t.now){this.SchedulerAction=e,this.now=i}schedule(t,e=0,i){return new this.SchedulerAction(this,t).schedule(i,e)}}return t.now=()=>Date.now(),t})();class m extends b{constructor(t,e=b.now){super(t,()=>m.delegate&&m.delegate!==this?m.delegate.now():e()),this.actions=[],this.active=!1,this.scheduled=void 0}schedule(t,e=0,i){return m.delegate&&m.delegate!==this?m.delegate.schedule(t,e,i):super.schedule(t,e,i)}flush(t){const{actions:e}=this;if(this.active)return void e.push(t);let i;this.active=!0;do{if(i=t.execute(t.state,t.delay))break}while(t=e.shift());if(this.active=!1,i){for(;t=e.shift();)t.unsubscribe();throw i}}}const _=new m(p);function g(t,e=_){return i=>i.lift(new f(t,e))}class f{constructor(t,e){this.dueTime=t,this.scheduler=e}call(t,e){return e.subscribe(new v(t,this.dueTime,this.scheduler))}}class v extends d.a{constructor(t,e,i){super(t),this.dueTime=e,this.scheduler=i,this.debouncedSubscription=null,this.lastValue=null,this.hasValue=!1}_next(t){this.clearDebounce(),this.lastValue=t,this.hasValue=!0,this.add(this.debouncedSubscription=this.scheduler.schedule(y,this.dueTime,this))}_complete(){this.debouncedNext(),this.destination.complete()}debouncedNext(){if(this.clearDebounce(),this.hasValue){const{lastValue:t}=this;this.lastValue=null,this.hasValue=!1,this.destination.next(t)}}clearDebounce(){const t=this.debouncedSubscription;null!==t&&(this.remove(t),t.unsubscribe(),this.debouncedSubscription=null)}}function y(t){t.debouncedNext()}var w=i(\"pLZG\"),x=i(\"lJxs\"),C=i(\"IzEk\");function k(t){return null!=t&&\"\"+t!=\"false\"}function S(t,e=0){return function(t){return!isNaN(parseFloat(t))&&!isNaN(Number(t))}(t)?Number(t):e}function O(t){return Array.isArray(t)?t:[t]}function R(t){return null==t?\"\":\"string\"==typeof t?t:t+\"px\"}function I(t){return t instanceof o.l?t.nativeElement:t}let E;try{E=\"undefined\"!=typeof Intl&&Intl.v8BreakIterator}catch(Cn){E=!1}let P,A,M,T=(()=>{class t{constructor(t){this._platformId=t,this.isBrowser=this._platformId?Object(s.s)(this._platformId):\"object\"==typeof document&&!!document,this.EDGE=this.isBrowser&&/(edge)/i.test(navigator.userAgent),this.TRIDENT=this.isBrowser&&/(msie|trident)/i.test(navigator.userAgent),this.BLINK=this.isBrowser&&!(!window.chrome&&!E)&&\"undefined\"!=typeof CSS&&!this.EDGE&&!this.TRIDENT,this.WEBKIT=this.isBrowser&&/AppleWebKit/i.test(navigator.userAgent)&&!this.BLINK&&!this.EDGE&&!this.TRIDENT,this.IOS=this.isBrowser&&/iPad|iPhone|iPod/.test(navigator.userAgent)&&!(\"MSStream\"in window),this.FIREFOX=this.isBrowser&&/(firefox|minefield)/i.test(navigator.userAgent),this.ANDROID=this.isBrowser&&/android/i.test(navigator.userAgent)&&!this.TRIDENT,this.SAFARI=this.isBrowser&&/safari/i.test(navigator.userAgent)&&this.WEBKIT}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(o.C))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(o.C))},token:t,providedIn:\"root\"}),t})(),D=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)}}),t})();function L(t){return function(){if(null==P&&\"undefined\"!=typeof window)try{window.addEventListener(\"test\",null,Object.defineProperty({},\"passive\",{get:()=>P=!0}))}finally{P=P||!1}return P}()?t:!!t.capture}function B(){if(null==A){if(\"object\"!=typeof document||!document||\"function\"!=typeof Element||!Element)return A=!1,A;if(\"scrollBehavior\"in document.documentElement.style)A=!0;else{const t=Element.prototype.scrollTo;A=!!t&&!/\\{\\s*\\[native code\\]\\s*\\}/.test(t.toString())}}return A}var j=i(\"HDdC\");let F=(()=>{class t{create(t){return\"undefined\"==typeof MutationObserver?null:new MutationObserver(t)}}return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t},token:t,providedIn:\"root\"}),t})(),W=(()=>{class t{constructor(t){this._mutationObserverFactory=t,this._observedElements=new Map}ngOnDestroy(){this._observedElements.forEach((t,e)=>this._cleanupObserver(e))}observe(t){const e=I(t);return new j.a(t=>{const i=this._observeElement(e).subscribe(t);return()=>{i.unsubscribe(),this._unobserveElement(e)}})}_observeElement(t){if(this._observedElements.has(t))this._observedElements.get(t).count++;else{const e=new r.a,i=this._mutationObserverFactory.create(t=>e.next(t));i&&i.observe(t,{characterData:!0,childList:!0,subtree:!0}),this._observedElements.set(t,{observer:i,stream:e,count:1})}return this._observedElements.get(t).stream}_unobserveElement(t){this._observedElements.has(t)&&(this._observedElements.get(t).count--,this._observedElements.get(t).count||this._cleanupObserver(t))}_cleanupObserver(t){if(this._observedElements.has(t)){const{observer:e,stream:i}=this._observedElements.get(t);e&&e.disconnect(),i.complete(),this._observedElements.delete(t)}}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(F))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(F))},token:t,providedIn:\"root\"}),t})(),N=(()=>{class t{constructor(t,e,i){this._contentObserver=t,this._elementRef=e,this._ngZone=i,this.event=new o.n,this._disabled=!1,this._currentSubscription=null}get disabled(){return this._disabled}set disabled(t){this._disabled=k(t),this._disabled?this._unsubscribe():this._subscribe()}get debounce(){return this._debounce}set debounce(t){this._debounce=S(t),this._subscribe()}ngAfterContentInit(){this._currentSubscription||this.disabled||this._subscribe()}ngOnDestroy(){this._unsubscribe()}_subscribe(){this._unsubscribe();const t=this._contentObserver.observe(this._elementRef);this._ngZone.runOutsideAngular(()=>{this._currentSubscription=(this.debounce?t.pipe(g(this.debounce)):t).subscribe(this.event)})}_unsubscribe(){var t;null===(t=this._currentSubscription)||void 0===t||t.unsubscribe()}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(W),o.Mb(o.l),o.Mb(o.A))},t.\\u0275dir=o.Hb({type:t,selectors:[[\"\",\"cdkObserveContent\",\"\"]],inputs:{disabled:[\"cdkObserveContentDisabled\",\"disabled\"],debounce:\"debounce\"},outputs:{event:\"cdkObserveContent\"},exportAs:[\"cdkObserveContent\"]}),t})(),H=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},providers:[F]}),t})();class V{constructor(t){this._items=t,this._activeItemIndex=-1,this._activeItem=null,this._wrap=!1,this._letterKeyStream=new r.a,this._typeaheadSubscription=a.a.EMPTY,this._vertical=!0,this._allowedModifierKeys=[],this._homeAndEnd=!1,this._skipPredicateFn=t=>t.disabled,this._pressedLetters=[],this.tabOut=new r.a,this.change=new r.a,t instanceof o.E&&t.changes.subscribe(t=>{if(this._activeItem){const e=t.toArray().indexOf(this._activeItem);e>-1&&e!==this._activeItemIndex&&(this._activeItemIndex=e)}})}skipPredicate(t){return this._skipPredicateFn=t,this}withWrap(t=!0){return this._wrap=t,this}withVerticalOrientation(t=!0){return this._vertical=t,this}withHorizontalOrientation(t){return this._horizontal=t,this}withAllowedModifierKeys(t){return this._allowedModifierKeys=t,this}withTypeAhead(t=200){return this._typeaheadSubscription.unsubscribe(),this._typeaheadSubscription=this._letterKeyStream.pipe(Object(h.a)(t=>this._pressedLetters.push(t)),g(t),Object(w.a)(()=>this._pressedLetters.length>0),Object(x.a)(()=>this._pressedLetters.join(\"\"))).subscribe(t=>{const e=this._getItemsArray();for(let i=1;i<e.length+1;i++){const s=(this._activeItemIndex+i)%e.length,n=e[s];if(!this._skipPredicateFn(n)&&0===n.getLabel().toUpperCase().trim().indexOf(t)){this.setActiveItem(s);break}}this._pressedLetters=[]}),this}withHomeAndEnd(t=!0){return this._homeAndEnd=t,this}setActiveItem(t){const e=this._activeItem;this.updateActiveItem(t),this._activeItem!==e&&this.change.next(this._activeItemIndex)}onKeydown(t){const e=t.keyCode,i=[\"altKey\",\"ctrlKey\",\"metaKey\",\"shiftKey\"].every(e=>!t[e]||this._allowedModifierKeys.indexOf(e)>-1);switch(e){case 9:return void this.tabOut.next();case 40:if(this._vertical&&i){this.setNextItemActive();break}return;case 38:if(this._vertical&&i){this.setPreviousItemActive();break}return;case 39:if(this._horizontal&&i){\"rtl\"===this._horizontal?this.setPreviousItemActive():this.setNextItemActive();break}return;case 37:if(this._horizontal&&i){\"rtl\"===this._horizontal?this.setNextItemActive():this.setPreviousItemActive();break}return;case 36:if(this._homeAndEnd&&i){this.setFirstItemActive();break}return;case 35:if(this._homeAndEnd&&i){this.setLastItemActive();break}return;default:return void((i||c(t,\"shiftKey\"))&&(t.key&&1===t.key.length?this._letterKeyStream.next(t.key.toLocaleUpperCase()):(e>=65&&e<=90||e>=48&&e<=57)&&this._letterKeyStream.next(String.fromCharCode(e))))}this._pressedLetters=[],t.preventDefault()}get activeItemIndex(){return this._activeItemIndex}get activeItem(){return this._activeItem}isTyping(){return this._pressedLetters.length>0}setFirstItemActive(){this._setActiveItemByIndex(0,1)}setLastItemActive(){this._setActiveItemByIndex(this._items.length-1,-1)}setNextItemActive(){this._activeItemIndex<0?this.setFirstItemActive():this._setActiveItemByDelta(1)}setPreviousItemActive(){this._activeItemIndex<0&&this._wrap?this.setLastItemActive():this._setActiveItemByDelta(-1)}updateActiveItem(t){const e=this._getItemsArray(),i=\"number\"==typeof t?t:e.indexOf(t),s=e[i];this._activeItem=null==s?null:s,this._activeItemIndex=i}_setActiveItemByDelta(t){this._wrap?this._setActiveInWrapMode(t):this._setActiveInDefaultMode(t)}_setActiveInWrapMode(t){const e=this._getItemsArray();for(let i=1;i<=e.length;i++){const s=(this._activeItemIndex+t*i+e.length)%e.length;if(!this._skipPredicateFn(e[s]))return void this.setActiveItem(s)}}_setActiveInDefaultMode(t){this._setActiveItemByIndex(this._activeItemIndex+t,t)}_setActiveItemByIndex(t,e){const i=this._getItemsArray();if(i[t]){for(;this._skipPredicateFn(i[t]);)if(!i[t+=e])return;this.setActiveItem(t)}}_getItemsArray(){return this._items instanceof o.E?this._items.toArray():this._items}}class z extends V{setActiveItem(t){this.activeItem&&this.activeItem.setInactiveStyles(),super.setActiveItem(t),this.activeItem&&this.activeItem.setActiveStyles()}}class Y extends V{constructor(){super(...arguments),this._origin=\"program\"}setFocusOrigin(t){return this._origin=t,this}setActiveItem(t){super.setActiveItem(t),this.activeItem&&this.activeItem.focus(this._origin)}}\"undefined\"!=typeof Element&&Element;const K=new o.q(\"liveAnnouncerElement\",{providedIn:\"root\",factory:function(){return null}}),X=new o.q(\"LIVE_ANNOUNCER_DEFAULT_OPTIONS\");let q=(()=>{class t{constructor(t,e,i,s){this._ngZone=e,this._defaultOptions=s,this._document=i,this._liveElement=t||this._createLiveElement()}announce(t,...e){const i=this._defaultOptions;let s,n;return 1===e.length&&\"number\"==typeof e[0]?n=e[0]:[s,n]=e,this.clear(),clearTimeout(this._previousTimeout),s||(s=i&&i.politeness?i.politeness:\"polite\"),null==n&&i&&(n=i.duration),this._liveElement.setAttribute(\"aria-live\",s),this._ngZone.runOutsideAngular(()=>new Promise(e=>{clearTimeout(this._previousTimeout),this._previousTimeout=setTimeout(()=>{this._liveElement.textContent=t,e(),\"number\"==typeof n&&(this._previousTimeout=setTimeout(()=>this.clear(),n))},100)}))}clear(){this._liveElement&&(this._liveElement.textContent=\"\")}ngOnDestroy(){clearTimeout(this._previousTimeout),this._liveElement&&this._liveElement.parentNode&&(this._liveElement.parentNode.removeChild(this._liveElement),this._liveElement=null)}_createLiveElement(){const t=\"cdk-live-announcer-element\",e=this._document.getElementsByClassName(t),i=this._document.createElement(\"div\");for(let s=0;s<e.length;s++)e[s].parentNode.removeChild(e[s]);return i.classList.add(t),i.classList.add(\"cdk-visually-hidden\"),i.setAttribute(\"aria-atomic\",\"true\"),i.setAttribute(\"aria-live\",\"polite\"),this._document.body.appendChild(i),i}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(K,8),o.Wb(o.A),o.Wb(s.c),o.Wb(X,8))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(K,8),Object(o.Wb)(o.A),Object(o.Wb)(s.c),Object(o.Wb)(X,8))},token:t,providedIn:\"root\"}),t})();function Z(t){return 0===t.buttons}function G(t){const e=t.touches&&t.touches[0]||t.changedTouches&&t.changedTouches[0];return!(!e||-1!==e.identifier||null!=e.radiusX&&1!==e.radiusX||null!=e.radiusY&&1!==e.radiusY)}const J=new o.q(\"cdk-focus-monitor-default-options\"),U=L({passive:!0,capture:!0});let $=(()=>{class t{constructor(t,e,i,s){this._ngZone=t,this._platform=e,this._origin=null,this._windowFocused=!1,this._elementInfo=new Map,this._monitoredElementCount=0,this._rootNodeFocusListenerCount=new Map,this._documentKeydownListener=()=>{this._lastTouchTarget=null,this._setOriginForCurrentEventQueue(\"keyboard\")},this._documentMousedownListener=t=>{if(!this._lastTouchTarget){const e=Z(t)?\"keyboard\":\"mouse\";this._setOriginForCurrentEventQueue(e)}},this._documentTouchstartListener=t=>{G(t)?this._lastTouchTarget||this._setOriginForCurrentEventQueue(\"keyboard\"):(null!=this._touchTimeoutId&&clearTimeout(this._touchTimeoutId),this._lastTouchTarget=Q(t),this._touchTimeoutId=setTimeout(()=>this._lastTouchTarget=null,650))},this._windowFocusListener=()=>{this._windowFocused=!0,this._windowFocusTimeoutId=setTimeout(()=>this._windowFocused=!1)},this._rootNodeFocusAndBlurListener=t=>{const e=Q(t),i=\"focus\"===t.type?this._onFocus:this._onBlur;for(let s=e;s;s=s.parentElement)i.call(this,t,s)},this._document=i,this._detectionMode=(null==s?void 0:s.detectionMode)||0}monitor(t,e=!1){const i=I(t);if(!this._platform.isBrowser||1!==i.nodeType)return Object(l.a)(null);const s=function(t){if(function(){if(null==M){const t=\"undefined\"!=typeof document?document.head:null;M=!(!t||!t.createShadowRoot&&!t.attachShadow)}return M}()){const e=t.getRootNode?t.getRootNode():null;if(\"undefined\"!=typeof ShadowRoot&&ShadowRoot&&e instanceof ShadowRoot)return e}return null}(i)||this._getDocument(),n=this._elementInfo.get(i);if(n)return e&&(n.checkChildren=!0),n.subject;const o={checkChildren:e,subject:new r.a,rootNode:s};return this._elementInfo.set(i,o),this._registerGlobalListeners(o),o.subject}stopMonitoring(t){const e=I(t),i=this._elementInfo.get(e);i&&(i.subject.complete(),this._setClasses(e),this._elementInfo.delete(e),this._removeGlobalListeners(i))}focusVia(t,e,i){const s=I(t);s===this._getDocument().activeElement?this._getClosestElementsInfo(s).forEach(([t,i])=>this._originChanged(t,e,i)):(this._setOriginForCurrentEventQueue(e),\"function\"==typeof s.focus&&s.focus(i))}ngOnDestroy(){this._elementInfo.forEach((t,e)=>this.stopMonitoring(e))}_getDocument(){return this._document||document}_getWindow(){return this._getDocument().defaultView||window}_toggleClass(t,e,i){i?t.classList.add(e):t.classList.remove(e)}_getFocusOrigin(t){return this._origin?this._origin:this._windowFocused&&this._lastFocusOrigin?this._lastFocusOrigin:this._wasCausedByTouch(t)?\"touch\":\"program\"}_setClasses(t,e){this._toggleClass(t,\"cdk-focused\",!!e),this._toggleClass(t,\"cdk-touch-focused\",\"touch\"===e),this._toggleClass(t,\"cdk-keyboard-focused\",\"keyboard\"===e),this._toggleClass(t,\"cdk-mouse-focused\",\"mouse\"===e),this._toggleClass(t,\"cdk-program-focused\",\"program\"===e)}_setOriginForCurrentEventQueue(t){this._ngZone.runOutsideAngular(()=>{this._origin=t,0===this._detectionMode&&(this._originTimeoutId=setTimeout(()=>this._origin=null,1))})}_wasCausedByTouch(t){const e=Q(t);return this._lastTouchTarget instanceof Node&&e instanceof Node&&(e===this._lastTouchTarget||e.contains(this._lastTouchTarget))}_onFocus(t,e){const i=this._elementInfo.get(e);i&&(i.checkChildren||e===Q(t))&&this._originChanged(e,this._getFocusOrigin(t),i)}_onBlur(t,e){const i=this._elementInfo.get(e);!i||i.checkChildren&&t.relatedTarget instanceof Node&&e.contains(t.relatedTarget)||(this._setClasses(e),this._emitOrigin(i.subject,null))}_emitOrigin(t,e){this._ngZone.run(()=>t.next(e))}_registerGlobalListeners(t){if(!this._platform.isBrowser)return;const e=t.rootNode,i=this._rootNodeFocusListenerCount.get(e)||0;i||this._ngZone.runOutsideAngular(()=>{e.addEventListener(\"focus\",this._rootNodeFocusAndBlurListener,U),e.addEventListener(\"blur\",this._rootNodeFocusAndBlurListener,U)}),this._rootNodeFocusListenerCount.set(e,i+1),1==++this._monitoredElementCount&&this._ngZone.runOutsideAngular(()=>{const t=this._getDocument(),e=this._getWindow();t.addEventListener(\"keydown\",this._documentKeydownListener,U),t.addEventListener(\"mousedown\",this._documentMousedownListener,U),t.addEventListener(\"touchstart\",this._documentTouchstartListener,U),e.addEventListener(\"focus\",this._windowFocusListener)})}_removeGlobalListeners(t){const e=t.rootNode;if(this._rootNodeFocusListenerCount.has(e)){const t=this._rootNodeFocusListenerCount.get(e);t>1?this._rootNodeFocusListenerCount.set(e,t-1):(e.removeEventListener(\"focus\",this._rootNodeFocusAndBlurListener,U),e.removeEventListener(\"blur\",this._rootNodeFocusAndBlurListener,U),this._rootNodeFocusListenerCount.delete(e))}if(!--this._monitoredElementCount){const t=this._getDocument(),e=this._getWindow();t.removeEventListener(\"keydown\",this._documentKeydownListener,U),t.removeEventListener(\"mousedown\",this._documentMousedownListener,U),t.removeEventListener(\"touchstart\",this._documentTouchstartListener,U),e.removeEventListener(\"focus\",this._windowFocusListener),clearTimeout(this._windowFocusTimeoutId),clearTimeout(this._touchTimeoutId),clearTimeout(this._originTimeoutId)}}_originChanged(t,e,i){this._setClasses(t,e),this._emitOrigin(i.subject,e),this._lastFocusOrigin=e}_getClosestElementsInfo(t){const e=[];return this._elementInfo.forEach((i,s)=>{(s===t||i.checkChildren&&s.contains(t))&&e.push([s,i])}),e}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(o.A),o.Wb(T),o.Wb(s.c,8),o.Wb(J,8))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(o.A),Object(o.Wb)(T),Object(o.Wb)(s.c,8),Object(o.Wb)(J,8))},token:t,providedIn:\"root\"}),t})();function Q(t){return t.composedPath?t.composedPath()[0]:t.target}let tt=(()=>{class t{constructor(t,e){this._elementRef=t,this._focusMonitor=e,this.cdkFocusChange=new o.n}ngAfterViewInit(){const t=this._elementRef.nativeElement;this._monitorSubscription=this._focusMonitor.monitor(t,1===t.nodeType&&t.hasAttribute(\"cdkMonitorSubtreeFocus\")).subscribe(t=>this.cdkFocusChange.emit(t))}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef),this._monitorSubscription&&this._monitorSubscription.unsubscribe()}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb($))},t.\\u0275dir=o.Hb({type:t,selectors:[[\"\",\"cdkMonitorElementFocus\",\"\"],[\"\",\"cdkMonitorSubtreeFocus\",\"\"]],outputs:{cdkFocusChange:\"cdkFocusChange\"}}),t})();const et=\"cdk-high-contrast-black-on-white\",it=\"cdk-high-contrast-white-on-black\",st=\"cdk-high-contrast-active\";let nt=(()=>{class t{constructor(t,e){this._platform=t,this._document=e}getHighContrastMode(){if(!this._platform.isBrowser)return 0;const t=this._document.createElement(\"div\");t.style.backgroundColor=\"rgb(1,2,3)\",t.style.position=\"absolute\",this._document.body.appendChild(t);const e=this._document.defaultView||window,i=e&&e.getComputedStyle?e.getComputedStyle(t):null,s=(i&&i.backgroundColor||\"\").replace(/ /g,\"\");switch(this._document.body.removeChild(t),s){case\"rgb(0,0,0)\":return 2;case\"rgb(255,255,255)\":return 1}return 0}_applyBodyHighContrastModeCssClasses(){if(this._platform.isBrowser&&this._document.body){const t=this._document.body.classList;t.remove(st),t.remove(et),t.remove(it);const e=this.getHighContrastMode();1===e?(t.add(st),t.add(et)):2===e&&(t.add(st),t.add(it))}}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(T),o.Wb(s.c))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(T),Object(o.Wb)(s.c))},token:t,providedIn:\"root\"}),t})(),ot=(()=>{class t{constructor(t){t._applyBodyHighContrastModeCssClasses()}}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)(o.Wb(nt))},imports:[[D,H]]}),t})();class rt{attach(t){return this._attachedHost=t,t.attach(this)}detach(){let t=this._attachedHost;null!=t&&(this._attachedHost=null,t.detach())}get isAttached(){return null!=this._attachedHost}setAttachedHost(t){this._attachedHost=t}}class at extends rt{constructor(t,e,i,s){super(),this.component=t,this.viewContainerRef=e,this.injector=i,this.componentFactoryResolver=s}}class lt extends rt{constructor(t,e,i){super(),this.templateRef=t,this.viewContainerRef=e,this.context=i}get origin(){return this.templateRef.elementRef}attach(t,e=this.context){return this.context=e,super.attach(t)}detach(){return this.context=void 0,super.detach()}}class ct extends rt{constructor(t){super(),this.element=t instanceof o.l?t.nativeElement:t}}class ht{constructor(){this._isDisposed=!1,this.attachDomPortal=null}hasAttached(){return!!this._attachedPortal}attach(t){return t instanceof at?(this._attachedPortal=t,this.attachComponentPortal(t)):t instanceof lt?(this._attachedPortal=t,this.attachTemplatePortal(t)):this.attachDomPortal&&t instanceof ct?(this._attachedPortal=t,this.attachDomPortal(t)):void 0}detach(){this._attachedPortal&&(this._attachedPortal.setAttachedHost(null),this._attachedPortal=null),this._invokeDisposeFn()}dispose(){this.hasAttached()&&this.detach(),this._invokeDisposeFn(),this._isDisposed=!0}setDisposeFn(t){this._disposeFn=t}_invokeDisposeFn(){this._disposeFn&&(this._disposeFn(),this._disposeFn=null)}}class dt extends ht{constructor(t,e,i,s,n){super(),this.outletElement=t,this._componentFactoryResolver=e,this._appRef=i,this._defaultInjector=s,this.attachDomPortal=t=>{const e=t.element,i=this._document.createComment(\"dom-portal\");e.parentNode.insertBefore(i,e),this.outletElement.appendChild(e),this._attachedPortal=t,super.setDisposeFn(()=>{i.parentNode&&i.parentNode.replaceChild(e,i)})},this._document=n}attachComponentPortal(t){const e=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component);let i;return t.viewContainerRef?(i=t.viewContainerRef.createComponent(e,t.viewContainerRef.length,t.injector||t.viewContainerRef.injector),this.setDisposeFn(()=>i.destroy())):(i=e.create(t.injector||this._defaultInjector),this._appRef.attachView(i.hostView),this.setDisposeFn(()=>{this._appRef.detachView(i.hostView),i.destroy()})),this.outletElement.appendChild(this._getComponentRootNode(i)),this._attachedPortal=t,i}attachTemplatePortal(t){let e=t.viewContainerRef,i=e.createEmbeddedView(t.templateRef,t.context);return i.rootNodes.forEach(t=>this.outletElement.appendChild(t)),i.detectChanges(),this.setDisposeFn(()=>{let t=e.indexOf(i);-1!==t&&e.remove(t)}),this._attachedPortal=t,i}dispose(){super.dispose(),null!=this.outletElement.parentNode&&this.outletElement.parentNode.removeChild(this.outletElement)}_getComponentRootNode(t){return t.hostView.rootNodes[0]}}let ut=(()=>{class t extends ht{constructor(t,e,i){super(),this._componentFactoryResolver=t,this._viewContainerRef=e,this._isInitialized=!1,this.attached=new o.n,this.attachDomPortal=t=>{const e=t.element,i=this._document.createComment(\"dom-portal\");t.setAttachedHost(this),e.parentNode.insertBefore(i,e),this._getRootNode().appendChild(e),this._attachedPortal=t,super.setDisposeFn(()=>{i.parentNode&&i.parentNode.replaceChild(e,i)})},this._document=i}get portal(){return this._attachedPortal}set portal(t){(!this.hasAttached()||t||this._isInitialized)&&(this.hasAttached()&&super.detach(),t&&super.attach(t),this._attachedPortal=t)}get attachedRef(){return this._attachedRef}ngOnInit(){this._isInitialized=!0}ngOnDestroy(){super.dispose(),this._attachedPortal=null,this._attachedRef=null}attachComponentPortal(t){t.setAttachedHost(this);const e=null!=t.viewContainerRef?t.viewContainerRef:this._viewContainerRef,i=(t.componentFactoryResolver||this._componentFactoryResolver).resolveComponentFactory(t.component),s=e.createComponent(i,e.length,t.injector||e.injector);return e!==this._viewContainerRef&&this._getRootNode().appendChild(s.hostView.rootNodes[0]),super.setDisposeFn(()=>s.destroy()),this._attachedPortal=t,this._attachedRef=s,this.attached.emit(s),s}attachTemplatePortal(t){t.setAttachedHost(this);const e=this._viewContainerRef.createEmbeddedView(t.templateRef,t.context);return super.setDisposeFn(()=>this._viewContainerRef.clear()),this._attachedPortal=t,this._attachedRef=e,this.attached.emit(e),e}_getRootNode(){const t=this._viewContainerRef.element.nativeElement;return t.nodeType===t.ELEMENT_NODE?t:t.parentNode}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.j),o.Mb(o.Q),o.Mb(s.c))},t.\\u0275dir=o.Hb({type:t,selectors:[[\"\",\"cdkPortalOutlet\",\"\"]],inputs:{portal:[\"cdkPortalOutlet\",\"portal\"]},outputs:{attached:\"attached\"},exportAs:[\"cdkPortalOutlet\"],features:[o.xb]}),t})(),pt=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)}}),t})();const bt=new o.q(\"cdk-dir-doc\",{providedIn:\"root\",factory:function(){return Object(o.V)(s.c)}});let mt=(()=>{class t{constructor(t){if(this.value=\"ltr\",this.change=new o.n,t){const e=t.documentElement?t.documentElement.dir:null,i=(t.body?t.body.dir:null)||e;this.value=\"ltr\"===i||\"rtl\"===i?i:\"ltr\"}}ngOnDestroy(){this.change.complete()}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(bt,8))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(bt,8))},token:t,providedIn:\"root\"}),t})(),_t=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)}}),t})();const gt=new o.P(\"11.2.13\");var ft=i(\"JX91\"),vt=i(\"R1ws\");function yt(t,e){if(1&t&&o.Nb(0,\"mat-pseudo-checkbox\",4),2&t){const t=o.bc();o.ec(\"state\",t.selected?\"checked\":\"unchecked\")(\"disabled\",t.disabled)}}function wt(t,e){if(1&t&&(o.Sb(0,\"span\",5),o.uc(1),o.Rb()),2&t){const t=o.bc();o.Ab(1),o.wc(\"(\",t.group.label,\")\")}}const xt=[\"*\"],Ct=new o.P(\"11.2.13\"),kt=new o.q(\"mat-sanity-checks\",{providedIn:\"root\",factory:function(){return!0}});let St,Ot=(()=>{class t{constructor(t,e,i){this._hasDoneGlobalChecks=!1,this._document=i,t._applyBodyHighContrastModeCssClasses(),this._sanityChecks=e,this._hasDoneGlobalChecks||(this._checkDoctypeIsDefined(),this._checkThemeIsPresent(),this._checkCdkVersionMatch(),this._hasDoneGlobalChecks=!0)}_getWindow(){const t=this._document.defaultView||window;return\"object\"==typeof t&&t?t:null}_checksAreEnabled(){return Object(o.W)()&&!this._isTestEnv()}_isTestEnv(){const t=this._getWindow();return t&&(t.__karma__||t.jasmine)}_checkDoctypeIsDefined(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.doctype)&&!this._document.doctype&&console.warn(\"Current document does not have a doctype. This may cause some Angular Material components not to behave as expected.\")}_checkThemeIsPresent(){if(!this._checksAreEnabled()||!1===this._sanityChecks||!this._sanityChecks.theme||!this._document.body||\"function\"!=typeof getComputedStyle)return;const t=this._document.createElement(\"div\");t.classList.add(\"mat-theme-loaded-marker\"),this._document.body.appendChild(t);const e=getComputedStyle(t);e&&\"none\"!==e.display&&console.warn(\"Could not find Angular Material core theme. Most Material components may not work as expected. For more info refer to the theming guide: https://material.angular.io/guide/theming\"),this._document.body.removeChild(t)}_checkCdkVersionMatch(){this._checksAreEnabled()&&(!0===this._sanityChecks||this._sanityChecks.version)&&Ct.full!==gt.full&&console.warn(\"The Angular Material version (\"+Ct.full+\") does not match the Angular CDK version (\"+gt.full+\").\\nPlease ensure the versions of these two packages exactly match.\")}}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)(o.Wb(nt),o.Wb(kt,8),o.Wb(s.c))},imports:[[_t],_t]}),t})();function Rt(t){return class extends t{constructor(...t){super(...t),this._disabled=!1}get disabled(){return this._disabled}set disabled(t){this._disabled=k(t)}}}function It(t,e){return class extends t{constructor(...t){super(...t),this.defaultColor=e,this.color=e}get color(){return this._color}set color(t){const e=t||this.defaultColor;e!==this._color&&(this._color&&this._elementRef.nativeElement.classList.remove(\"mat-\"+this._color),e&&this._elementRef.nativeElement.classList.add(\"mat-\"+e),this._color=e)}}}function Et(t){return class extends t{constructor(...t){super(...t),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=k(t)}}}function Pt(t,e=0){return class extends t{constructor(...t){super(...t),this._tabIndex=e,this.defaultTabIndex=e}get tabIndex(){return this.disabled?-1:this._tabIndex}set tabIndex(t){this._tabIndex=null!=t?S(t):this.defaultTabIndex}}}function At(t){return class extends t{constructor(...t){super(...t),this.errorState=!1,this.stateChanges=new r.a}updateErrorState(){const t=this.errorState,e=(this.errorStateMatcher||this._defaultErrorStateMatcher).isErrorState(this.ngControl?this.ngControl.control:null,this._parentFormGroup||this._parentForm);e!==t&&(this.errorState=e,this.stateChanges.next())}}}try{St=\"undefined\"!=typeof Intl}catch(Cn){St=!1}let Mt=(()=>{class t{isErrorState(t,e){return!!(t&&t.invalid&&(t.touched||e&&e.submitted))}}return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t},token:t,providedIn:\"root\"}),t})();class Tt{constructor(t,e,i){this._renderer=t,this.element=e,this.config=i,this.state=3}fadeOut(){this._renderer.fadeOutRipple(this)}}const Dt={enterDuration:450,exitDuration:400},Lt=L({passive:!0}),Bt=[\"mousedown\",\"touchstart\"],jt=[\"mouseup\",\"mouseleave\",\"touchend\",\"touchcancel\"];class Ft{constructor(t,e,i,s){this._target=t,this._ngZone=e,this._isPointerDown=!1,this._activeRipples=new Set,this._pointerUpEventsRegistered=!1,s.isBrowser&&(this._containerElement=I(i))}fadeInRipple(t,e,i={}){const s=this._containerRect=this._containerRect||this._containerElement.getBoundingClientRect(),n=Object.assign(Object.assign({},Dt),i.animation);i.centered&&(t=s.left+s.width/2,e=s.top+s.height/2);const o=i.radius||function(t,e,i){const s=Math.max(Math.abs(t-i.left),Math.abs(t-i.right)),n=Math.max(Math.abs(e-i.top),Math.abs(e-i.bottom));return Math.sqrt(s*s+n*n)}(t,e,s),r=t-s.left,a=e-s.top,l=n.enterDuration,c=document.createElement(\"div\");c.classList.add(\"mat-ripple-element\"),c.style.left=r-o+\"px\",c.style.top=a-o+\"px\",c.style.height=2*o+\"px\",c.style.width=2*o+\"px\",null!=i.color&&(c.style.backgroundColor=i.color),c.style.transitionDuration=l+\"ms\",this._containerElement.appendChild(c),window.getComputedStyle(c).getPropertyValue(\"opacity\"),c.style.transform=\"scale(1)\";const h=new Tt(this,c,i);return h.state=0,this._activeRipples.add(h),i.persistent||(this._mostRecentTransientRipple=h),this._runTimeoutOutsideZone(()=>{const t=h===this._mostRecentTransientRipple;h.state=1,i.persistent||t&&this._isPointerDown||h.fadeOut()},l),h}fadeOutRipple(t){const e=this._activeRipples.delete(t);if(t===this._mostRecentTransientRipple&&(this._mostRecentTransientRipple=null),this._activeRipples.size||(this._containerRect=null),!e)return;const i=t.element,s=Object.assign(Object.assign({},Dt),t.config.animation);i.style.transitionDuration=s.exitDuration+\"ms\",i.style.opacity=\"0\",t.state=2,this._runTimeoutOutsideZone(()=>{t.state=3,i.parentNode.removeChild(i)},s.exitDuration)}fadeOutAll(){this._activeRipples.forEach(t=>t.fadeOut())}fadeOutAllNonPersistent(){this._activeRipples.forEach(t=>{t.config.persistent||t.fadeOut()})}setupTriggerEvents(t){const e=I(t);e&&e!==this._triggerElement&&(this._removeTriggerEvents(),this._triggerElement=e,this._registerEvents(Bt))}handleEvent(t){\"mousedown\"===t.type?this._onMousedown(t):\"touchstart\"===t.type?this._onTouchStart(t):this._onPointerUp(),this._pointerUpEventsRegistered||(this._registerEvents(jt),this._pointerUpEventsRegistered=!0)}_onMousedown(t){const e=Z(t),i=this._lastTouchStartEvent&&Date.now()<this._lastTouchStartEvent+800;this._target.rippleDisabled||e||i||(this._isPointerDown=!0,this.fadeInRipple(t.clientX,t.clientY,this._target.rippleConfig))}_onTouchStart(t){if(!this._target.rippleDisabled&&!G(t)){this._lastTouchStartEvent=Date.now(),this._isPointerDown=!0;const e=t.changedTouches;for(let t=0;t<e.length;t++)this.fadeInRipple(e[t].clientX,e[t].clientY,this._target.rippleConfig)}}_onPointerUp(){this._isPointerDown&&(this._isPointerDown=!1,this._activeRipples.forEach(t=>{!t.config.persistent&&(1===t.state||t.config.terminateOnPointerUp&&0===t.state)&&t.fadeOut()}))}_runTimeoutOutsideZone(t,e=0){this._ngZone.runOutsideAngular(()=>setTimeout(t,e))}_registerEvents(t){this._ngZone.runOutsideAngular(()=>{t.forEach(t=>{this._triggerElement.addEventListener(t,this,Lt)})})}_removeTriggerEvents(){this._triggerElement&&(Bt.forEach(t=>{this._triggerElement.removeEventListener(t,this,Lt)}),this._pointerUpEventsRegistered&&jt.forEach(t=>{this._triggerElement.removeEventListener(t,this,Lt)}))}}const Wt=new o.q(\"mat-ripple-global-options\");let Nt=(()=>{class t{constructor(t,e,i,s,n){this._elementRef=t,this._animationMode=n,this.radius=0,this._disabled=!1,this._isInitialized=!1,this._globalOptions=s||{},this._rippleRenderer=new Ft(this,e,t,i)}get disabled(){return this._disabled}set disabled(t){t&&this.fadeOutAllNonPersistent(),this._disabled=t,this._setupTriggerEventsIfEnabled()}get trigger(){return this._trigger||this._elementRef.nativeElement}set trigger(t){this._trigger=t,this._setupTriggerEventsIfEnabled()}ngOnInit(){this._isInitialized=!0,this._setupTriggerEventsIfEnabled()}ngOnDestroy(){this._rippleRenderer._removeTriggerEvents()}fadeOutAll(){this._rippleRenderer.fadeOutAll()}fadeOutAllNonPersistent(){this._rippleRenderer.fadeOutAllNonPersistent()}get rippleConfig(){return{centered:this.centered,radius:this.radius,color:this.color,animation:Object.assign(Object.assign(Object.assign({},this._globalOptions.animation),\"NoopAnimations\"===this._animationMode?{enterDuration:0,exitDuration:0}:{}),this.animation),terminateOnPointerUp:this._globalOptions.terminateOnPointerUp}}get rippleDisabled(){return this.disabled||!!this._globalOptions.disabled}_setupTriggerEventsIfEnabled(){!this.disabled&&this._isInitialized&&this._rippleRenderer.setupTriggerEvents(this.trigger)}launch(t,e=0,i){return\"number\"==typeof t?this._rippleRenderer.fadeInRipple(t,e,Object.assign(Object.assign({},this.rippleConfig),i)):this._rippleRenderer.fadeInRipple(0,0,Object.assign(Object.assign({},this.rippleConfig),t))}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb(o.A),o.Mb(T),o.Mb(Wt,8),o.Mb(vt.a,8))},t.\\u0275dir=o.Hb({type:t,selectors:[[\"\",\"mat-ripple\",\"\"],[\"\",\"matRipple\",\"\"]],hostAttrs:[1,\"mat-ripple\"],hostVars:2,hostBindings:function(t,e){2&t&&o.Eb(\"mat-ripple-unbounded\",e.unbounded)},inputs:{radius:[\"matRippleRadius\",\"radius\"],disabled:[\"matRippleDisabled\",\"disabled\"],trigger:[\"matRippleTrigger\",\"trigger\"],color:[\"matRippleColor\",\"color\"],unbounded:[\"matRippleUnbounded\",\"unbounded\"],centered:[\"matRippleCentered\",\"centered\"],animation:[\"matRippleAnimation\",\"animation\"]},exportAs:[\"matRipple\"]}),t})(),Ht=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},imports:[[Ot,D],Ot]}),t})(),Vt=(()=>{class t{constructor(t){this._animationMode=t,this.state=\"unchecked\",this.disabled=!1}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(vt.a,8))},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"mat-pseudo-checkbox\"]],hostAttrs:[1,\"mat-pseudo-checkbox\"],hostVars:8,hostBindings:function(t,e){2&t&&o.Eb(\"mat-pseudo-checkbox-indeterminate\",\"indeterminate\"===e.state)(\"mat-pseudo-checkbox-checked\",\"checked\"===e.state)(\"mat-pseudo-checkbox-disabled\",e.disabled)(\"_mat-animation-noopable\",\"NoopAnimations\"===e._animationMode)},inputs:{state:\"state\",disabled:\"disabled\"},decls:0,vars:0,template:function(t,e){},styles:['.mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:\"\";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}\\n'],encapsulation:2,changeDetection:0}),t})(),zt=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},imports:[[Ot]]}),t})();const Yt=new o.q(\"MAT_OPTION_PARENT_COMPONENT\");class Kt{}const Xt=Rt(Kt);let qt=0,Zt=(()=>{class t extends Xt{constructor(t){var e;super(),this._labelId=\"mat-optgroup-label-\"+qt++,this._inert=null!==(e=null==t?void 0:t.inertGroups)&&void 0!==e&&e}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(Yt,8))},t.\\u0275dir=o.Hb({type:t,inputs:{label:\"label\"},features:[o.xb]}),t})();const Gt=new o.q(\"MatOptgroup\");let Jt=0;class Ut{constructor(t,e=!1){this.source=t,this.isUserInput=e}}let $t=(()=>{class t{constructor(t,e,i,s){this._element=t,this._changeDetectorRef=e,this._parent=i,this.group=s,this._selected=!1,this._active=!1,this._disabled=!1,this._mostRecentViewValue=\"\",this.id=\"mat-option-\"+Jt++,this.onSelectionChange=new o.n,this._stateChanges=new r.a}get multiple(){return this._parent&&this._parent.multiple}get selected(){return this._selected}get disabled(){return this.group&&this.group.disabled||this._disabled}set disabled(t){this._disabled=k(t)}get disableRipple(){return this._parent&&this._parent.disableRipple}get active(){return this._active}get viewValue(){return(this._getHostElement().textContent||\"\").trim()}select(){this._selected||(this._selected=!0,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent())}deselect(){this._selected&&(this._selected=!1,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent())}focus(t,e){const i=this._getHostElement();\"function\"==typeof i.focus&&i.focus(e)}setActiveStyles(){this._active||(this._active=!0,this._changeDetectorRef.markForCheck())}setInactiveStyles(){this._active&&(this._active=!1,this._changeDetectorRef.markForCheck())}getLabel(){return this.viewValue}_handleKeydown(t){13!==t.keyCode&&32!==t.keyCode||c(t)||(this._selectViaInteraction(),t.preventDefault())}_selectViaInteraction(){this.disabled||(this._selected=!this.multiple||!this._selected,this._changeDetectorRef.markForCheck(),this._emitSelectionChangeEvent(!0))}_getAriaSelected(){return this.selected||!this.multiple&&null}_getTabIndex(){return this.disabled?\"-1\":\"0\"}_getHostElement(){return this._element.nativeElement}ngAfterViewChecked(){if(this._selected){const t=this.viewValue;t!==this._mostRecentViewValue&&(this._mostRecentViewValue=t,this._stateChanges.next())}}ngOnDestroy(){this._stateChanges.complete()}_emitSelectionChangeEvent(t=!1){this.onSelectionChange.emit(new Ut(this,t))}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb(o.h),o.Mb(void 0),o.Mb(Zt))},t.\\u0275dir=o.Hb({type:t,inputs:{id:\"id\",disabled:\"disabled\",value:\"value\"},outputs:{onSelectionChange:\"onSelectionChange\"}}),t})(),Qt=(()=>{class t extends $t{constructor(t,e,i,s){super(t,e,i,s)}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb(o.h),o.Mb(Yt,8),o.Mb(Gt,8))},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"mat-option\"]],hostAttrs:[\"role\",\"option\",1,\"mat-option\",\"mat-focus-indicator\"],hostVars:12,hostBindings:function(t,e){1&t&&o.Zb(\"click\",function(){return e._selectViaInteraction()})(\"keydown\",function(t){return e._handleKeydown(t)}),2&t&&(o.Vb(\"id\",e.id),o.Bb(\"tabindex\",e._getTabIndex())(\"aria-selected\",e._getAriaSelected())(\"aria-disabled\",e.disabled.toString()),o.Eb(\"mat-selected\",e.selected)(\"mat-option-multiple\",e.multiple)(\"mat-active\",e.active)(\"mat-option-disabled\",e.disabled))},exportAs:[\"matOption\"],features:[o.xb],ngContentSelectors:xt,decls:5,vars:4,consts:[[\"class\",\"mat-option-pseudo-checkbox\",3,\"state\",\"disabled\",4,\"ngIf\"],[1,\"mat-option-text\"],[\"class\",\"cdk-visually-hidden\",4,\"ngIf\"],[\"mat-ripple\",\"\",1,\"mat-option-ripple\",3,\"matRippleTrigger\",\"matRippleDisabled\"],[1,\"mat-option-pseudo-checkbox\",3,\"state\",\"disabled\"],[1,\"cdk-visually-hidden\"]],template:function(t,e){1&t&&(o.dc(),o.sc(0,yt,1,2,\"mat-pseudo-checkbox\",0),o.Sb(1,\"span\",1),o.cc(2),o.Rb(),o.sc(3,wt,2,1,\"span\",2),o.Nb(4,\"div\",3)),2&t&&(o.ec(\"ngIf\",e.multiple),o.Ab(3),o.ec(\"ngIf\",e.group&&e.group._inert),o.Ab(1),o.ec(\"matRippleTrigger\",e._getHostElement())(\"matRippleDisabled\",e.disabled||e.disableRipple))},directives:[s.j,Nt,Vt],styles:[\".mat-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative;cursor:pointer;outline:none;display:flex;flex-direction:row;max-width:100%;box-sizing:border-box;align-items:center;-webkit-tap-highlight-color:transparent}.mat-option[disabled]{cursor:default}[dir=rtl] .mat-option{text-align:right}.mat-option .mat-icon{margin-right:16px;vertical-align:middle}.mat-option .mat-icon svg{vertical-align:top}[dir=rtl] .mat-option .mat-icon{margin-left:16px;margin-right:0}.mat-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:32px}[dir=rtl] .mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:16px;padding-right:32px}.cdk-high-contrast-active .mat-option{margin:0 1px}.cdk-high-contrast-active .mat-option.mat-active{border:solid 1px currentColor;margin:0}.cdk-high-contrast-active .mat-option[aria-disabled=true]{opacity:.5}.mat-option-text{display:inline-block;flex-grow:1;overflow:hidden;text-overflow:ellipsis}.mat-option .mat-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-option-pseudo-checkbox{margin-right:8px}[dir=rtl] .mat-option-pseudo-checkbox{margin-left:8px;margin-right:0}\\n\"],encapsulation:2,changeDetection:0}),t})();function te(t,e,i){if(i.length){let s=e.toArray(),n=i.toArray(),o=0;for(let e=0;e<t+1;e++)s[e].group&&s[e].group===n[o]&&o++;return o}return 0}let ee=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},imports:[[Ht,s.b,Ot,zt]]}),t})();var ie=i(\"VRyK\"),se=i(\"DH7j\"),ne=i(\"n6bG\");function oe(t,e,i,s){return Object(ne.a)(i)&&(s=i,i=void 0),s?oe(t,e,i).pipe(Object(x.a)(t=>Object(se.a)(t)?s(...t):s(t))):new j.a(s=>{re(t,e,function(t){s.next(arguments.length>1?Array.prototype.slice.call(arguments):t)},s,i)})}function re(t,e,i,s,n){let o;if(function(t){return t&&\"function\"==typeof t.addEventListener&&\"function\"==typeof t.removeEventListener}(t)){const s=t;t.addEventListener(e,i,n),o=()=>s.removeEventListener(e,i,n)}else if(function(t){return t&&\"function\"==typeof t.on&&\"function\"==typeof t.off}(t)){const s=t;t.on(e,i),o=()=>s.off(e,i)}else if(function(t){return t&&\"function\"==typeof t.addListener&&\"function\"==typeof t.removeListener}(t)){const s=t;t.addListener(e,i),o=()=>s.removeListener(e,i)}else{if(!t||!t.length)throw new TypeError(\"Invalid event target\");for(let o=0,r=t.length;o<r;o++)re(t[o],e,i,s,n)}s.add(o)}function ae(t){return!Object(se.a)(t)&&t-parseFloat(t)+1>=0}var le=i(\"z+Ro\");function ce(t=0,e,i){let s=-1;return ae(e)?s=Number(e)<1?1:Number(e):Object(le.a)(e)&&(i=e),Object(le.a)(i)||(i=_),new j.a(e=>{const n=ae(t)?t:+t-i.now();return i.schedule(he,n,{index:0,period:s,subscriber:e})})}function he(t){const{index:e,period:i,subscriber:s}=t;if(s.next(e),!s.closed){if(-1===i)return s.complete();t.index=e+1,this.schedule(t,i)}}var de=i(\"R0Ic\");function ue(t,e){return i=>i.lift(new pe(t,e))}class pe{constructor(t,e){this.compare=t,this.keySelector=e}call(t,e){return e.subscribe(new be(t,this.compare,this.keySelector))}}class be extends d.a{constructor(t,e,i){super(t),this.keySelector=i,this.hasKey=!1,\"function\"==typeof e&&(this.compare=e)}compare(t,e){return t===e}_next(t){let e;try{const{keySelector:i}=this;e=i?i(t):t}catch(s){return this.destination.error(s)}let i=!1;if(this.hasKey)try{const{compare:t}=this;i=t(this.key,e)}catch(s){return this.destination.error(s)}else this.hasKey=!0;i||(this.key=e,this.destination.next(t))}}var me=i(\"zx2A\");function _e(t){return e=>e.lift(new ge(t))}class ge{constructor(t){this.notifier=t}call(t,e){const i=new fe(t),s=Object(me.c)(this.notifier,new me.a(i));return s&&!i.seenValue?(i.add(s),e.subscribe(i)):i}}class fe extends me.b{constructor(t){super(t),this.seenValue=!1}notifyNext(){this.seenValue=!0,this.complete()}notifyComplete(){}}class ve{constructor(t){this.durationSelector=t}call(t,e){return e.subscribe(new ye(t,this.durationSelector))}}class ye extends me.b{constructor(t,e){super(t),this.durationSelector=e,this.hasValue=!1}_next(t){if(this.value=t,this.hasValue=!0,!this.throttled){let i;try{const{durationSelector:e}=this;i=e(t)}catch(e){return this.destination.error(e)}const s=Object(me.c)(i,new me.a(this));!s||s.closed?this.clearThrottle():this.add(this.throttled=s)}}clearThrottle(){const{value:t,hasValue:e,throttled:i}=this;i&&(this.remove(i),this.throttled=void 0,i.unsubscribe()),e&&(this.value=void 0,this.hasValue=!1,this.destination.next(t))}notifyNext(){this.clearThrottle()}notifyComplete(){this.clearThrottle()}}function we(t,e=_){return i=()=>ce(t,e),function(t){return t.lift(new ve(i))};var i}var xe=i(\"eIep\");i(\"EY2u\"),i(\"9ppp\"),i(\"Ylt2\");class Ce{constructor(t=!1,e,i=!0){this._multiple=t,this._emitChanges=i,this._selection=new Set,this._deselectedToEmit=[],this._selectedToEmit=[],this.changed=new r.a,e&&e.length&&(t?e.forEach(t=>this._markSelected(t)):this._markSelected(e[0]),this._selectedToEmit.length=0)}get selected(){return this._selected||(this._selected=Array.from(this._selection.values())),this._selected}select(...t){this._verifyValueAssignment(t),t.forEach(t=>this._markSelected(t)),this._emitChangeEvent()}deselect(...t){this._verifyValueAssignment(t),t.forEach(t=>this._unmarkSelected(t)),this._emitChangeEvent()}toggle(t){this.isSelected(t)?this.deselect(t):this.select(t)}clear(){this._unmarkAll(),this._emitChangeEvent()}isSelected(t){return this._selection.has(t)}isEmpty(){return 0===this._selection.size}hasValue(){return!this.isEmpty()}sort(t){this._multiple&&this.selected&&this._selected.sort(t)}isMultipleSelection(){return this._multiple}_emitChangeEvent(){this._selected=null,(this._selectedToEmit.length||this._deselectedToEmit.length)&&(this.changed.next({source:this,added:this._selectedToEmit,removed:this._deselectedToEmit}),this._deselectedToEmit=[],this._selectedToEmit=[])}_markSelected(t){this.isSelected(t)||(this._multiple||this._unmarkAll(),this._selection.add(t),this._emitChanges&&this._selectedToEmit.push(t))}_unmarkSelected(t){this.isSelected(t)&&(this._selection.delete(t),this._emitChanges&&this._deselectedToEmit.push(t))}_unmarkAll(){this.isEmpty()||this._selection.forEach(t=>this._unmarkSelected(t))}_verifyValueAssignment(t){}}let ke=(()=>{class t{constructor(t,e,i){this._ngZone=t,this._platform=e,this._scrolled=new r.a,this._globalSubscription=null,this._scrolledCount=0,this.scrollContainers=new Map,this._document=i}register(t){this.scrollContainers.has(t)||this.scrollContainers.set(t,t.elementScrolled().subscribe(()=>this._scrolled.next(t)))}deregister(t){const e=this.scrollContainers.get(t);e&&(e.unsubscribe(),this.scrollContainers.delete(t))}scrolled(t=20){return this._platform.isBrowser?new j.a(e=>{this._globalSubscription||this._addGlobalListener();const i=t>0?this._scrolled.pipe(we(t)).subscribe(e):this._scrolled.subscribe(e);return this._scrolledCount++,()=>{i.unsubscribe(),this._scrolledCount--,this._scrolledCount||this._removeGlobalListener()}}):Object(l.a)()}ngOnDestroy(){this._removeGlobalListener(),this.scrollContainers.forEach((t,e)=>this.deregister(e)),this._scrolled.complete()}ancestorScrolled(t,e){const i=this.getAncestorScrollContainers(t);return this.scrolled(e).pipe(Object(w.a)(t=>!t||i.indexOf(t)>-1))}getAncestorScrollContainers(t){const e=[];return this.scrollContainers.forEach((i,s)=>{this._scrollableContainsElement(s,t)&&e.push(s)}),e}_getWindow(){return this._document.defaultView||window}_scrollableContainsElement(t,e){let i=I(e),s=t.getElementRef().nativeElement;do{if(i==s)return!0}while(i=i.parentElement);return!1}_addGlobalListener(){this._globalSubscription=this._ngZone.runOutsideAngular(()=>oe(this._getWindow().document,\"scroll\").subscribe(()=>this._scrolled.next()))}_removeGlobalListener(){this._globalSubscription&&(this._globalSubscription.unsubscribe(),this._globalSubscription=null)}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(o.A),o.Wb(T),o.Wb(s.c,8))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(o.A),Object(o.Wb)(T),Object(o.Wb)(s.c,8))},token:t,providedIn:\"root\"}),t})(),Se=(()=>{class t{constructor(t,e,i){this._platform=t,this._change=new r.a,this._changeListener=t=>{this._change.next(t)},this._document=i,e.runOutsideAngular(()=>{if(t.isBrowser){const t=this._getWindow();t.addEventListener(\"resize\",this._changeListener),t.addEventListener(\"orientationchange\",this._changeListener)}this.change().subscribe(()=>this._updateViewportSize())})}ngOnDestroy(){if(this._platform.isBrowser){const t=this._getWindow();t.removeEventListener(\"resize\",this._changeListener),t.removeEventListener(\"orientationchange\",this._changeListener)}this._change.complete()}getViewportSize(){this._viewportSize||this._updateViewportSize();const t={width:this._viewportSize.width,height:this._viewportSize.height};return this._platform.isBrowser||(this._viewportSize=null),t}getViewportRect(){const t=this.getViewportScrollPosition(),{width:e,height:i}=this.getViewportSize();return{top:t.top,left:t.left,bottom:t.top+i,right:t.left+e,height:i,width:e}}getViewportScrollPosition(){if(!this._platform.isBrowser)return{top:0,left:0};const t=this._document,e=this._getWindow(),i=t.documentElement,s=i.getBoundingClientRect();return{top:-s.top||t.body.scrollTop||e.scrollY||i.scrollTop||0,left:-s.left||t.body.scrollLeft||e.scrollX||i.scrollLeft||0}}change(t=20){return t>0?this._change.pipe(we(t)):this._change}_getWindow(){return this._document.defaultView||window}_updateViewportSize(){const t=this._getWindow();this._viewportSize=this._platform.isBrowser?{width:t.innerWidth,height:t.innerHeight}:{width:0,height:0}}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(T),o.Wb(o.A),o.Wb(s.c,8))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(T),Object(o.Wb)(o.A),Object(o.Wb)(s.c,8))},token:t,providedIn:\"root\"}),t})(),Oe=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)}}),t})(),Re=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},imports:[[_t,D,Oe],_t,Oe]}),t})();function Ie(t,e){1&t&&o.cc(0)}const Ee=[\"*\"];function Pe(t,e){}const Ae=function(t){return{animationDuration:t}},Me=function(t,e){return{value:t,params:e}},Te=[\"tabBodyWrapper\"],De=[\"tabHeader\"];function Le(t,e){}function Be(t,e){if(1&t&&o.sc(0,Le,0,0,\"ng-template\",9),2&t){const t=o.bc().$implicit;o.ec(\"cdkPortalOutlet\",t.templateLabel)}}function je(t,e){if(1&t&&o.uc(0),2&t){const t=o.bc().$implicit;o.vc(t.textLabel)}}function Fe(t,e){if(1&t){const t=o.Tb();o.Sb(0,\"div\",6),o.Zb(\"click\",function(){o.mc(t);const i=e.$implicit,s=e.index,n=o.bc(),r=o.lc(1);return n._handleClick(i,r,s)})(\"cdkFocusChange\",function(i){o.mc(t);const s=e.index;return o.bc()._tabFocusChanged(i,s)}),o.Sb(1,\"div\",7),o.sc(2,Be,1,1,\"ng-template\",8),o.sc(3,je,1,1,\"ng-template\",8),o.Rb(),o.Rb()}if(2&t){const t=e.$implicit,i=e.index,s=o.bc();o.Eb(\"mat-tab-label-active\",s.selectedIndex==i),o.ec(\"id\",s._getTabLabelId(i))(\"disabled\",t.disabled)(\"matRippleDisabled\",t.disabled||s.disableRipple),o.Bb(\"tabIndex\",s._getTabIndex(t,i))(\"aria-posinset\",i+1)(\"aria-setsize\",s._tabs.length)(\"aria-controls\",s._getTabContentId(i))(\"aria-selected\",s.selectedIndex==i)(\"aria-label\",t.ariaLabel||null)(\"aria-labelledby\",!t.ariaLabel&&t.ariaLabelledby?t.ariaLabelledby:null),o.Ab(2),o.ec(\"ngIf\",t.templateLabel),o.Ab(1),o.ec(\"ngIf\",!t.templateLabel)}}function We(t,e){if(1&t){const t=o.Tb();o.Sb(0,\"mat-tab-body\",10),o.Zb(\"_onCentered\",function(){return o.mc(t),o.bc()._removeTabBodyWrapperHeight()})(\"_onCentering\",function(e){return o.mc(t),o.bc()._setTabBodyWrapperHeight(e)}),o.Rb()}if(2&t){const t=e.$implicit,i=e.index,s=o.bc();o.Eb(\"mat-tab-body-active\",s.selectedIndex==i),o.ec(\"id\",s._getTabContentId(i))(\"content\",t.content)(\"position\",t.position)(\"origin\",t.origin)(\"animationDuration\",s.animationDuration),o.Bb(\"aria-labelledby\",s._getTabLabelId(i))}}const Ne=[\"tabListContainer\"],He=[\"tabList\"],Ve=[\"nextPaginator\"],ze=[\"previousPaginator\"],Ye=new o.q(\"MatInkBarPositioner\",{providedIn:\"root\",factory:function(){return t=>({left:t?(t.offsetLeft||0)+\"px\":\"0\",width:t?(t.offsetWidth||0)+\"px\":\"0\"})}});let Ke=(()=>{class t{constructor(t,e,i,s){this._elementRef=t,this._ngZone=e,this._inkBarPositioner=i,this._animationMode=s}alignToElement(t){this.show(),\"undefined\"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>this._setStyles(t))}):this._setStyles(t)}show(){this._elementRef.nativeElement.style.visibility=\"visible\"}hide(){this._elementRef.nativeElement.style.visibility=\"hidden\"}_setStyles(t){const e=this._inkBarPositioner(t),i=this._elementRef.nativeElement;i.style.left=e.left,i.style.width=e.width}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb(o.A),o.Mb(Ye),o.Mb(vt.a,8))},t.\\u0275dir=o.Hb({type:t,selectors:[[\"mat-ink-bar\"]],hostAttrs:[1,\"mat-ink-bar\"],hostVars:2,hostBindings:function(t,e){2&t&&o.Eb(\"_mat-animation-noopable\",\"NoopAnimations\"===e._animationMode)}}),t})();const Xe=new o.q(\"MatTabContent\"),qe=new o.q(\"MatTabLabel\");class Ze{}const Ge=Rt(Ze),Je=new o.q(\"MAT_TAB_GROUP\");let Ue=(()=>{class t extends Ge{constructor(t,e){super(),this._viewContainerRef=t,this._closestTabGroup=e,this.textLabel=\"\",this._contentPortal=null,this._stateChanges=new r.a,this.position=null,this.origin=null,this.isActive=!1}get templateLabel(){return this._templateLabel}set templateLabel(t){this._setTemplateLabelInput(t)}get content(){return this._contentPortal}ngOnChanges(t){(t.hasOwnProperty(\"textLabel\")||t.hasOwnProperty(\"disabled\"))&&this._stateChanges.next()}ngOnDestroy(){this._stateChanges.complete()}ngOnInit(){this._contentPortal=new lt(this._explicitContent||this._implicitContent,this._viewContainerRef)}_setTemplateLabelInput(t){t&&(this._templateLabel=t)}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.Q),o.Mb(Je))},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"mat-tab\"]],contentQueries:function(t,e,i){if(1&t&&(o.Fb(i,qe,!0),o.pc(i,Xe,!0,o.M)),2&t){let t;o.kc(t=o.ac())&&(e.templateLabel=t.first),o.kc(t=o.ac())&&(e._explicitContent=t.first)}},viewQuery:function(t,e){if(1&t&&o.qc(o.M,!0),2&t){let t;o.kc(t=o.ac())&&(e._implicitContent=t.first)}},inputs:{disabled:\"disabled\",textLabel:[\"label\",\"textLabel\"],ariaLabel:[\"aria-label\",\"ariaLabel\"],ariaLabelledby:[\"aria-labelledby\",\"ariaLabelledby\"]},exportAs:[\"matTab\"],features:[o.xb,o.yb],ngContentSelectors:Ee,decls:1,vars:0,template:function(t,e){1&t&&(o.dc(),o.sc(0,Ie,1,0,\"ng-template\"))},encapsulation:2}),t})();const $e={translateTab:Object(de.l)(\"translateTab\",[Object(de.i)(\"center, void, left-origin-center, right-origin-center\",Object(de.j)({transform:\"none\"})),Object(de.i)(\"left\",Object(de.j)({transform:\"translate3d(-100%, 0, 0)\",minHeight:\"1px\"})),Object(de.i)(\"right\",Object(de.j)({transform:\"translate3d(100%, 0, 0)\",minHeight:\"1px\"})),Object(de.k)(\"* => left, * => right, left => center, right => center\",Object(de.e)(\"{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)\")),Object(de.k)(\"void => left-origin-center\",[Object(de.j)({transform:\"translate3d(-100%, 0, 0)\"}),Object(de.e)(\"{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)\")]),Object(de.k)(\"void => right-origin-center\",[Object(de.j)({transform:\"translate3d(100%, 0, 0)\"}),Object(de.e)(\"{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)\")])])};let Qe=(()=>{class t extends ut{constructor(t,e,i,s){super(t,e,s),this._host=i,this._centeringSub=a.a.EMPTY,this._leavingSub=a.a.EMPTY}ngOnInit(){super.ngOnInit(),this._centeringSub=this._host._beforeCentering.pipe(Object(ft.a)(this._host._isCenterPosition(this._host._position))).subscribe(t=>{t&&!this.hasAttached()&&this.attach(this._host._content)}),this._leavingSub=this._host._afterLeavingCenter.subscribe(()=>{this.detach()})}ngOnDestroy(){super.ngOnDestroy(),this._centeringSub.unsubscribe(),this._leavingSub.unsubscribe()}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.j),o.Mb(o.Q),o.Mb(Object(o.U)(()=>ei)),o.Mb(s.c))},t.\\u0275dir=o.Hb({type:t,selectors:[[\"\",\"matTabBodyHost\",\"\"]],features:[o.xb]}),t})(),ti=(()=>{class t{constructor(t,e,i){this._elementRef=t,this._dir=e,this._dirChangeSubscription=a.a.EMPTY,this._translateTabComplete=new r.a,this._onCentering=new o.n,this._beforeCentering=new o.n,this._afterLeavingCenter=new o.n,this._onCentered=new o.n(!0),this.animationDuration=\"500ms\",e&&(this._dirChangeSubscription=e.change.subscribe(t=>{this._computePositionAnimationState(t),i.markForCheck()})),this._translateTabComplete.pipe(ue((t,e)=>t.fromState===e.fromState&&t.toState===e.toState)).subscribe(t=>{this._isCenterPosition(t.toState)&&this._isCenterPosition(this._position)&&this._onCentered.emit(),this._isCenterPosition(t.fromState)&&!this._isCenterPosition(this._position)&&this._afterLeavingCenter.emit()})}set position(t){this._positionIndex=t,this._computePositionAnimationState()}ngOnInit(){\"center\"==this._position&&null!=this.origin&&(this._position=this._computePositionFromOrigin(this.origin))}ngOnDestroy(){this._dirChangeSubscription.unsubscribe(),this._translateTabComplete.complete()}_onTranslateTabStarted(t){const e=this._isCenterPosition(t.toState);this._beforeCentering.emit(e),e&&this._onCentering.emit(this._elementRef.nativeElement.clientHeight)}_getLayoutDirection(){return this._dir&&\"rtl\"===this._dir.value?\"rtl\":\"ltr\"}_isCenterPosition(t){return\"center\"==t||\"left-origin-center\"==t||\"right-origin-center\"==t}_computePositionAnimationState(t=this._getLayoutDirection()){this._position=this._positionIndex<0?\"ltr\"==t?\"left\":\"right\":this._positionIndex>0?\"ltr\"==t?\"right\":\"left\":\"center\"}_computePositionFromOrigin(t){const e=this._getLayoutDirection();return\"ltr\"==e&&t<=0||\"rtl\"==e&&t>0?\"left-origin-center\":\"right-origin-center\"}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb(mt,8),o.Mb(o.h))},t.\\u0275dir=o.Hb({type:t,inputs:{animationDuration:\"animationDuration\",position:\"position\",_content:[\"content\",\"_content\"],origin:\"origin\"},outputs:{_onCentering:\"_onCentering\",_beforeCentering:\"_beforeCentering\",_afterLeavingCenter:\"_afterLeavingCenter\",_onCentered:\"_onCentered\"}}),t})(),ei=(()=>{class t extends ti{constructor(t,e,i){super(t,e,i)}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb(mt,8),o.Mb(o.h))},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"mat-tab-body\"]],viewQuery:function(t,e){if(1&t&&o.xc(ut,!0),2&t){let t;o.kc(t=o.ac())&&(e._portalHost=t.first)}},hostAttrs:[1,\"mat-tab-body\"],features:[o.xb],decls:3,vars:6,consts:[[\"cdkScrollable\",\"\",1,\"mat-tab-body-content\"],[\"content\",\"\"],[\"matTabBodyHost\",\"\"]],template:function(t,e){1&t&&(o.Sb(0,\"div\",0,1),o.Zb(\"@translateTab.start\",function(t){return e._onTranslateTabStarted(t)})(\"@translateTab.done\",function(t){return e._translateTabComplete.next(t)}),o.sc(2,Pe,0,0,\"ng-template\",2),o.Rb()),2&t&&o.ec(\"@translateTab\",o.gc(3,Me,e._position,o.fc(1,Ae,e.animationDuration)))},directives:[Qe],styles:[\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\\n\"],encapsulation:2,data:{animation:[$e.translateTab]}}),t})();const ii=new o.q(\"MAT_TABS_CONFIG\");let si=0;class ni{}class oi{constructor(t){this._elementRef=t}}const ri=It(Et(oi),\"primary\");let ai=(()=>{class t extends ri{constructor(t,e,i,s){super(t),this._changeDetectorRef=e,this._animationMode=s,this._tabs=new o.E,this._indexToSelect=0,this._tabBodyWrapperHeight=0,this._tabsSubscription=a.a.EMPTY,this._tabLabelSubscription=a.a.EMPTY,this._selectedIndex=null,this.headerPosition=\"above\",this.selectedIndexChange=new o.n,this.focusChange=new o.n,this.animationDone=new o.n,this.selectedTabChange=new o.n(!0),this._groupId=si++,this.animationDuration=i&&i.animationDuration?i.animationDuration:\"500ms\",this.disablePagination=!(!i||null==i.disablePagination)&&i.disablePagination,this.dynamicHeight=!(!i||null==i.dynamicHeight)&&i.dynamicHeight}get dynamicHeight(){return this._dynamicHeight}set dynamicHeight(t){this._dynamicHeight=k(t)}get selectedIndex(){return this._selectedIndex}set selectedIndex(t){this._indexToSelect=S(t,null)}get animationDuration(){return this._animationDuration}set animationDuration(t){this._animationDuration=/^\\d+$/.test(t)?t+\"ms\":t}get backgroundColor(){return this._backgroundColor}set backgroundColor(t){const e=this._elementRef.nativeElement;e.classList.remove(\"mat-background-\"+this.backgroundColor),t&&e.classList.add(\"mat-background-\"+t),this._backgroundColor=t}ngAfterContentChecked(){const t=this._indexToSelect=this._clampTabIndex(this._indexToSelect);if(this._selectedIndex!=t){const e=null==this._selectedIndex;if(!e){this.selectedTabChange.emit(this._createChangeEvent(t));const e=this._tabBodyWrapper.nativeElement;e.style.minHeight=e.clientHeight+\"px\"}Promise.resolve().then(()=>{this._tabs.forEach((e,i)=>e.isActive=i===t),e||(this.selectedIndexChange.emit(t),this._tabBodyWrapper.nativeElement.style.minHeight=\"\")})}this._tabs.forEach((e,i)=>{e.position=i-t,null==this._selectedIndex||0!=e.position||e.origin||(e.origin=t-this._selectedIndex)}),this._selectedIndex!==t&&(this._selectedIndex=t,this._changeDetectorRef.markForCheck())}ngAfterContentInit(){this._subscribeToAllTabChanges(),this._subscribeToTabLabels(),this._tabsSubscription=this._tabs.changes.subscribe(()=>{if(this._clampTabIndex(this._indexToSelect)===this._selectedIndex){const t=this._tabs.toArray();for(let e=0;e<t.length;e++)if(t[e].isActive){this._indexToSelect=this._selectedIndex=e;break}}this._changeDetectorRef.markForCheck()})}_subscribeToAllTabChanges(){this._allTabs.changes.pipe(Object(ft.a)(this._allTabs)).subscribe(t=>{this._tabs.reset(t.filter(t=>t._closestTabGroup===this)),this._tabs.notifyOnChanges()})}ngOnDestroy(){this._tabs.destroy(),this._tabsSubscription.unsubscribe(),this._tabLabelSubscription.unsubscribe()}realignInkBar(){this._tabHeader&&this._tabHeader._alignInkBarToSelectedTab()}_focusChanged(t){this.focusChange.emit(this._createChangeEvent(t))}_createChangeEvent(t){const e=new ni;return e.index=t,this._tabs&&this._tabs.length&&(e.tab=this._tabs.toArray()[t]),e}_subscribeToTabLabels(){this._tabLabelSubscription&&this._tabLabelSubscription.unsubscribe(),this._tabLabelSubscription=Object(ie.a)(...this._tabs.map(t=>t._stateChanges)).subscribe(()=>this._changeDetectorRef.markForCheck())}_clampTabIndex(t){return Math.min(this._tabs.length-1,Math.max(t||0,0))}_getTabLabelId(t){return`mat-tab-label-${this._groupId}-${t}`}_getTabContentId(t){return`mat-tab-content-${this._groupId}-${t}`}_setTabBodyWrapperHeight(t){if(!this._dynamicHeight||!this._tabBodyWrapperHeight)return;const e=this._tabBodyWrapper.nativeElement;e.style.height=this._tabBodyWrapperHeight+\"px\",this._tabBodyWrapper.nativeElement.offsetHeight&&(e.style.height=t+\"px\")}_removeTabBodyWrapperHeight(){const t=this._tabBodyWrapper.nativeElement;this._tabBodyWrapperHeight=t.clientHeight,t.style.height=\"\",this.animationDone.emit()}_handleClick(t,e,i){t.disabled||(this.selectedIndex=e.focusIndex=i)}_getTabIndex(t,e){return t.disabled?null:this.selectedIndex===e?0:-1}_tabFocusChanged(t,e){t&&(this._tabHeader.focusIndex=e)}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb(o.h),o.Mb(ii,8),o.Mb(vt.a,8))},t.\\u0275dir=o.Hb({type:t,inputs:{headerPosition:\"headerPosition\",animationDuration:\"animationDuration\",disablePagination:\"disablePagination\",dynamicHeight:\"dynamicHeight\",selectedIndex:\"selectedIndex\",backgroundColor:\"backgroundColor\"},outputs:{selectedIndexChange:\"selectedIndexChange\",focusChange:\"focusChange\",animationDone:\"animationDone\",selectedTabChange:\"selectedTabChange\"},features:[o.xb]}),t})(),li=(()=>{class t extends ai{constructor(t,e,i,s){super(t,e,i,s)}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb(o.h),o.Mb(ii,8),o.Mb(vt.a,8))},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"mat-tab-group\"]],contentQueries:function(t,e,i){if(1&t&&o.Fb(i,Ue,!0),2&t){let t;o.kc(t=o.ac())&&(e._allTabs=t)}},viewQuery:function(t,e){if(1&t&&(o.xc(Te,!0),o.xc(De,!0)),2&t){let t;o.kc(t=o.ac())&&(e._tabBodyWrapper=t.first),o.kc(t=o.ac())&&(e._tabHeader=t.first)}},hostAttrs:[1,\"mat-tab-group\"],hostVars:4,hostBindings:function(t,e){2&t&&o.Eb(\"mat-tab-group-dynamic-height\",e.dynamicHeight)(\"mat-tab-group-inverted-header\",\"below\"===e.headerPosition)},inputs:{color:\"color\",disableRipple:\"disableRipple\"},exportAs:[\"matTabGroup\"],features:[o.zb([{provide:Je,useExisting:t}]),o.xb],decls:6,vars:7,consts:[[3,\"selectedIndex\",\"disableRipple\",\"disablePagination\",\"indexFocused\",\"selectFocusedIndex\"],[\"tabHeader\",\"\"],[\"class\",\"mat-tab-label mat-focus-indicator\",\"role\",\"tab\",\"matTabLabelWrapper\",\"\",\"mat-ripple\",\"\",\"cdkMonitorElementFocus\",\"\",3,\"id\",\"mat-tab-label-active\",\"disabled\",\"matRippleDisabled\",\"click\",\"cdkFocusChange\",4,\"ngFor\",\"ngForOf\"],[1,\"mat-tab-body-wrapper\"],[\"tabBodyWrapper\",\"\"],[\"role\",\"tabpanel\",3,\"id\",\"mat-tab-body-active\",\"content\",\"position\",\"origin\",\"animationDuration\",\"_onCentered\",\"_onCentering\",4,\"ngFor\",\"ngForOf\"],[\"role\",\"tab\",\"matTabLabelWrapper\",\"\",\"mat-ripple\",\"\",\"cdkMonitorElementFocus\",\"\",1,\"mat-tab-label\",\"mat-focus-indicator\",3,\"id\",\"disabled\",\"matRippleDisabled\",\"click\",\"cdkFocusChange\"],[1,\"mat-tab-label-content\"],[3,\"ngIf\"],[3,\"cdkPortalOutlet\"],[\"role\",\"tabpanel\",3,\"id\",\"content\",\"position\",\"origin\",\"animationDuration\",\"_onCentered\",\"_onCentering\"]],template:function(t,e){1&t&&(o.Sb(0,\"mat-tab-header\",0,1),o.Zb(\"indexFocused\",function(t){return e._focusChanged(t)})(\"selectFocusedIndex\",function(t){return e.selectedIndex=t}),o.sc(2,Fe,4,14,\"div\",2),o.Rb(),o.Sb(3,\"div\",3,4),o.sc(5,We,1,8,\"mat-tab-body\",5),o.Rb()),2&t&&(o.ec(\"selectedIndex\",e.selectedIndex||0)(\"disableRipple\",e.disableRipple)(\"disablePagination\",e.disablePagination),o.Ab(2),o.ec(\"ngForOf\",e._tabs),o.Ab(1),o.Eb(\"_mat-animation-noopable\",\"NoopAnimations\"===e._animationMode),o.Ab(2),o.ec(\"ngForOf\",e._tabs))},directives:function(){return[mi,s.i,di,Nt,tt,s.j,ut,ei]},styles:[\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\\n\"],encapsulation:2}),t})();class ci{}const hi=Rt(ci);let di=(()=>{class t extends hi{constructor(t){super(),this.elementRef=t}focus(){this.elementRef.nativeElement.focus()}getOffsetLeft(){return this.elementRef.nativeElement.offsetLeft}getOffsetWidth(){return this.elementRef.nativeElement.offsetWidth}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l))},t.\\u0275dir=o.Hb({type:t,selectors:[[\"\",\"matTabLabelWrapper\",\"\"]],hostVars:3,hostBindings:function(t,e){2&t&&(o.Bb(\"aria-disabled\",!!e.disabled),o.Eb(\"mat-tab-disabled\",e.disabled))},inputs:{disabled:\"disabled\"},features:[o.xb]}),t})();const ui=L({passive:!0});let pi=(()=>{class t{constructor(t,e,i,s,n,a,l){this._elementRef=t,this._changeDetectorRef=e,this._viewportRuler=i,this._dir=s,this._ngZone=n,this._platform=a,this._animationMode=l,this._scrollDistance=0,this._selectedIndexChanged=!1,this._destroyed=new r.a,this._showPaginationControls=!1,this._disableScrollAfter=!0,this._disableScrollBefore=!0,this._stopScrolling=new r.a,this.disablePagination=!1,this._selectedIndex=0,this.selectFocusedIndex=new o.n,this.indexFocused=new o.n,n.runOutsideAngular(()=>{oe(t.nativeElement,\"mouseleave\").pipe(_e(this._destroyed)).subscribe(()=>{this._stopInterval()})})}get selectedIndex(){return this._selectedIndex}set selectedIndex(t){t=S(t),this._selectedIndex!=t&&(this._selectedIndexChanged=!0,this._selectedIndex=t,this._keyManager&&this._keyManager.updateActiveItem(t))}ngAfterViewInit(){oe(this._previousPaginator.nativeElement,\"touchstart\",ui).pipe(_e(this._destroyed)).subscribe(()=>{this._handlePaginatorPress(\"before\")}),oe(this._nextPaginator.nativeElement,\"touchstart\",ui).pipe(_e(this._destroyed)).subscribe(()=>{this._handlePaginatorPress(\"after\")})}ngAfterContentInit(){const t=this._dir?this._dir.change:Object(l.a)(null),e=this._viewportRuler.change(150),i=()=>{this.updatePagination(),this._alignInkBarToSelectedTab()};this._keyManager=new Y(this._items).withHorizontalOrientation(this._getLayoutDirection()).withHomeAndEnd().withWrap(),this._keyManager.updateActiveItem(this._selectedIndex),\"undefined\"!=typeof requestAnimationFrame?requestAnimationFrame(i):i(),Object(ie.a)(t,e,this._items.changes).pipe(_e(this._destroyed)).subscribe(()=>{this._ngZone.run(()=>Promise.resolve().then(i)),this._keyManager.withHorizontalOrientation(this._getLayoutDirection())}),this._keyManager.change.pipe(_e(this._destroyed)).subscribe(t=>{this.indexFocused.emit(t),this._setTabFocus(t)})}ngAfterContentChecked(){this._tabLabelCount!=this._items.length&&(this.updatePagination(),this._tabLabelCount=this._items.length,this._changeDetectorRef.markForCheck()),this._selectedIndexChanged&&(this._scrollToLabel(this._selectedIndex),this._checkScrollingControls(),this._alignInkBarToSelectedTab(),this._selectedIndexChanged=!1,this._changeDetectorRef.markForCheck()),this._scrollDistanceChanged&&(this._updateTabScrollPosition(),this._scrollDistanceChanged=!1,this._changeDetectorRef.markForCheck())}ngOnDestroy(){this._destroyed.next(),this._destroyed.complete(),this._stopScrolling.complete()}_handleKeydown(t){if(!c(t))switch(t.keyCode){case 13:case 32:this.focusIndex!==this.selectedIndex&&(this.selectFocusedIndex.emit(this.focusIndex),this._itemSelected(t));break;default:this._keyManager.onKeydown(t)}}_onContentChanges(){const t=this._elementRef.nativeElement.textContent;t!==this._currentTextContent&&(this._currentTextContent=t||\"\",this._ngZone.run(()=>{this.updatePagination(),this._alignInkBarToSelectedTab(),this._changeDetectorRef.markForCheck()}))}updatePagination(){this._checkPaginationEnabled(),this._checkScrollingControls(),this._updateTabScrollPosition()}get focusIndex(){return this._keyManager?this._keyManager.activeItemIndex:0}set focusIndex(t){this._isValidIndex(t)&&this.focusIndex!==t&&this._keyManager&&this._keyManager.setActiveItem(t)}_isValidIndex(t){if(!this._items)return!0;const e=this._items?this._items.toArray()[t]:null;return!!e&&!e.disabled}_setTabFocus(t){if(this._showPaginationControls&&this._scrollToLabel(t),this._items&&this._items.length){this._items.toArray()[t].focus();const e=this._tabListContainer.nativeElement,i=this._getLayoutDirection();e.scrollLeft=\"ltr\"==i?0:e.scrollWidth-e.offsetWidth}}_getLayoutDirection(){return this._dir&&\"rtl\"===this._dir.value?\"rtl\":\"ltr\"}_updateTabScrollPosition(){if(this.disablePagination)return;const t=this.scrollDistance,e=\"ltr\"===this._getLayoutDirection()?-t:t;this._tabList.nativeElement.style.transform=`translateX(${Math.round(e)}px)`,(this._platform.TRIDENT||this._platform.EDGE)&&(this._tabListContainer.nativeElement.scrollLeft=0)}get scrollDistance(){return this._scrollDistance}set scrollDistance(t){this._scrollTo(t)}_scrollHeader(t){return this._scrollTo(this._scrollDistance+(\"before\"==t?-1:1)*this._tabListContainer.nativeElement.offsetWidth/3)}_handlePaginatorClick(t){this._stopInterval(),this._scrollHeader(t)}_scrollToLabel(t){if(this.disablePagination)return;const e=this._items?this._items.toArray()[t]:null;if(!e)return;const i=this._tabListContainer.nativeElement.offsetWidth,{offsetLeft:s,offsetWidth:n}=e.elementRef.nativeElement;let o,r;\"ltr\"==this._getLayoutDirection()?(o=s,r=o+n):(r=this._tabList.nativeElement.offsetWidth-s,o=r-n);const a=this.scrollDistance,l=this.scrollDistance+i;o<a?this.scrollDistance-=a-o+60:r>l&&(this.scrollDistance+=r-l+60)}_checkPaginationEnabled(){if(this.disablePagination)this._showPaginationControls=!1;else{const t=this._tabList.nativeElement.scrollWidth>this._elementRef.nativeElement.offsetWidth;t||(this.scrollDistance=0),t!==this._showPaginationControls&&this._changeDetectorRef.markForCheck(),this._showPaginationControls=t}}_checkScrollingControls(){this.disablePagination?this._disableScrollAfter=this._disableScrollBefore=!0:(this._disableScrollBefore=0==this.scrollDistance,this._disableScrollAfter=this.scrollDistance==this._getMaxScrollDistance(),this._changeDetectorRef.markForCheck())}_getMaxScrollDistance(){return this._tabList.nativeElement.scrollWidth-this._tabListContainer.nativeElement.offsetWidth||0}_alignInkBarToSelectedTab(){const t=this._items&&this._items.length?this._items.toArray()[this.selectedIndex]:null,e=t?t.elementRef.nativeElement:null;e?this._inkBar.alignToElement(e):this._inkBar.hide()}_stopInterval(){this._stopScrolling.next()}_handlePaginatorPress(t,e){e&&null!=e.button&&0!==e.button||(this._stopInterval(),ce(650,100).pipe(_e(Object(ie.a)(this._stopScrolling,this._destroyed))).subscribe(()=>{const{maxScrollDistance:e,distance:i}=this._scrollHeader(t);(0===i||i>=e)&&this._stopInterval()}))}_scrollTo(t){if(this.disablePagination)return{maxScrollDistance:0,distance:0};const e=this._getMaxScrollDistance();return this._scrollDistance=Math.max(0,Math.min(e,t)),this._scrollDistanceChanged=!0,this._checkScrollingControls(),{maxScrollDistance:e,distance:this._scrollDistance}}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb(o.h),o.Mb(Se),o.Mb(mt,8),o.Mb(o.A),o.Mb(T),o.Mb(vt.a,8))},t.\\u0275dir=o.Hb({type:t,inputs:{disablePagination:\"disablePagination\"}}),t})(),bi=(()=>{class t extends pi{constructor(t,e,i,s,n,o,r){super(t,e,i,s,n,o,r),this._disableRipple=!1}get disableRipple(){return this._disableRipple}set disableRipple(t){this._disableRipple=k(t)}_itemSelected(t){t.preventDefault()}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb(o.h),o.Mb(Se),o.Mb(mt,8),o.Mb(o.A),o.Mb(T),o.Mb(vt.a,8))},t.\\u0275dir=o.Hb({type:t,inputs:{disableRipple:\"disableRipple\"},features:[o.xb]}),t})(),mi=(()=>{class t extends bi{constructor(t,e,i,s,n,o,r){super(t,e,i,s,n,o,r)}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb(o.h),o.Mb(Se),o.Mb(mt,8),o.Mb(o.A),o.Mb(T),o.Mb(vt.a,8))},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"mat-tab-header\"]],contentQueries:function(t,e,i){if(1&t&&o.Fb(i,di,!1),2&t){let t;o.kc(t=o.ac())&&(e._items=t)}},viewQuery:function(t,e){if(1&t&&(o.qc(Ke,!0),o.qc(Ne,!0),o.qc(He,!0),o.xc(Ve,!0),o.xc(ze,!0)),2&t){let t;o.kc(t=o.ac())&&(e._inkBar=t.first),o.kc(t=o.ac())&&(e._tabListContainer=t.first),o.kc(t=o.ac())&&(e._tabList=t.first),o.kc(t=o.ac())&&(e._nextPaginator=t.first),o.kc(t=o.ac())&&(e._previousPaginator=t.first)}},hostAttrs:[1,\"mat-tab-header\"],hostVars:4,hostBindings:function(t,e){2&t&&o.Eb(\"mat-tab-header-pagination-controls-enabled\",e._showPaginationControls)(\"mat-tab-header-rtl\",\"rtl\"==e._getLayoutDirection())},inputs:{selectedIndex:\"selectedIndex\"},outputs:{selectFocusedIndex:\"selectFocusedIndex\",indexFocused:\"indexFocused\"},features:[o.xb],ngContentSelectors:Ee,decls:13,vars:8,consts:[[\"aria-hidden\",\"true\",\"mat-ripple\",\"\",1,\"mat-tab-header-pagination\",\"mat-tab-header-pagination-before\",\"mat-elevation-z4\",3,\"matRippleDisabled\",\"click\",\"mousedown\",\"touchend\"],[\"previousPaginator\",\"\"],[1,\"mat-tab-header-pagination-chevron\"],[1,\"mat-tab-label-container\",3,\"keydown\"],[\"tabListContainer\",\"\"],[\"role\",\"tablist\",1,\"mat-tab-list\",3,\"cdkObserveContent\"],[\"tabList\",\"\"],[1,\"mat-tab-labels\"],[\"aria-hidden\",\"true\",\"mat-ripple\",\"\",1,\"mat-tab-header-pagination\",\"mat-tab-header-pagination-after\",\"mat-elevation-z4\",3,\"matRippleDisabled\",\"mousedown\",\"click\",\"touchend\"],[\"nextPaginator\",\"\"]],template:function(t,e){1&t&&(o.dc(),o.Sb(0,\"div\",0,1),o.Zb(\"click\",function(){return e._handlePaginatorClick(\"before\")})(\"mousedown\",function(t){return e._handlePaginatorPress(\"before\",t)})(\"touchend\",function(){return e._stopInterval()}),o.Nb(2,\"div\",2),o.Rb(),o.Sb(3,\"div\",3,4),o.Zb(\"keydown\",function(t){return e._handleKeydown(t)}),o.Sb(5,\"div\",5,6),o.Zb(\"cdkObserveContent\",function(){return e._onContentChanges()}),o.Sb(7,\"div\",7),o.cc(8),o.Rb(),o.Nb(9,\"mat-ink-bar\"),o.Rb(),o.Rb(),o.Sb(10,\"div\",8,9),o.Zb(\"mousedown\",function(t){return e._handlePaginatorPress(\"after\",t)})(\"click\",function(){return e._handlePaginatorClick(\"after\")})(\"touchend\",function(){return e._stopInterval()}),o.Nb(12,\"div\",2),o.Rb()),2&t&&(o.Eb(\"mat-tab-header-pagination-disabled\",e._disableScrollBefore),o.ec(\"matRippleDisabled\",e._disableScrollBefore||e.disableRipple),o.Ab(5),o.Eb(\"_mat-animation-noopable\",\"NoopAnimations\"===e._animationMode),o.Ab(5),o.Eb(\"mat-tab-header-pagination-disabled\",e._disableScrollAfter),o.ec(\"matRippleDisabled\",e._disableScrollAfter||e.disableRipple))},directives:[Nt,N,Ke],styles:['.mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\"\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-labels{display:flex}[mat-align-tabs=center]>.mat-tab-header .mat-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-tab-header .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\\n'],encapsulation:2}),t})(),_i=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},imports:[[s.b,Ot,pt,Ht,H,ot],Ot]}),t})();const gi=[\"mat-button\",\"\"],fi=[\"*\"],vi=[\"mat-button\",\"mat-flat-button\",\"mat-icon-button\",\"mat-raised-button\",\"mat-stroked-button\",\"mat-mini-fab\",\"mat-fab\"];class yi{constructor(t){this._elementRef=t}}const wi=It(Rt(Et(yi)));let xi=(()=>{class t extends wi{constructor(t,e,i){super(t),this._focusMonitor=e,this._animationMode=i,this.isRoundButton=this._hasHostAttributes(\"mat-fab\",\"mat-mini-fab\"),this.isIconButton=this._hasHostAttributes(\"mat-icon-button\");for(const s of vi)this._hasHostAttributes(s)&&this._getHostElement().classList.add(s);t.nativeElement.classList.add(\"mat-button-base\"),this.isRoundButton&&(this.color=\"accent\")}ngAfterViewInit(){this._focusMonitor.monitor(this._elementRef,!0)}ngOnDestroy(){this._focusMonitor.stopMonitoring(this._elementRef)}focus(t,e){t?this._focusMonitor.focusVia(this._getHostElement(),t,e):this._getHostElement().focus(e)}_getHostElement(){return this._elementRef.nativeElement}_isRippleDisabled(){return this.disableRipple||this.disabled}_hasHostAttributes(...t){return t.some(t=>this._getHostElement().hasAttribute(t))}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l),o.Mb($),o.Mb(vt.a,8))},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"button\",\"mat-button\",\"\"],[\"button\",\"mat-raised-button\",\"\"],[\"button\",\"mat-icon-button\",\"\"],[\"button\",\"mat-fab\",\"\"],[\"button\",\"mat-mini-fab\",\"\"],[\"button\",\"mat-stroked-button\",\"\"],[\"button\",\"mat-flat-button\",\"\"]],viewQuery:function(t,e){if(1&t&&o.xc(Nt,!0),2&t){let t;o.kc(t=o.ac())&&(e.ripple=t.first)}},hostAttrs:[1,\"mat-focus-indicator\"],hostVars:5,hostBindings:function(t,e){2&t&&(o.Bb(\"disabled\",e.disabled||null),o.Eb(\"_mat-animation-noopable\",\"NoopAnimations\"===e._animationMode)(\"mat-button-disabled\",e.disabled))},inputs:{disabled:\"disabled\",disableRipple:\"disableRipple\",color:\"color\"},exportAs:[\"matButton\"],features:[o.xb],attrs:gi,ngContentSelectors:fi,decls:4,vars:5,consts:[[1,\"mat-button-wrapper\"],[\"matRipple\",\"\",1,\"mat-button-ripple\",3,\"matRippleDisabled\",\"matRippleCentered\",\"matRippleTrigger\"],[1,\"mat-button-focus-overlay\"]],template:function(t,e){1&t&&(o.dc(),o.Sb(0,\"span\",0),o.cc(1),o.Rb(),o.Nb(2,\"span\",1),o.Nb(3,\"span\",2)),2&t&&(o.Ab(2),o.Eb(\"mat-button-ripple-round\",e.isRoundButton||e.isIconButton),o.ec(\"matRippleDisabled\",e._isRippleDisabled())(\"matRippleCentered\",e.isIconButton)(\"matRippleTrigger\",e._getHostElement()))},directives:[Nt],styles:[\".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\\n\"],encapsulation:2,changeDetection:0}),t})(),Ci=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},imports:[[Ht,Ot],Ot]}),t})();function ki(t,e){if(1&t){const t=o.Tb();o.Sb(0,\"div\"),o.Nb(1,\"input\",6),o.Sb(2,\"div\",7),o.uc(3,\" Forgot Password? \"),o.Rb(),o.Sb(4,\"div\",15),o.Sb(5,\"button\",16),o.Zb(\"click\",function(){return o.mc(t),o.bc().sendOTPStatus=!0}),o.uc(6,\" Send OTP \"),o.Rb(),o.Rb(),o.Rb()}}function Si(t,e){if(1&t){const t=o.Tb();o.Sb(0,\"h3\",17),o.uc(1,\"Verify OTP\"),o.Rb(),o.Nb(2,\"input\",18),o.Sb(3,\"div\",15),o.Sb(4,\"button\",16),o.Zb(\"click\",function(){return o.mc(t),o.bc().sendOTPStatus=!1}),o.uc(5,\" Verify OTP \"),o.Rb(),o.Rb()}}let Oi=(()=>{class t{constructor(){this.sendOTPStatus=!1}ngOnInit(){}}return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"app-login\"]],decls:23,vars:2,consts:[[1,\"_containerWidth\"],[1,\"_m0\",\"_fw700\"],[1,\"_m0\",\"_loginWithColor\"],[\"mat-align-tabs\",\"start\"],[\"label\",\"Email\"],[\"placeholder\",\"Email\",\"type\",\"text\",1,\"_inputBox\",\"_mt\"],[\"placeholder\",\"Mobile Number\",\"type\",\"tel\",1,\"_inputBox\",\"_mt\"],[\"routerLink\",\"/forgot-password\",1,\"_textEnd\",\"_mt\",\"_cursorPointer\"],[1,\"_textCen\",\"_mt\"],[\"mat-button\",\"\",1,\"button\",\"_width100\"],[\"label\",\"Mobile\"],[4,\"ngIf\",\"ngIfElse\"],[\"verifyTemplate\",\"\"],[1,\"_textStart\",\"_mt\"],[\"routerLink\",\"/registration\",1,\"_cursorPointer\",\"_primaryTextColor\"],[1,\"_mt\",\"_textCen\"],[\"mat-button\",\"\",1,\"button\",\"_width100\",3,\"click\"],[1,\"_mt\",\"_forgotTextColor\"],[\"placeholder\",\"OTP\",1,\"_inputBox\",\"_mt\"]],template:function(t,e){if(1&t&&(o.Sb(0,\"div\"),o.Sb(1,\"div\",0),o.Sb(2,\"h1\",1),o.uc(3,\"ConvoBot360\"),o.Rb(),o.Sb(4,\"h3\",2),o.uc(5,\"Login with\"),o.Rb(),o.Sb(6,\"mat-tab-group\",3),o.Sb(7,\"mat-tab\",4),o.Nb(8,\"input\",5),o.Nb(9,\"input\",6),o.Sb(10,\"div\",7),o.uc(11,\" Forgot Password? \"),o.Rb(),o.Sb(12,\"div\",8),o.Sb(13,\"button\",9),o.uc(14,\"Sign in\"),o.Rb(),o.Rb(),o.Rb(),o.Sb(15,\"mat-tab\",10),o.sc(16,ki,7,0,\"div\",11),o.sc(17,Si,6,0,\"ng-template\",null,12,o.tc),o.Rb(),o.Rb(),o.Sb(19,\"div\",13),o.uc(20,\" Don't have an account yet?\"),o.Sb(21,\"span\",14),o.uc(22,\"\\xa0Sign up\"),o.Rb(),o.Rb(),o.Rb(),o.Rb()),2&t){const t=o.lc(18);o.Ab(16),o.ec(\"ngIf\",!e.sendOTPStatus)(\"ngIfElse\",t)}},directives:[li,Ue,n.a,xi,s.j],styles:[\"._loginWithColor[_ngcontent-%COMP%]{color:#454545}\"]}),t})();var Ri=i(\"3Pt+\");function Ii(t,e){return i=>{const s=i.controls[e];s.errors&&!s.errors.mustMatch||s.setErrors(i.controls[t].value!==s.value?{mustMatch:!0}:null)}}function Ei(t,e){if(1&t){const t=o.Tb();o.Sb(0,\"div\"),o.Sb(1,\"h3\",6),o.uc(2,\"Forgot Password\"),o.Rb(),o.Sb(3,\"label\",7),o.uc(4,\"Email\"),o.Rb(),o.Nb(5,\"input\",8),o.Sb(6,\"span\",9),o.uc(7,\"Requires your primary email ID.\"),o.Rb(),o.Sb(8,\"div\",10),o.Sb(9,\"button\",11),o.Zb(\"click\",function(){return o.mc(t),o.bc().forgotPasswordStageStatus=\"otpVerification\"}),o.uc(10,\" Send OTP \"),o.Rb(),o.Rb(),o.Rb()}}function Pi(t,e){if(1&t){const t=o.Tb();o.Sb(0,\"div\"),o.Sb(1,\"h3\",6),o.uc(2,\"Verify OTP\"),o.Rb(),o.Nb(3,\"input\",12),o.Sb(4,\"div\",10),o.Sb(5,\"button\",11),o.Zb(\"click\",function(){return o.mc(t),o.bc().forgotPasswordStageStatus=\"setNewPassword\"}),o.uc(6,\" Verify OTP \"),o.Rb(),o.Rb(),o.Rb()}}function Ai(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\"Password is required\"),o.Rb())}function Mi(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Password must be at least 6 characters \"),o.Rb())}function Ti(t,e){if(1&t&&(o.Sb(0,\"div\",17),o.sc(1,Ai,2,0,\"div\",18),o.sc(2,Mi,2,0,\"div\",18),o.Rb()),2&t){const t=o.bc(2);o.Ab(1),o.ec(\"ngIf\",t.f.password.errors.required),o.Ab(1),o.ec(\"ngIf\",t.f.password.errors.minlength)}}function Di(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Confirm Password is required \"),o.Rb())}function Li(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Passwords must match \"),o.Rb())}function Bi(t,e){if(1&t&&(o.Sb(0,\"div\",17),o.sc(1,Di,2,0,\"div\",18),o.sc(2,Li,2,0,\"div\",18),o.Rb()),2&t){const t=o.bc(2);o.Ab(1),o.ec(\"ngIf\",t.f.confirmPassword.errors.required),o.Ab(1),o.ec(\"ngIf\",t.f.confirmPassword.errors.mustMatch)}}function ji(t,e){if(1&t){const t=o.Tb();o.Sb(0,\"div\"),o.Sb(1,\"form\",13),o.Sb(2,\"h3\",6),o.uc(3,\"Set New Password\"),o.Rb(),o.Sb(4,\"div\"),o.Sb(5,\"label\",7),o.uc(6,\"Password\"),o.Rb(),o.Nb(7,\"input\",14),o.sc(8,Ti,3,2,\"div\",15),o.Rb(),o.Sb(9,\"div\"),o.Sb(10,\"label\",7),o.uc(11,\"Confirm Password\"),o.Rb(),o.Nb(12,\"input\",16),o.sc(13,Bi,3,2,\"div\",15),o.Rb(),o.Sb(14,\"div\",10),o.Sb(15,\"button\",11),o.Zb(\"click\",function(){return o.mc(t),o.bc().setNewPasswordFunction()}),o.uc(16,\" Set New Password \"),o.Rb(),o.Rb(),o.Rb(),o.Rb()}if(2&t){const t=o.bc();o.Ab(1),o.ec(\"formGroup\",t.newPasswordForm),o.Ab(7),o.ec(\"ngIf\",t.passwordSubmitted&&t.f.password.errors),o.Ab(5),o.ec(\"ngIf\",t.passwordSubmitted&&t.f.confirmPassword.errors)}}let Fi=(()=>{class t{constructor(t){this.formBuilder=t,this.sendOTPStatus=!1,this.forgotPasswordStageStatus=\"emailVerification\",this.passwordSubmitted=!1}ngOnInit(){this.newPasswordForm=this.formBuilder.group({password:[\"\",[Ri.k.required,Ri.k.minLength(6)]],confirmPassword:[\"\",Ri.k.required]},{validator:Ii(\"password\",\"confirmPassword\")})}get f(){var t;return null===(t=this.newPasswordForm)||void 0===t?void 0:t.controls}setNewPasswordFunction(){this.passwordSubmitted=!0}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(Ri.b))},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"app-forgot-password\"]],decls:12,vars:4,consts:[[1,\"_containerWidth\"],[1,\"_m0\",\"_fw700\"],[3,\"ngSwitch\"],[4,\"ngSwitchCase\"],[1,\"_textStart\",\"_mt\"],[\"routerLink\",\"/login\",1,\"_cursorPointer\",\"_primaryTextColor\"],[1,\"_m0\",\"_forgotTextColor\"],[1,\"_mt\",\"_inputLabel\"],[\"placeholder\",\"Email\",1,\"_inputBox\"],[1,\"_textMuted\"],[1,\"_mt\",\"_textCen\"],[\"mat-button\",\"\",1,\"button\",\"_width100\",3,\"click\"],[\"placeholder\",\"OTP\",1,\"_inputBox\",\"_mt\"],[3,\"formGroup\"],[\"placeholder\",\"Password\",\"formControlName\",\"password\",\"type\",\"password\",1,\"_inputBox\"],[\"class\",\"_alertTextColor\",4,\"ngIf\"],[\"placeholder\",\"Confirm Password\",\"formControlName\",\"confirmPassword\",\"type\",\"password\",1,\"_inputBox\"],[1,\"_alertTextColor\"],[4,\"ngIf\"]],template:function(t,e){1&t&&(o.Sb(0,\"div\"),o.Sb(1,\"div\",0),o.Sb(2,\"h1\",1),o.uc(3,\"ConvoBot360\"),o.Rb(),o.Sb(4,\"div\",2),o.sc(5,Ei,11,0,\"div\",3),o.sc(6,Pi,7,0,\"div\",3),o.sc(7,ji,17,3,\"div\",3),o.Rb(),o.Sb(8,\"div\",4),o.uc(9,\" Already have login and password?\"),o.Sb(10,\"span\",5),o.uc(11,\"\\xa0Sign in\"),o.Rb(),o.Rb(),o.Rb(),o.Rb()),2&t&&(o.Ab(4),o.ec(\"ngSwitch\",e.forgotPasswordStageStatus),o.Ab(1),o.ec(\"ngSwitchCase\",\"emailVerification\"),o.Ab(1),o.ec(\"ngSwitchCase\",\"otpVerification\"),o.Ab(1),o.ec(\"ngSwitchCase\",\"setNewPassword\"))},directives:[s.l,s.m,n.a,xi,Ri.l,Ri.h,Ri.d,Ri.a,Ri.g,Ri.c,s.j],styles:[\"._forgotTextColor[_ngcontent-%COMP%]{color:#454545}\"]}),t})();class Wi{constructor(){this.serverEndPoint={login:\"asdfasdfasd\"}}}var Ni=i(\"Sy1n\");class Hi{constructor(t,e){this.predicate=t,this.inclusive=e}call(t,e){return e.subscribe(new Vi(t,this.predicate,this.inclusive))}}class Vi extends d.a{constructor(t,e,i){super(t),this.predicate=e,this.inclusive=i,this.index=0}_next(t){const e=this.destination;let i;try{i=this.predicate(t,this.index++)}catch(s){return void e.error(s)}this.nextOrComplete(t,i)}nextOrComplete(t,e){const i=this.destination;Boolean(e)?i.next(t):(this.inclusive&&i.next(t),i.complete())}}const zi=B();class Yi{constructor(t,e){this._viewportRuler=t,this._previousHTMLStyles={top:\"\",left:\"\"},this._isEnabled=!1,this._document=e}attach(){}enable(){if(this._canBeEnabled()){const t=this._document.documentElement;this._previousScrollPosition=this._viewportRuler.getViewportScrollPosition(),this._previousHTMLStyles.left=t.style.left||\"\",this._previousHTMLStyles.top=t.style.top||\"\",t.style.left=R(-this._previousScrollPosition.left),t.style.top=R(-this._previousScrollPosition.top),t.classList.add(\"cdk-global-scrollblock\"),this._isEnabled=!0}}disable(){if(this._isEnabled){const t=this._document.documentElement,e=t.style,i=this._document.body.style,s=e.scrollBehavior||\"\",n=i.scrollBehavior||\"\";this._isEnabled=!1,e.left=this._previousHTMLStyles.left,e.top=this._previousHTMLStyles.top,t.classList.remove(\"cdk-global-scrollblock\"),zi&&(e.scrollBehavior=i.scrollBehavior=\"auto\"),window.scroll(this._previousScrollPosition.left,this._previousScrollPosition.top),zi&&(e.scrollBehavior=s,i.scrollBehavior=n)}}_canBeEnabled(){if(this._document.documentElement.classList.contains(\"cdk-global-scrollblock\")||this._isEnabled)return!1;const t=this._document.body,e=this._viewportRuler.getViewportSize();return t.scrollHeight>e.height||t.scrollWidth>e.width}}class Ki{constructor(t,e,i,s){this._scrollDispatcher=t,this._ngZone=e,this._viewportRuler=i,this._config=s,this._scrollSubscription=null,this._detach=()=>{this.disable(),this._overlayRef.hasAttached()&&this._ngZone.run(()=>this._overlayRef.detach())}}attach(t){this._overlayRef=t}enable(){if(this._scrollSubscription)return;const t=this._scrollDispatcher.scrolled(0);this._config&&this._config.threshold&&this._config.threshold>1?(this._initialScrollPosition=this._viewportRuler.getViewportScrollPosition().top,this._scrollSubscription=t.subscribe(()=>{const t=this._viewportRuler.getViewportScrollPosition().top;Math.abs(t-this._initialScrollPosition)>this._config.threshold?this._detach():this._overlayRef.updatePosition()})):this._scrollSubscription=t.subscribe(this._detach)}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}class Xi{enable(){}disable(){}attach(){}}function qi(t,e){return e.some(e=>t.bottom<e.top||t.top>e.bottom||t.right<e.left||t.left>e.right)}function Zi(t,e){return e.some(e=>t.top<e.top||t.bottom>e.bottom||t.left<e.left||t.right>e.right)}class Gi{constructor(t,e,i,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=i,this._config=s,this._scrollSubscription=null}attach(t){this._overlayRef=t}enable(){this._scrollSubscription||(this._scrollSubscription=this._scrollDispatcher.scrolled(this._config?this._config.scrollThrottle:0).subscribe(()=>{if(this._overlayRef.updatePosition(),this._config&&this._config.autoClose){const t=this._overlayRef.overlayElement.getBoundingClientRect(),{width:e,height:i}=this._viewportRuler.getViewportSize();qi(t,[{width:e,height:i,bottom:i,right:e,top:0,left:0}])&&(this.disable(),this._ngZone.run(()=>this._overlayRef.detach()))}}))}disable(){this._scrollSubscription&&(this._scrollSubscription.unsubscribe(),this._scrollSubscription=null)}detach(){this.disable(),this._overlayRef=null}}let Ji=(()=>{class t{constructor(t,e,i,s){this._scrollDispatcher=t,this._viewportRuler=e,this._ngZone=i,this.noop=()=>new Xi,this.close=t=>new Ki(this._scrollDispatcher,this._ngZone,this._viewportRuler,t),this.block=()=>new Yi(this._viewportRuler,this._document),this.reposition=t=>new Gi(this._scrollDispatcher,this._viewportRuler,this._ngZone,t),this._document=s}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(ke),o.Wb(Se),o.Wb(o.A),o.Wb(s.c))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(ke),Object(o.Wb)(Se),Object(o.Wb)(o.A),Object(o.Wb)(s.c))},token:t,providedIn:\"root\"}),t})();class Ui{constructor(t){if(this.scrollStrategy=new Xi,this.panelClass=\"\",this.hasBackdrop=!1,this.backdropClass=\"cdk-overlay-dark-backdrop\",this.disposeOnNavigation=!1,t){const e=Object.keys(t);for(const i of e)void 0!==t[i]&&(this[i]=t[i])}}}class $i{constructor(t,e,i,s,n){this.offsetX=i,this.offsetY=s,this.panelClass=n,this.originX=t.originX,this.originY=t.originY,this.overlayX=e.overlayX,this.overlayY=e.overlayY}}class Qi{constructor(t,e){this.connectionPair=t,this.scrollableViewProperties=e}}let ts=(()=>{class t{constructor(t){this._attachedOverlays=[],this._document=t}ngOnDestroy(){this.detach()}add(t){this.remove(t),this._attachedOverlays.push(t)}remove(t){const e=this._attachedOverlays.indexOf(t);e>-1&&this._attachedOverlays.splice(e,1),0===this._attachedOverlays.length&&this.detach()}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(s.c))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(s.c))},token:t,providedIn:\"root\"}),t})(),es=(()=>{class t extends ts{constructor(t){super(t),this._keydownListener=t=>{const e=this._attachedOverlays;for(let i=e.length-1;i>-1;i--)if(e[i]._keydownEvents.observers.length>0){e[i]._keydownEvents.next(t);break}}}add(t){super.add(t),this._isAttached||(this._document.body.addEventListener(\"keydown\",this._keydownListener),this._isAttached=!0)}detach(){this._isAttached&&(this._document.body.removeEventListener(\"keydown\",this._keydownListener),this._isAttached=!1)}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(s.c))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(s.c))},token:t,providedIn:\"root\"}),t})(),is=(()=>{class t extends ts{constructor(t,e){super(t),this._platform=e,this._cursorStyleIsSet=!1,this._clickListener=t=>{const e=t.composedPath?t.composedPath()[0]:t.target,i=this._attachedOverlays.slice();for(let s=i.length-1;s>-1;s--){const n=i[s];if(!(n._outsidePointerEvents.observers.length<1)&&n.hasAttached()){if(n.overlayElement.contains(e))break;n._outsidePointerEvents.next(t)}}}}add(t){if(super.add(t),!this._isAttached){const t=this._document.body;t.addEventListener(\"click\",this._clickListener,!0),t.addEventListener(\"auxclick\",this._clickListener,!0),t.addEventListener(\"contextmenu\",this._clickListener,!0),this._platform.IOS&&!this._cursorStyleIsSet&&(this._cursorOriginalValue=t.style.cursor,t.style.cursor=\"pointer\",this._cursorStyleIsSet=!0),this._isAttached=!0}}detach(){if(this._isAttached){const t=this._document.body;t.removeEventListener(\"click\",this._clickListener,!0),t.removeEventListener(\"auxclick\",this._clickListener,!0),t.removeEventListener(\"contextmenu\",this._clickListener,!0),this._platform.IOS&&this._cursorStyleIsSet&&(t.style.cursor=this._cursorOriginalValue,this._cursorStyleIsSet=!1),this._isAttached=!1}}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(s.c),o.Wb(T))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(s.c),Object(o.Wb)(T))},token:t,providedIn:\"root\"}),t})();const ss=!(\"undefined\"==typeof window||!window||!window.__karma__&&!window.jasmine);let ns=(()=>{class t{constructor(t,e){this._platform=e,this._document=t}ngOnDestroy(){const t=this._containerElement;t&&t.parentNode&&t.parentNode.removeChild(t)}getContainerElement(){return this._containerElement||this._createContainer(),this._containerElement}_createContainer(){const t=\"cdk-overlay-container\";if(this._platform.isBrowser||ss){const e=this._document.querySelectorAll(`.${t}[platform=\"server\"], .${t}[platform=\"test\"]`);for(let t=0;t<e.length;t++)e[t].parentNode.removeChild(e[t])}const e=this._document.createElement(\"div\");e.classList.add(t),ss?e.setAttribute(\"platform\",\"test\"):this._platform.isBrowser||e.setAttribute(\"platform\",\"server\"),this._document.body.appendChild(e),this._containerElement=e}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(s.c),o.Wb(T))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(s.c),Object(o.Wb)(T))},token:t,providedIn:\"root\"}),t})();class os{constructor(t,e,i,s,n,o,l,c,h){this._portalOutlet=t,this._host=e,this._pane=i,this._config=s,this._ngZone=n,this._keyboardDispatcher=o,this._document=l,this._location=c,this._outsideClickDispatcher=h,this._backdropElement=null,this._backdropClick=new r.a,this._attachments=new r.a,this._detachments=new r.a,this._locationChanges=a.a.EMPTY,this._backdropClickHandler=t=>this._backdropClick.next(t),this._keydownEvents=new r.a,this._outsidePointerEvents=new r.a,s.scrollStrategy&&(this._scrollStrategy=s.scrollStrategy,this._scrollStrategy.attach(this)),this._positionStrategy=s.positionStrategy}get overlayElement(){return this._pane}get backdropElement(){return this._backdropElement}get hostElement(){return this._host}attach(t){let e=this._portalOutlet.attach(t);return!this._host.parentElement&&this._previousHostParent&&this._previousHostParent.appendChild(this._host),this._positionStrategy&&this._positionStrategy.attach(this),this._updateStackingOrder(),this._updateElementSize(),this._updateElementDirection(),this._scrollStrategy&&this._scrollStrategy.enable(),this._ngZone.onStable.pipe(Object(C.a)(1)).subscribe(()=>{this.hasAttached()&&this.updatePosition()}),this._togglePointerEvents(!0),this._config.hasBackdrop&&this._attachBackdrop(),this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!0),this._attachments.next(),this._keyboardDispatcher.add(this),this._config.disposeOnNavigation&&(this._locationChanges=this._location.subscribe(()=>this.dispose())),this._outsideClickDispatcher.add(this),e}detach(){if(!this.hasAttached())return;this.detachBackdrop(),this._togglePointerEvents(!1),this._positionStrategy&&this._positionStrategy.detach&&this._positionStrategy.detach(),this._scrollStrategy&&this._scrollStrategy.disable();const t=this._portalOutlet.detach();return this._detachments.next(),this._keyboardDispatcher.remove(this),this._detachContentWhenStable(),this._locationChanges.unsubscribe(),this._outsideClickDispatcher.remove(this),t}dispose(){const t=this.hasAttached();this._positionStrategy&&this._positionStrategy.dispose(),this._disposeScrollStrategy(),this.detachBackdrop(),this._locationChanges.unsubscribe(),this._keyboardDispatcher.remove(this),this._portalOutlet.dispose(),this._attachments.complete(),this._backdropClick.complete(),this._keydownEvents.complete(),this._outsidePointerEvents.complete(),this._outsideClickDispatcher.remove(this),this._host&&this._host.parentNode&&(this._host.parentNode.removeChild(this._host),this._host=null),this._previousHostParent=this._pane=null,t&&this._detachments.next(),this._detachments.complete()}hasAttached(){return this._portalOutlet.hasAttached()}backdropClick(){return this._backdropClick}attachments(){return this._attachments}detachments(){return this._detachments}keydownEvents(){return this._keydownEvents}outsidePointerEvents(){return this._outsidePointerEvents}getConfig(){return this._config}updatePosition(){this._positionStrategy&&this._positionStrategy.apply()}updatePositionStrategy(t){t!==this._positionStrategy&&(this._positionStrategy&&this._positionStrategy.dispose(),this._positionStrategy=t,this.hasAttached()&&(t.attach(this),this.updatePosition()))}updateSize(t){this._config=Object.assign(Object.assign({},this._config),t),this._updateElementSize()}setDirection(t){this._config=Object.assign(Object.assign({},this._config),{direction:t}),this._updateElementDirection()}addPanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!0)}removePanelClass(t){this._pane&&this._toggleClasses(this._pane,t,!1)}getDirection(){const t=this._config.direction;return t?\"string\"==typeof t?t:t.value:\"ltr\"}updateScrollStrategy(t){t!==this._scrollStrategy&&(this._disposeScrollStrategy(),this._scrollStrategy=t,this.hasAttached()&&(t.attach(this),t.enable()))}_updateElementDirection(){this._host.setAttribute(\"dir\",this.getDirection())}_updateElementSize(){if(!this._pane)return;const t=this._pane.style;t.width=R(this._config.width),t.height=R(this._config.height),t.minWidth=R(this._config.minWidth),t.minHeight=R(this._config.minHeight),t.maxWidth=R(this._config.maxWidth),t.maxHeight=R(this._config.maxHeight)}_togglePointerEvents(t){this._pane.style.pointerEvents=t?\"\":\"none\"}_attachBackdrop(){const t=\"cdk-overlay-backdrop-showing\";this._backdropElement=this._document.createElement(\"div\"),this._backdropElement.classList.add(\"cdk-overlay-backdrop\"),this._config.backdropClass&&this._toggleClasses(this._backdropElement,this._config.backdropClass,!0),this._host.parentElement.insertBefore(this._backdropElement,this._host),this._backdropElement.addEventListener(\"click\",this._backdropClickHandler),\"undefined\"!=typeof requestAnimationFrame?this._ngZone.runOutsideAngular(()=>{requestAnimationFrame(()=>{this._backdropElement&&this._backdropElement.classList.add(t)})}):this._backdropElement.classList.add(t)}_updateStackingOrder(){this._host.nextSibling&&this._host.parentNode.appendChild(this._host)}detachBackdrop(){let t,e=this._backdropElement;if(!e)return;let i=()=>{e&&(e.removeEventListener(\"click\",this._backdropClickHandler),e.removeEventListener(\"transitionend\",i),e.parentNode&&e.parentNode.removeChild(e)),this._backdropElement==e&&(this._backdropElement=null),this._config.backdropClass&&this._toggleClasses(e,this._config.backdropClass,!1),clearTimeout(t)};e.classList.remove(\"cdk-overlay-backdrop-showing\"),this._ngZone.runOutsideAngular(()=>{e.addEventListener(\"transitionend\",i)}),e.style.pointerEvents=\"none\",t=this._ngZone.runOutsideAngular(()=>setTimeout(i,500))}_toggleClasses(t,e,i){const s=t.classList;O(e).forEach(t=>{t&&(i?s.add(t):s.remove(t))})}_detachContentWhenStable(){this._ngZone.runOutsideAngular(()=>{const t=this._ngZone.onStable.pipe(_e(Object(ie.a)(this._attachments,this._detachments))).subscribe(()=>{this._pane&&this._host&&0!==this._pane.children.length||(this._pane&&this._config.panelClass&&this._toggleClasses(this._pane,this._config.panelClass,!1),this._host&&this._host.parentElement&&(this._previousHostParent=this._host.parentElement,this._previousHostParent.removeChild(this._host)),t.unsubscribe())})})}_disposeScrollStrategy(){const t=this._scrollStrategy;t&&(t.disable(),t.detach&&t.detach())}}const rs=\"cdk-overlay-connected-position-bounding-box\",as=/([A-Za-z%]+)$/;class ls{constructor(t,e,i,s,n){this._viewportRuler=e,this._document=i,this._platform=s,this._overlayContainer=n,this._lastBoundingBoxSize={width:0,height:0},this._isPushed=!1,this._canPush=!0,this._growAfterOpen=!1,this._hasFlexibleDimensions=!0,this._positionLocked=!1,this._viewportMargin=0,this._scrollables=[],this._preferredPositions=[],this._positionChanges=new r.a,this._resizeSubscription=a.a.EMPTY,this._offsetX=0,this._offsetY=0,this._appliedPanelClasses=[],this.positionChanges=this._positionChanges,this.setOrigin(t)}get positions(){return this._preferredPositions}attach(t){this._validatePositions(),t.hostElement.classList.add(rs),this._overlayRef=t,this._boundingBox=t.hostElement,this._pane=t.overlayElement,this._isDisposed=!1,this._isInitialRender=!0,this._lastPosition=null,this._resizeSubscription.unsubscribe(),this._resizeSubscription=this._viewportRuler.change().subscribe(()=>{this._isInitialRender=!0,this.apply()})}apply(){if(this._isDisposed||!this._platform.isBrowser)return;if(!this._isInitialRender&&this._positionLocked&&this._lastPosition)return void this.reapplyLastPosition();this._clearPanelClasses(),this._resetOverlayElementStyles(),this._resetBoundingBoxStyles(),this._viewportRect=this._getNarrowedViewportRect(),this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect();const t=this._originRect,e=this._overlayRect,i=this._viewportRect,s=[];let n;for(let o of this._preferredPositions){let r=this._getOriginPoint(t,o),a=this._getOverlayPoint(r,e,o),l=this._getOverlayFit(a,e,i,o);if(l.isCompletelyWithinViewport)return this._isPushed=!1,void this._applyPosition(o,r);this._canFitWithFlexibleDimensions(l,a,i)?s.push({position:o,origin:r,overlayRect:e,boundingBoxRect:this._calculateBoundingBoxRect(r,o)}):(!n||n.overlayFit.visibleArea<l.visibleArea)&&(n={overlayFit:l,overlayPoint:a,originPoint:r,position:o,overlayRect:e})}if(s.length){let t=null,e=-1;for(const i of s){const s=i.boundingBoxRect.width*i.boundingBoxRect.height*(i.position.weight||1);s>e&&(e=s,t=i)}return this._isPushed=!1,void this._applyPosition(t.position,t.origin)}if(this._canPush)return this._isPushed=!0,void this._applyPosition(n.position,n.originPoint);this._applyPosition(n.position,n.originPoint)}detach(){this._clearPanelClasses(),this._lastPosition=null,this._previousPushAmount=null,this._resizeSubscription.unsubscribe()}dispose(){this._isDisposed||(this._boundingBox&&cs(this._boundingBox.style,{top:\"\",left:\"\",right:\"\",bottom:\"\",height:\"\",width:\"\",alignItems:\"\",justifyContent:\"\"}),this._pane&&this._resetOverlayElementStyles(),this._overlayRef&&this._overlayRef.hostElement.classList.remove(rs),this.detach(),this._positionChanges.complete(),this._overlayRef=this._boundingBox=null,this._isDisposed=!0)}reapplyLastPosition(){if(!this._isDisposed&&(!this._platform||this._platform.isBrowser)){this._originRect=this._getOriginRect(),this._overlayRect=this._pane.getBoundingClientRect(),this._viewportRect=this._getNarrowedViewportRect();const t=this._lastPosition||this._preferredPositions[0],e=this._getOriginPoint(this._originRect,t);this._applyPosition(t,e)}}withScrollableContainers(t){return this._scrollables=t,this}withPositions(t){return this._preferredPositions=t,-1===t.indexOf(this._lastPosition)&&(this._lastPosition=null),this._validatePositions(),this}withViewportMargin(t){return this._viewportMargin=t,this}withFlexibleDimensions(t=!0){return this._hasFlexibleDimensions=t,this}withGrowAfterOpen(t=!0){return this._growAfterOpen=t,this}withPush(t=!0){return this._canPush=t,this}withLockedPosition(t=!0){return this._positionLocked=t,this}setOrigin(t){return this._origin=t,this}withDefaultOffsetX(t){return this._offsetX=t,this}withDefaultOffsetY(t){return this._offsetY=t,this}withTransformOriginOn(t){return this._transformOriginSelector=t,this}_getOriginPoint(t,e){let i,s;if(\"center\"==e.originX)i=t.left+t.width/2;else{const s=this._isRtl()?t.right:t.left,n=this._isRtl()?t.left:t.right;i=\"start\"==e.originX?s:n}return s=\"center\"==e.originY?t.top+t.height/2:\"top\"==e.originY?t.top:t.bottom,{x:i,y:s}}_getOverlayPoint(t,e,i){let s,n;return s=\"center\"==i.overlayX?-e.width/2:\"start\"===i.overlayX?this._isRtl()?-e.width:0:this._isRtl()?0:-e.width,n=\"center\"==i.overlayY?-e.height/2:\"top\"==i.overlayY?0:-e.height,{x:t.x+s,y:t.y+n}}_getOverlayFit(t,e,i,s){const n=ds(e);let{x:o,y:r}=t,a=this._getOffset(s,\"x\"),l=this._getOffset(s,\"y\");a&&(o+=a),l&&(r+=l);let c=0-r,h=r+n.height-i.height,d=this._subtractOverflows(n.width,0-o,o+n.width-i.width),u=this._subtractOverflows(n.height,c,h),p=d*u;return{visibleArea:p,isCompletelyWithinViewport:n.width*n.height===p,fitsInViewportVertically:u===n.height,fitsInViewportHorizontally:d==n.width}}_canFitWithFlexibleDimensions(t,e,i){if(this._hasFlexibleDimensions){const s=i.bottom-e.y,n=i.right-e.x,o=hs(this._overlayRef.getConfig().minHeight),r=hs(this._overlayRef.getConfig().minWidth),a=t.fitsInViewportHorizontally||null!=r&&r<=n;return(t.fitsInViewportVertically||null!=o&&o<=s)&&a}return!1}_pushOverlayOnScreen(t,e,i){if(this._previousPushAmount&&this._positionLocked)return{x:t.x+this._previousPushAmount.x,y:t.y+this._previousPushAmount.y};const s=ds(e),n=this._viewportRect,o=Math.max(t.x+s.width-n.width,0),r=Math.max(t.y+s.height-n.height,0),a=Math.max(n.top-i.top-t.y,0),l=Math.max(n.left-i.left-t.x,0);let c=0,h=0;return c=s.width<=n.width?l||-o:t.x<this._viewportMargin?n.left-i.left-t.x:0,h=s.height<=n.height?a||-r:t.y<this._viewportMargin?n.top-i.top-t.y:0,this._previousPushAmount={x:c,y:h},{x:t.x+c,y:t.y+h}}_applyPosition(t,e){if(this._setTransformOrigin(t),this._setOverlayElementStyles(e,t),this._setBoundingBoxStyles(e,t),t.panelClass&&this._addPanelClasses(t.panelClass),this._lastPosition=t,this._positionChanges.observers.length){const e=this._getScrollVisibility(),i=new Qi(t,e);this._positionChanges.next(i)}this._isInitialRender=!1}_setTransformOrigin(t){if(!this._transformOriginSelector)return;const e=this._boundingBox.querySelectorAll(this._transformOriginSelector);let i,s=t.overlayY;i=\"center\"===t.overlayX?\"center\":this._isRtl()?\"start\"===t.overlayX?\"right\":\"left\":\"start\"===t.overlayX?\"left\":\"right\";for(let n=0;n<e.length;n++)e[n].style.transformOrigin=`${i} ${s}`}_calculateBoundingBoxRect(t,e){const i=this._viewportRect,s=this._isRtl();let n,o,r,a,l,c;if(\"top\"===e.overlayY)o=t.y,n=i.height-o+this._viewportMargin;else if(\"bottom\"===e.overlayY)r=i.height-t.y+2*this._viewportMargin,n=i.height-r+this._viewportMargin;else{const e=Math.min(i.bottom-t.y+i.top,t.y),s=this._lastBoundingBoxSize.height;n=2*e,o=t.y-e,n>s&&!this._isInitialRender&&!this._growAfterOpen&&(o=t.y-s/2)}if(\"end\"===e.overlayX&&!s||\"start\"===e.overlayX&&s)c=i.width-t.x+this._viewportMargin,a=t.x-this._viewportMargin;else if(\"start\"===e.overlayX&&!s||\"end\"===e.overlayX&&s)l=t.x,a=i.right-t.x;else{const e=Math.min(i.right-t.x+i.left,t.x),s=this._lastBoundingBoxSize.width;a=2*e,l=t.x-e,a>s&&!this._isInitialRender&&!this._growAfterOpen&&(l=t.x-s/2)}return{top:o,left:l,bottom:r,right:c,width:a,height:n}}_setBoundingBoxStyles(t,e){const i=this._calculateBoundingBoxRect(t,e);this._isInitialRender||this._growAfterOpen||(i.height=Math.min(i.height,this._lastBoundingBoxSize.height),i.width=Math.min(i.width,this._lastBoundingBoxSize.width));const s={};if(this._hasExactPosition())s.top=s.left=\"0\",s.bottom=s.right=s.maxHeight=s.maxWidth=\"\",s.width=s.height=\"100%\";else{const t=this._overlayRef.getConfig().maxHeight,n=this._overlayRef.getConfig().maxWidth;s.height=R(i.height),s.top=R(i.top),s.bottom=R(i.bottom),s.width=R(i.width),s.left=R(i.left),s.right=R(i.right),s.alignItems=\"center\"===e.overlayX?\"center\":\"end\"===e.overlayX?\"flex-end\":\"flex-start\",s.justifyContent=\"center\"===e.overlayY?\"center\":\"bottom\"===e.overlayY?\"flex-end\":\"flex-start\",t&&(s.maxHeight=R(t)),n&&(s.maxWidth=R(n))}this._lastBoundingBoxSize=i,cs(this._boundingBox.style,s)}_resetBoundingBoxStyles(){cs(this._boundingBox.style,{top:\"0\",left:\"0\",right:\"0\",bottom:\"0\",height:\"\",width:\"\",alignItems:\"\",justifyContent:\"\"})}_resetOverlayElementStyles(){cs(this._pane.style,{top:\"\",left:\"\",bottom:\"\",right:\"\",position:\"\",transform:\"\"})}_setOverlayElementStyles(t,e){const i={},s=this._hasExactPosition(),n=this._hasFlexibleDimensions,o=this._overlayRef.getConfig();if(s){const s=this._viewportRuler.getViewportScrollPosition();cs(i,this._getExactOverlayY(e,t,s)),cs(i,this._getExactOverlayX(e,t,s))}else i.position=\"static\";let r=\"\",a=this._getOffset(e,\"x\"),l=this._getOffset(e,\"y\");a&&(r+=`translateX(${a}px) `),l&&(r+=`translateY(${l}px)`),i.transform=r.trim(),o.maxHeight&&(s?i.maxHeight=R(o.maxHeight):n&&(i.maxHeight=\"\")),o.maxWidth&&(s?i.maxWidth=R(o.maxWidth):n&&(i.maxWidth=\"\")),cs(this._pane.style,i)}_getExactOverlayY(t,e,i){let s={top:\"\",bottom:\"\"},n=this._getOverlayPoint(e,this._overlayRect,t);this._isPushed&&(n=this._pushOverlayOnScreen(n,this._overlayRect,i));let o=this._overlayContainer.getContainerElement().getBoundingClientRect().top;return n.y-=o,\"bottom\"===t.overlayY?s.bottom=this._document.documentElement.clientHeight-(n.y+this._overlayRect.height)+\"px\":s.top=R(n.y),s}_getExactOverlayX(t,e,i){let s,n={left:\"\",right:\"\"},o=this._getOverlayPoint(e,this._overlayRect,t);return this._isPushed&&(o=this._pushOverlayOnScreen(o,this._overlayRect,i)),s=this._isRtl()?\"end\"===t.overlayX?\"left\":\"right\":\"end\"===t.overlayX?\"right\":\"left\",\"right\"===s?n.right=this._document.documentElement.clientWidth-(o.x+this._overlayRect.width)+\"px\":n.left=R(o.x),n}_getScrollVisibility(){const t=this._getOriginRect(),e=this._pane.getBoundingClientRect(),i=this._scrollables.map(t=>t.getElementRef().nativeElement.getBoundingClientRect());return{isOriginClipped:Zi(t,i),isOriginOutsideView:qi(t,i),isOverlayClipped:Zi(e,i),isOverlayOutsideView:qi(e,i)}}_subtractOverflows(t,...e){return e.reduce((t,e)=>t-Math.max(e,0),t)}_getNarrowedViewportRect(){const t=this._document.documentElement.clientWidth,e=this._document.documentElement.clientHeight,i=this._viewportRuler.getViewportScrollPosition();return{top:i.top+this._viewportMargin,left:i.left+this._viewportMargin,right:i.left+t-this._viewportMargin,bottom:i.top+e-this._viewportMargin,width:t-2*this._viewportMargin,height:e-2*this._viewportMargin}}_isRtl(){return\"rtl\"===this._overlayRef.getDirection()}_hasExactPosition(){return!this._hasFlexibleDimensions||this._isPushed}_getOffset(t,e){return\"x\"===e?null==t.offsetX?this._offsetX:t.offsetX:null==t.offsetY?this._offsetY:t.offsetY}_validatePositions(){}_addPanelClasses(t){this._pane&&O(t).forEach(t=>{\"\"!==t&&-1===this._appliedPanelClasses.indexOf(t)&&(this._appliedPanelClasses.push(t),this._pane.classList.add(t))})}_clearPanelClasses(){this._pane&&(this._appliedPanelClasses.forEach(t=>{this._pane.classList.remove(t)}),this._appliedPanelClasses=[])}_getOriginRect(){const t=this._origin;if(t instanceof o.l)return t.nativeElement.getBoundingClientRect();if(t instanceof Element)return t.getBoundingClientRect();const e=t.width||0,i=t.height||0;return{top:t.y,bottom:t.y+i,left:t.x,right:t.x+e,height:i,width:e}}}function cs(t,e){for(let i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);return t}function hs(t){if(\"number\"!=typeof t&&null!=t){const[e,i]=t.split(as);return i&&\"px\"!==i?null:parseFloat(e)}return t||null}function ds(t){return{top:Math.floor(t.top),right:Math.floor(t.right),bottom:Math.floor(t.bottom),left:Math.floor(t.left),width:Math.floor(t.width),height:Math.floor(t.height)}}class us{constructor(t,e,i,s,n,o,r){this._preferredPositions=[],this._positionStrategy=new ls(i,s,n,o,r).withFlexibleDimensions(!1).withPush(!1).withViewportMargin(0),this.withFallbackPosition(t,e),this.onPositionChange=this._positionStrategy.positionChanges}get positions(){return this._preferredPositions}attach(t){this._overlayRef=t,this._positionStrategy.attach(t),this._direction&&(t.setDirection(this._direction),this._direction=null)}dispose(){this._positionStrategy.dispose()}detach(){this._positionStrategy.detach()}apply(){this._positionStrategy.apply()}recalculateLastPosition(){this._positionStrategy.reapplyLastPosition()}withScrollableContainers(t){this._positionStrategy.withScrollableContainers(t)}withFallbackPosition(t,e,i,s){const n=new $i(t,e,i,s);return this._preferredPositions.push(n),this._positionStrategy.withPositions(this._preferredPositions),this}withDirection(t){return this._overlayRef?this._overlayRef.setDirection(t):this._direction=t,this}withOffsetX(t){return this._positionStrategy.withDefaultOffsetX(t),this}withOffsetY(t){return this._positionStrategy.withDefaultOffsetY(t),this}withLockedPosition(t){return this._positionStrategy.withLockedPosition(t),this}withPositions(t){return this._preferredPositions=t.slice(),this._positionStrategy.withPositions(this._preferredPositions),this}setOrigin(t){return this._positionStrategy.setOrigin(t),this}}const ps=\"cdk-global-overlay-wrapper\";class bs{constructor(){this._cssPosition=\"static\",this._topOffset=\"\",this._bottomOffset=\"\",this._leftOffset=\"\",this._rightOffset=\"\",this._alignItems=\"\",this._justifyContent=\"\",this._width=\"\",this._height=\"\"}attach(t){const e=t.getConfig();this._overlayRef=t,this._width&&!e.width&&t.updateSize({width:this._width}),this._height&&!e.height&&t.updateSize({height:this._height}),t.hostElement.classList.add(ps),this._isDisposed=!1}top(t=\"\"){return this._bottomOffset=\"\",this._topOffset=t,this._alignItems=\"flex-start\",this}left(t=\"\"){return this._rightOffset=\"\",this._leftOffset=t,this._justifyContent=\"flex-start\",this}bottom(t=\"\"){return this._topOffset=\"\",this._bottomOffset=t,this._alignItems=\"flex-end\",this}right(t=\"\"){return this._leftOffset=\"\",this._rightOffset=t,this._justifyContent=\"flex-end\",this}width(t=\"\"){return this._overlayRef?this._overlayRef.updateSize({width:t}):this._width=t,this}height(t=\"\"){return this._overlayRef?this._overlayRef.updateSize({height:t}):this._height=t,this}centerHorizontally(t=\"\"){return this.left(t),this._justifyContent=\"center\",this}centerVertically(t=\"\"){return this.top(t),this._alignItems=\"center\",this}apply(){if(!this._overlayRef||!this._overlayRef.hasAttached())return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement.style,i=this._overlayRef.getConfig(),{width:s,height:n,maxWidth:o,maxHeight:r}=i,a=!(\"100%\"!==s&&\"100vw\"!==s||o&&\"100%\"!==o&&\"100vw\"!==o),l=!(\"100%\"!==n&&\"100vh\"!==n||r&&\"100%\"!==r&&\"100vh\"!==r);t.position=this._cssPosition,t.marginLeft=a?\"0\":this._leftOffset,t.marginTop=l?\"0\":this._topOffset,t.marginBottom=this._bottomOffset,t.marginRight=this._rightOffset,a?e.justifyContent=\"flex-start\":\"center\"===this._justifyContent?e.justifyContent=\"center\":\"rtl\"===this._overlayRef.getConfig().direction?\"flex-start\"===this._justifyContent?e.justifyContent=\"flex-end\":\"flex-end\"===this._justifyContent&&(e.justifyContent=\"flex-start\"):e.justifyContent=this._justifyContent,e.alignItems=l?\"flex-start\":this._alignItems}dispose(){if(this._isDisposed||!this._overlayRef)return;const t=this._overlayRef.overlayElement.style,e=this._overlayRef.hostElement,i=e.style;e.classList.remove(ps),i.justifyContent=i.alignItems=t.marginTop=t.marginBottom=t.marginLeft=t.marginRight=t.position=\"\",this._overlayRef=null,this._isDisposed=!0}}let ms=(()=>{class t{constructor(t,e,i,s){this._viewportRuler=t,this._document=e,this._platform=i,this._overlayContainer=s}global(){return new bs}connectedTo(t,e,i){return new us(e,i,t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}flexibleConnectedTo(t){return new ls(t,this._viewportRuler,this._document,this._platform,this._overlayContainer)}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(Se),o.Wb(s.c),o.Wb(T),o.Wb(ns))},t.\\u0275prov=Object(o.Ib)({factory:function(){return new t(Object(o.Wb)(Se),Object(o.Wb)(s.c),Object(o.Wb)(T),Object(o.Wb)(ns))},token:t,providedIn:\"root\"}),t})(),_s=0,gs=(()=>{class t{constructor(t,e,i,s,n,o,r,a,l,c,h){this.scrollStrategies=t,this._overlayContainer=e,this._componentFactoryResolver=i,this._positionBuilder=s,this._keyboardDispatcher=n,this._injector=o,this._ngZone=r,this._document=a,this._directionality=l,this._location=c,this._outsideClickDispatcher=h}create(t){const e=this._createHostElement(),i=this._createPaneElement(e),s=this._createPortalOutlet(i),n=new Ui(t);return n.direction=n.direction||this._directionality.value,new os(s,e,i,n,this._ngZone,this._keyboardDispatcher,this._document,this._location,this._outsideClickDispatcher)}position(){return this._positionBuilder}_createPaneElement(t){const e=this._document.createElement(\"div\");return e.id=\"cdk-overlay-\"+_s++,e.classList.add(\"cdk-overlay-pane\"),t.appendChild(e),e}_createHostElement(){const t=this._document.createElement(\"div\");return this._overlayContainer.getContainerElement().appendChild(t),t}_createPortalOutlet(t){return this._appRef||(this._appRef=this._injector.get(o.g)),new dt(t,this._componentFactoryResolver,this._appRef,this._injector,this._document)}}return t.\\u0275fac=function(e){return new(e||t)(o.Wb(Ji),o.Wb(ns),o.Wb(o.j),o.Wb(ms),o.Wb(es),o.Wb(o.r),o.Wb(o.A),o.Wb(s.c),o.Wb(mt),o.Wb(s.f),o.Wb(is))},t.\\u0275prov=o.Ib({token:t,factory:t.\\u0275fac}),t})();const fs=[{originX:\"start\",originY:\"bottom\",overlayX:\"start\",overlayY:\"top\"},{originX:\"start\",originY:\"top\",overlayX:\"start\",overlayY:\"bottom\"},{originX:\"end\",originY:\"top\",overlayX:\"end\",overlayY:\"bottom\"},{originX:\"end\",originY:\"bottom\",overlayX:\"end\",overlayY:\"top\"}],vs=new o.q(\"cdk-connected-overlay-scroll-strategy\");let ys=(()=>{class t{constructor(t){this.elementRef=t}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(o.l))},t.\\u0275dir=o.Hb({type:t,selectors:[[\"\",\"cdk-overlay-origin\",\"\"],[\"\",\"overlay-origin\",\"\"],[\"\",\"cdkOverlayOrigin\",\"\"]],exportAs:[\"cdkOverlayOrigin\"]}),t})(),ws=(()=>{class t{constructor(t,e,i,s,n){this._overlay=t,this._dir=n,this._hasBackdrop=!1,this._lockPosition=!1,this._growAfterOpen=!1,this._flexibleDimensions=!1,this._push=!1,this._backdropSubscription=a.a.EMPTY,this._attachSubscription=a.a.EMPTY,this._detachSubscription=a.a.EMPTY,this._positionSubscription=a.a.EMPTY,this.viewportMargin=0,this.open=!1,this.disableClose=!1,this.backdropClick=new o.n,this.positionChange=new o.n,this.attach=new o.n,this.detach=new o.n,this.overlayKeydown=new o.n,this.overlayOutsideClick=new o.n,this._templatePortal=new lt(e,i),this._scrollStrategyFactory=s,this.scrollStrategy=this._scrollStrategyFactory()}get offsetX(){return this._offsetX}set offsetX(t){this._offsetX=t,this._position&&this._updatePositionStrategy(this._position)}get offsetY(){return this._offsetY}set offsetY(t){this._offsetY=t,this._position&&this._updatePositionStrategy(this._position)}get hasBackdrop(){return this._hasBackdrop}set hasBackdrop(t){this._hasBackdrop=k(t)}get lockPosition(){return this._lockPosition}set lockPosition(t){this._lockPosition=k(t)}get flexibleDimensions(){return this._flexibleDimensions}set flexibleDimensions(t){this._flexibleDimensions=k(t)}get growAfterOpen(){return this._growAfterOpen}set growAfterOpen(t){this._growAfterOpen=k(t)}get push(){return this._push}set push(t){this._push=k(t)}get overlayRef(){return this._overlayRef}get dir(){return this._dir?this._dir.value:\"ltr\"}ngOnDestroy(){this._attachSubscription.unsubscribe(),this._detachSubscription.unsubscribe(),this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe(),this._overlayRef&&this._overlayRef.dispose()}ngOnChanges(t){this._position&&(this._updatePositionStrategy(this._position),this._overlayRef.updateSize({width:this.width,minWidth:this.minWidth,height:this.height,minHeight:this.minHeight}),t.origin&&this.open&&this._position.apply()),t.open&&(this.open?this._attachOverlay():this._detachOverlay())}_createOverlay(){this.positions&&this.positions.length||(this.positions=fs);const t=this._overlayRef=this._overlay.create(this._buildConfig());this._attachSubscription=t.attachments().subscribe(()=>this.attach.emit()),this._detachSubscription=t.detachments().subscribe(()=>this.detach.emit()),t.keydownEvents().subscribe(t=>{this.overlayKeydown.next(t),27!==t.keyCode||this.disableClose||c(t)||(t.preventDefault(),this._detachOverlay())}),this._overlayRef.outsidePointerEvents().subscribe(t=>{this.overlayOutsideClick.next(t)})}_buildConfig(){const t=this._position=this.positionStrategy||this._createPositionStrategy(),e=new Ui({direction:this._dir,positionStrategy:t,scrollStrategy:this.scrollStrategy,hasBackdrop:this.hasBackdrop});return(this.width||0===this.width)&&(e.width=this.width),(this.height||0===this.height)&&(e.height=this.height),(this.minWidth||0===this.minWidth)&&(e.minWidth=this.minWidth),(this.minHeight||0===this.minHeight)&&(e.minHeight=this.minHeight),this.backdropClass&&(e.backdropClass=this.backdropClass),this.panelClass&&(e.panelClass=this.panelClass),e}_updatePositionStrategy(t){const e=this.positions.map(t=>({originX:t.originX,originY:t.originY,overlayX:t.overlayX,overlayY:t.overlayY,offsetX:t.offsetX||this.offsetX,offsetY:t.offsetY||this.offsetY,panelClass:t.panelClass||void 0}));return t.setOrigin(this.origin.elementRef).withPositions(e).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector)}_createPositionStrategy(){const t=this._overlay.position().flexibleConnectedTo(this.origin.elementRef);return this._updatePositionStrategy(t),t}_attachOverlay(){this._overlayRef?this._overlayRef.getConfig().hasBackdrop=this.hasBackdrop:this._createOverlay(),this._overlayRef.hasAttached()||this._overlayRef.attach(this._templatePortal),this.hasBackdrop?this._backdropSubscription=this._overlayRef.backdropClick().subscribe(t=>{this.backdropClick.emit(t)}):this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe(),this.positionChange.observers.length>0&&(this._positionSubscription=this._position.positionChanges.pipe(function(t,e=!1){return i=>i.lift(new Hi(t,e))}(()=>this.positionChange.observers.length>0)).subscribe(t=>{this.positionChange.emit(t),0===this.positionChange.observers.length&&this._positionSubscription.unsubscribe()}))}_detachOverlay(){this._overlayRef&&this._overlayRef.detach(),this._backdropSubscription.unsubscribe(),this._positionSubscription.unsubscribe()}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(gs),o.Mb(o.M),o.Mb(o.Q),o.Mb(vs),o.Mb(mt,8))},t.\\u0275dir=o.Hb({type:t,selectors:[[\"\",\"cdk-connected-overlay\",\"\"],[\"\",\"connected-overlay\",\"\"],[\"\",\"cdkConnectedOverlay\",\"\"]],inputs:{viewportMargin:[\"cdkConnectedOverlayViewportMargin\",\"viewportMargin\"],open:[\"cdkConnectedOverlayOpen\",\"open\"],disableClose:[\"cdkConnectedOverlayDisableClose\",\"disableClose\"],scrollStrategy:[\"cdkConnectedOverlayScrollStrategy\",\"scrollStrategy\"],offsetX:[\"cdkConnectedOverlayOffsetX\",\"offsetX\"],offsetY:[\"cdkConnectedOverlayOffsetY\",\"offsetY\"],hasBackdrop:[\"cdkConnectedOverlayHasBackdrop\",\"hasBackdrop\"],lockPosition:[\"cdkConnectedOverlayLockPosition\",\"lockPosition\"],flexibleDimensions:[\"cdkConnectedOverlayFlexibleDimensions\",\"flexibleDimensions\"],growAfterOpen:[\"cdkConnectedOverlayGrowAfterOpen\",\"growAfterOpen\"],push:[\"cdkConnectedOverlayPush\",\"push\"],positions:[\"cdkConnectedOverlayPositions\",\"positions\"],origin:[\"cdkConnectedOverlayOrigin\",\"origin\"],positionStrategy:[\"cdkConnectedOverlayPositionStrategy\",\"positionStrategy\"],width:[\"cdkConnectedOverlayWidth\",\"width\"],height:[\"cdkConnectedOverlayHeight\",\"height\"],minWidth:[\"cdkConnectedOverlayMinWidth\",\"minWidth\"],minHeight:[\"cdkConnectedOverlayMinHeight\",\"minHeight\"],backdropClass:[\"cdkConnectedOverlayBackdropClass\",\"backdropClass\"],panelClass:[\"cdkConnectedOverlayPanelClass\",\"panelClass\"],transformOriginSelector:[\"cdkConnectedOverlayTransformOriginOn\",\"transformOriginSelector\"]},outputs:{backdropClick:\"backdropClick\",positionChange:\"positionChange\",attach:\"attach\",detach:\"detach\",overlayKeydown:\"overlayKeydown\",overlayOutsideClick:\"overlayOutsideClick\"},exportAs:[\"cdkConnectedOverlay\"],features:[o.yb]}),t})();const xs={provide:vs,deps:[gs],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};let Cs=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},providers:[gs,xs],imports:[[_t,pt,Re],Re]}),t})(),ks=(()=>{class t{}return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275dir=o.Hb({type:t}),t})();const Ss=new o.q(\"MatFormField\");let Os=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},imports:[[s.b,Ot,H],Ot]}),t})();var Rs=i(\"NXyV\");const Is=[\"trigger\"],Es=[\"panel\"];function Ps(t,e){if(1&t&&(o.Sb(0,\"span\",8),o.uc(1),o.Rb()),2&t){const t=o.bc();o.Ab(1),o.vc(t.placeholder)}}function As(t,e){if(1&t&&(o.Sb(0,\"span\",12),o.uc(1),o.Rb()),2&t){const t=o.bc(2);o.Ab(1),o.vc(t.triggerValue)}}function Ms(t,e){1&t&&o.cc(0,0,[\"*ngSwitchCase\",\"true\"])}function Ts(t,e){if(1&t&&(o.Sb(0,\"span\",9),o.sc(1,As,2,1,\"span\",10),o.sc(2,Ms,1,0,\"ng-content\",11),o.Rb()),2&t){const t=o.bc();o.ec(\"ngSwitch\",!!t.customTrigger),o.Ab(2),o.ec(\"ngSwitchCase\",!0)}}function Ds(t,e){if(1&t){const t=o.Tb();o.Sb(0,\"div\",13),o.Sb(1,\"div\",14,15),o.Zb(\"@transformPanel.done\",function(e){return o.mc(t),o.bc()._panelDoneAnimatingStream.next(e.toState)})(\"keydown\",function(e){return o.mc(t),o.bc()._handleKeydown(e)}),o.cc(3,1),o.Rb(),o.Rb()}if(2&t){const t=o.bc();o.ec(\"@transformPanelWrap\",void 0),o.Ab(1),o.Db(\"mat-select-panel \",t._getPanelTheme(),\"\"),o.rc(\"transform-origin\",t._transformOrigin)(\"font-size\",t._triggerFontSize,\"px\"),o.ec(\"ngClass\",t.panelClass)(\"@transformPanel\",t.multiple?\"showing-multiple\":\"showing\"),o.Bb(\"id\",t.id+\"-panel\")(\"aria-multiselectable\",t.multiple)(\"aria-label\",t.ariaLabel||null)(\"aria-labelledby\",t._getPanelAriaLabelledby())}}const Ls=[[[\"mat-select-trigger\"]],\"*\"],Bs=[\"mat-select-trigger\",\"*\"],js={transformPanelWrap:Object(de.l)(\"transformPanelWrap\",[Object(de.k)(\"* => void\",Object(de.g)(\"@transformPanel\",[Object(de.f)()],{optional:!0}))]),transformPanel:Object(de.l)(\"transformPanel\",[Object(de.i)(\"void\",Object(de.j)({transform:\"scaleY(0.8)\",minWidth:\"100%\",opacity:0})),Object(de.i)(\"showing\",Object(de.j)({opacity:1,minWidth:\"calc(100% + 32px)\",transform:\"scaleY(1)\"})),Object(de.i)(\"showing-multiple\",Object(de.j)({opacity:1,minWidth:\"calc(100% + 64px)\",transform:\"scaleY(1)\"})),Object(de.k)(\"void => *\",Object(de.e)(\"120ms cubic-bezier(0, 0, 0.2, 1)\")),Object(de.k)(\"* => void\",Object(de.e)(\"100ms 25ms linear\",Object(de.j)({opacity:0})))])};let Fs=0;const Ws=256,Ns=new o.q(\"mat-select-scroll-strategy\"),Hs=new o.q(\"MAT_SELECT_CONFIG\"),Vs={provide:Ns,deps:[gs],useFactory:function(t){return()=>t.scrollStrategies.reposition()}};class zs{constructor(t,e){this.source=t,this.value=e}}class Ys{constructor(t,e,i,s,n){this._elementRef=t,this._defaultErrorStateMatcher=e,this._parentForm=i,this._parentFormGroup=s,this.ngControl=n}}const Ks=Et(Pt(Rt(At(Ys)))),Xs=new o.q(\"MatSelectTrigger\");let qs=(()=>{class t extends Ks{constructor(t,e,i,s,n,a,l,c,h,d,u,p,b,m){var _,g,f;super(n,s,l,c,d),this._viewportRuler=t,this._changeDetectorRef=e,this._ngZone=i,this._dir=a,this._parentFormField=h,this.ngControl=d,this._liveAnnouncer=b,this._defaultOptions=m,this._panelOpen=!1,this._compareWith=(t,e)=>t===e,this._uid=\"mat-select-\"+Fs++,this._triggerAriaLabelledBy=null,this._destroy=new r.a,this._onChange=()=>{},this._onTouched=()=>{},this._valueId=\"mat-select-value-\"+Fs++,this._panelDoneAnimatingStream=new r.a,this._overlayPanelClass=(null===(_=this._defaultOptions)||void 0===_?void 0:_.overlayPanelClass)||\"\",this._focused=!1,this.controlType=\"mat-select\",this._required=!1,this._multiple=!1,this._disableOptionCentering=null!==(f=null===(g=this._defaultOptions)||void 0===g?void 0:g.disableOptionCentering)&&void 0!==f&&f,this.ariaLabel=\"\",this.optionSelectionChanges=Object(Rs.a)(()=>{const t=this.options;return t?t.changes.pipe(Object(ft.a)(t),Object(xe.a)(()=>Object(ie.a)(...t.map(t=>t.onSelectionChange)))):this._ngZone.onStable.pipe(Object(C.a)(1),Object(xe.a)(()=>this.optionSelectionChanges))}),this.openedChange=new o.n,this._openedStream=this.openedChange.pipe(Object(w.a)(t=>t),Object(x.a)(()=>{})),this._closedStream=this.openedChange.pipe(Object(w.a)(t=>!t),Object(x.a)(()=>{})),this.selectionChange=new o.n,this.valueChange=new o.n,this.ngControl&&(this.ngControl.valueAccessor=this),null!=(null==m?void 0:m.typeaheadDebounceInterval)&&(this._typeaheadDebounceInterval=m.typeaheadDebounceInterval),this._scrollStrategyFactory=p,this._scrollStrategy=this._scrollStrategyFactory(),this.tabIndex=parseInt(u)||0,this.id=this.id}get focused(){return this._focused||this._panelOpen}get placeholder(){return this._placeholder}set placeholder(t){this._placeholder=t,this.stateChanges.next()}get required(){return this._required}set required(t){this._required=k(t),this.stateChanges.next()}get multiple(){return this._multiple}set multiple(t){this._multiple=k(t)}get disableOptionCentering(){return this._disableOptionCentering}set disableOptionCentering(t){this._disableOptionCentering=k(t)}get compareWith(){return this._compareWith}set compareWith(t){this._compareWith=t,this._selectionModel&&this._initializeSelection()}get value(){return this._value}set value(t){(t!==this._value||this._multiple&&Array.isArray(t))&&(this.options&&this._setSelectionByValue(t),this._value=t)}get typeaheadDebounceInterval(){return this._typeaheadDebounceInterval}set typeaheadDebounceInterval(t){this._typeaheadDebounceInterval=S(t)}get id(){return this._id}set id(t){this._id=t||this._uid,this.stateChanges.next()}ngOnInit(){this._selectionModel=new Ce(this.multiple),this.stateChanges.next(),this._panelDoneAnimatingStream.pipe(ue(),_e(this._destroy)).subscribe(()=>this._panelDoneAnimating(this.panelOpen))}ngAfterContentInit(){this._initKeyManager(),this._selectionModel.changed.pipe(_e(this._destroy)).subscribe(t=>{t.added.forEach(t=>t.select()),t.removed.forEach(t=>t.deselect())}),this.options.changes.pipe(Object(ft.a)(null),_e(this._destroy)).subscribe(()=>{this._resetOptions(),this._initializeSelection()})}ngDoCheck(){const t=this._getTriggerAriaLabelledby();if(t!==this._triggerAriaLabelledBy){const e=this._elementRef.nativeElement;this._triggerAriaLabelledBy=t,t?e.setAttribute(\"aria-labelledby\",t):e.removeAttribute(\"aria-labelledby\")}this.ngControl&&this.updateErrorState()}ngOnChanges(t){t.disabled&&this.stateChanges.next(),t.typeaheadDebounceInterval&&this._keyManager&&this._keyManager.withTypeAhead(this._typeaheadDebounceInterval)}ngOnDestroy(){this._destroy.next(),this._destroy.complete(),this.stateChanges.complete()}toggle(){this.panelOpen?this.close():this.open()}open(){this._canOpen()&&(this._panelOpen=!0,this._keyManager.withHorizontalOrientation(null),this._highlightCorrectOption(),this._changeDetectorRef.markForCheck())}close(){this._panelOpen&&(this._panelOpen=!1,this._keyManager.withHorizontalOrientation(this._isRtl()?\"rtl\":\"ltr\"),this._changeDetectorRef.markForCheck(),this._onTouched())}writeValue(t){this.value=t}registerOnChange(t){this._onChange=t}registerOnTouched(t){this._onTouched=t}setDisabledState(t){this.disabled=t,this._changeDetectorRef.markForCheck(),this.stateChanges.next()}get panelOpen(){return this._panelOpen}get selected(){return this.multiple?this._selectionModel.selected:this._selectionModel.selected[0]}get triggerValue(){if(this.empty)return\"\";if(this._multiple){const t=this._selectionModel.selected.map(t=>t.viewValue);return this._isRtl()&&t.reverse(),t.join(\", \")}return this._selectionModel.selected[0].viewValue}_isRtl(){return!!this._dir&&\"rtl\"===this._dir.value}_handleKeydown(t){this.disabled||(this.panelOpen?this._handleOpenKeydown(t):this._handleClosedKeydown(t))}_handleClosedKeydown(t){const e=t.keyCode,i=40===e||38===e||37===e||39===e,s=13===e||32===e,n=this._keyManager;if(!n.isTyping()&&s&&!c(t)||(this.multiple||t.altKey)&&i)t.preventDefault(),this.open();else if(!this.multiple){const e=this.selected;n.onKeydown(t);const i=this.selected;i&&e!==i&&this._liveAnnouncer.announce(i.viewValue,1e4)}}_handleOpenKeydown(t){const e=this._keyManager,i=t.keyCode,s=40===i||38===i,n=e.isTyping();if(s&&t.altKey)t.preventDefault(),this.close();else if(n||13!==i&&32!==i||!e.activeItem||c(t))if(!n&&this._multiple&&65===i&&t.ctrlKey){t.preventDefault();const e=this.options.some(t=>!t.disabled&&!t.selected);this.options.forEach(t=>{t.disabled||(e?t.select():t.deselect())})}else{const i=e.activeItemIndex;e.onKeydown(t),this._multiple&&s&&t.shiftKey&&e.activeItem&&e.activeItemIndex!==i&&e.activeItem._selectViaInteraction()}else t.preventDefault(),e.activeItem._selectViaInteraction()}_onFocus(){this.disabled||(this._focused=!0,this.stateChanges.next())}_onBlur(){this._focused=!1,this.disabled||this.panelOpen||(this._onTouched(),this._changeDetectorRef.markForCheck(),this.stateChanges.next())}_onAttached(){this.overlayDir.positionChange.pipe(Object(C.a)(1)).subscribe(()=>{this._changeDetectorRef.detectChanges(),this._positioningSettled()})}_getPanelTheme(){return this._parentFormField?\"mat-\"+this._parentFormField.color:\"\"}get empty(){return!this._selectionModel||this._selectionModel.isEmpty()}_initializeSelection(){Promise.resolve().then(()=>{this._setSelectionByValue(this.ngControl?this.ngControl.value:this._value),this.stateChanges.next()})}_setSelectionByValue(t){if(this._selectionModel.selected.forEach(t=>t.setInactiveStyles()),this._selectionModel.clear(),this.multiple&&t)Array.isArray(t),t.forEach(t=>this._selectValue(t)),this._sortValues();else{const e=this._selectValue(t);e?this._keyManager.updateActiveItem(e):this.panelOpen||this._keyManager.updateActiveItem(-1)}this._changeDetectorRef.markForCheck()}_selectValue(t){const e=this.options.find(e=>{if(this._selectionModel.isSelected(e))return!1;try{return null!=e.value&&this._compareWith(e.value,t)}catch(i){return!1}});return e&&this._selectionModel.select(e),e}_initKeyManager(){this._keyManager=new z(this.options).withTypeAhead(this._typeaheadDebounceInterval).withVerticalOrientation().withHorizontalOrientation(this._isRtl()?\"rtl\":\"ltr\").withHomeAndEnd().withAllowedModifierKeys([\"shiftKey\"]),this._keyManager.tabOut.pipe(_e(this._destroy)).subscribe(()=>{this.panelOpen&&(!this.multiple&&this._keyManager.activeItem&&this._keyManager.activeItem._selectViaInteraction(),this.focus(),this.close())}),this._keyManager.change.pipe(_e(this._destroy)).subscribe(()=>{this._panelOpen&&this.panel?this._scrollOptionIntoView(this._keyManager.activeItemIndex||0):this._panelOpen||this.multiple||!this._keyManager.activeItem||this._keyManager.activeItem._selectViaInteraction()})}_resetOptions(){const t=Object(ie.a)(this.options.changes,this._destroy);this.optionSelectionChanges.pipe(_e(t)).subscribe(t=>{this._onSelect(t.source,t.isUserInput),t.isUserInput&&!this.multiple&&this._panelOpen&&(this.close(),this.focus())}),Object(ie.a)(...this.options.map(t=>t._stateChanges)).pipe(_e(t)).subscribe(()=>{this._changeDetectorRef.markForCheck(),this.stateChanges.next()})}_onSelect(t,e){const i=this._selectionModel.isSelected(t);null!=t.value||this._multiple?(i!==t.selected&&(t.selected?this._selectionModel.select(t):this._selectionModel.deselect(t)),e&&this._keyManager.setActiveItem(t),this.multiple&&(this._sortValues(),e&&this.focus())):(t.deselect(),this._selectionModel.clear(),null!=this.value&&this._propagateChanges(t.value)),i!==this._selectionModel.isSelected(t)&&this._propagateChanges(),this.stateChanges.next()}_sortValues(){if(this.multiple){const t=this.options.toArray();this._selectionModel.sort((e,i)=>this.sortComparator?this.sortComparator(e,i,t):t.indexOf(e)-t.indexOf(i)),this.stateChanges.next()}}_propagateChanges(t){let e=null;e=this.multiple?this.selected.map(t=>t.value):this.selected?this.selected.value:t,this._value=e,this.valueChange.emit(e),this._onChange(e),this.selectionChange.emit(this._getChangeEvent(e)),this._changeDetectorRef.markForCheck()}_highlightCorrectOption(){this._keyManager&&(this.empty?this._keyManager.setFirstItemActive():this._keyManager.setActiveItem(this._selectionModel.selected[0]))}_canOpen(){var t;return!this._panelOpen&&!this.disabled&&(null===(t=this.options)||void 0===t?void 0:t.length)>0}focus(t){this._elementRef.nativeElement.focus(t)}_getPanelAriaLabelledby(){var t;if(this.ariaLabel)return null;const e=null===(t=this._parentFormField)||void 0===t?void 0:t.getLabelId();return this.ariaLabelledby?(e?e+\" \":\"\")+this.ariaLabelledby:e}_getAriaActiveDescendant(){return this.panelOpen&&this._keyManager&&this._keyManager.activeItem?this._keyManager.activeItem.id:null}_getTriggerAriaLabelledby(){var t;if(this.ariaLabel)return null;const e=null===(t=this._parentFormField)||void 0===t?void 0:t.getLabelId();let i=(e?e+\" \":\"\")+this._valueId;return this.ariaLabelledby&&(i+=\" \"+this.ariaLabelledby),i}_panelDoneAnimating(t){this.openedChange.emit(t)}setDescribedByIds(t){this._ariaDescribedby=t.join(\" \")}onContainerClick(){this.focus(),this.open()}get shouldLabelFloat(){return this._panelOpen||!this.empty||this._focused&&!!this._placeholder}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(Se),o.Mb(o.h),o.Mb(o.A),o.Mb(Mt),o.Mb(o.l),o.Mb(mt,8),o.Mb(Ri.i,8),o.Mb(Ri.d,8),o.Mb(Ss,8),o.Mb(Ri.f,10),o.Xb(\"tabindex\"),o.Mb(Ns),o.Mb(q),o.Mb(Hs,8))},t.\\u0275dir=o.Hb({type:t,viewQuery:function(t,e){if(1&t&&(o.xc(Is,!0),o.xc(Es,!0),o.xc(ws,!0)),2&t){let t;o.kc(t=o.ac())&&(e.trigger=t.first),o.kc(t=o.ac())&&(e.panel=t.first),o.kc(t=o.ac())&&(e.overlayDir=t.first)}},inputs:{ariaLabel:[\"aria-label\",\"ariaLabel\"],id:\"id\",placeholder:\"placeholder\",required:\"required\",multiple:\"multiple\",disableOptionCentering:\"disableOptionCentering\",compareWith:\"compareWith\",value:\"value\",typeaheadDebounceInterval:\"typeaheadDebounceInterval\",panelClass:\"panelClass\",ariaLabelledby:[\"aria-labelledby\",\"ariaLabelledby\"],errorStateMatcher:\"errorStateMatcher\",sortComparator:\"sortComparator\"},outputs:{openedChange:\"openedChange\",_openedStream:\"opened\",_closedStream:\"closed\",selectionChange:\"selectionChange\",valueChange:\"valueChange\"},features:[o.xb,o.yb]}),t})(),Zs=(()=>{class t extends qs{constructor(){super(...arguments),this._scrollTop=0,this._triggerFontSize=0,this._transformOrigin=\"top\",this._offsetY=0,this._positions=[{originX:\"start\",originY:\"top\",overlayX:\"start\",overlayY:\"top\"},{originX:\"start\",originY:\"bottom\",overlayX:\"start\",overlayY:\"bottom\"}]}_calculateOverlayScroll(t,e,i){const s=this._getItemHeight();return Math.min(Math.max(0,s*t-e+s/2),i)}ngOnInit(){super.ngOnInit(),this._viewportRuler.change().pipe(_e(this._destroy)).subscribe(()=>{this.panelOpen&&(this._triggerRect=this.trigger.nativeElement.getBoundingClientRect(),this._changeDetectorRef.markForCheck())})}open(){super._canOpen()&&(super.open(),this._triggerRect=this.trigger.nativeElement.getBoundingClientRect(),this._triggerFontSize=parseInt(getComputedStyle(this.trigger.nativeElement).fontSize||\"0\"),this._calculateOverlayPosition(),this._ngZone.onStable.pipe(Object(C.a)(1)).subscribe(()=>{this._triggerFontSize&&this.overlayDir.overlayRef&&this.overlayDir.overlayRef.overlayElement&&(this.overlayDir.overlayRef.overlayElement.style.fontSize=this._triggerFontSize+\"px\")}))}_scrollOptionIntoView(t){const e=te(t,this.options,this.optionGroups),i=this._getItemHeight();var s,n,o;this.panel.nativeElement.scrollTop=(n=i,(s=(t+e)*i)<(o=this.panel.nativeElement.scrollTop)?s:s+n>o+256?Math.max(0,s-256+n):o)}_positioningSettled(){this._calculateOverlayOffsetX(),this.panel.nativeElement.scrollTop=this._scrollTop}_panelDoneAnimating(t){this.panelOpen?this._scrollTop=0:(this.overlayDir.offsetX=0,this._changeDetectorRef.markForCheck()),super._panelDoneAnimating(t)}_getChangeEvent(t){return new zs(this,t)}_calculateOverlayOffsetX(){const t=this.overlayDir.overlayRef.overlayElement.getBoundingClientRect(),e=this._viewportRuler.getViewportSize(),i=this._isRtl(),s=this.multiple?56:32;let n;if(this.multiple)n=40;else if(this.disableOptionCentering)n=16;else{let t=this._selectionModel.selected[0]||this.options.first;n=t&&t.group?32:16}i||(n*=-1);const o=0-(t.left+n-(i?s:0)),r=t.right+n-e.width+(i?0:s);o>0?n+=o+8:r>0&&(n-=r+8),this.overlayDir.offsetX=Math.round(n),this.overlayDir.overlayRef.updatePosition()}_calculateOverlayOffsetY(t,e,i){const s=this._getItemHeight(),n=(s-this._triggerRect.height)/2,o=Math.floor(Ws/s);let r;return this.disableOptionCentering?0:(r=0===this._scrollTop?t*s:this._scrollTop===i?(t-(this._getItemCount()-o))*s+(s-(this._getItemCount()*s-Ws)%s):e-s/2,Math.round(-1*r-n))}_checkOverlayWithinViewport(t){const e=this._getItemHeight(),i=this._viewportRuler.getViewportSize(),s=this._triggerRect.top-8,n=i.height-this._triggerRect.bottom-8,o=Math.abs(this._offsetY),r=Math.min(this._getItemCount()*e,Ws)-o-this._triggerRect.height;r>n?this._adjustPanelUp(r,n):o>s?this._adjustPanelDown(o,s,t):this._transformOrigin=this._getOriginBasedOnOption()}_adjustPanelUp(t,e){const i=Math.round(t-e);this._scrollTop-=i,this._offsetY-=i,this._transformOrigin=this._getOriginBasedOnOption(),this._scrollTop<=0&&(this._scrollTop=0,this._offsetY=0,this._transformOrigin=\"50% bottom 0px\")}_adjustPanelDown(t,e,i){const s=Math.round(t-e);if(this._scrollTop+=s,this._offsetY+=s,this._transformOrigin=this._getOriginBasedOnOption(),this._scrollTop>=i)return this._scrollTop=i,this._offsetY=0,void(this._transformOrigin=\"50% top 0px\")}_calculateOverlayPosition(){const t=this._getItemHeight(),e=this._getItemCount(),i=Math.min(e*t,Ws),s=e*t-i;let n;n=this.empty?0:Math.max(this.options.toArray().indexOf(this._selectionModel.selected[0]),0),n+=te(n,this.options,this.optionGroups);const o=i/2;this._scrollTop=this._calculateOverlayScroll(n,o,s),this._offsetY=this._calculateOverlayOffsetY(n,o,s),this._checkOverlayWithinViewport(s)}_getOriginBasedOnOption(){const t=this._getItemHeight(),e=(t-this._triggerRect.height)/2;return`50% ${Math.abs(this._offsetY)-e+t/2}px 0px`}_getItemHeight(){return 3*this._triggerFontSize}_getItemCount(){return this.options.length+this.optionGroups.length}}return t.\\u0275fac=function(e){return Gs(e||t)},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"mat-select\"]],contentQueries:function(t,e,i){if(1&t&&(o.Fb(i,Xs,!0),o.Fb(i,Qt,!0),o.Fb(i,Gt,!0)),2&t){let t;o.kc(t=o.ac())&&(e.customTrigger=t.first),o.kc(t=o.ac())&&(e.options=t),o.kc(t=o.ac())&&(e.optionGroups=t)}},hostAttrs:[\"role\",\"combobox\",\"aria-autocomplete\",\"none\",\"aria-haspopup\",\"true\",1,\"mat-select\"],hostVars:20,hostBindings:function(t,e){1&t&&o.Zb(\"keydown\",function(t){return e._handleKeydown(t)})(\"focus\",function(){return e._onFocus()})(\"blur\",function(){return e._onBlur()}),2&t&&(o.Bb(\"id\",e.id)(\"tabindex\",e.tabIndex)(\"aria-controls\",e.panelOpen?e.id+\"-panel\":null)(\"aria-expanded\",e.panelOpen)(\"aria-label\",e.ariaLabel||null)(\"aria-required\",e.required.toString())(\"aria-disabled\",e.disabled.toString())(\"aria-invalid\",e.errorState)(\"aria-describedby\",e._ariaDescribedby||null)(\"aria-activedescendant\",e._getAriaActiveDescendant()),o.Eb(\"mat-select-disabled\",e.disabled)(\"mat-select-invalid\",e.errorState)(\"mat-select-required\",e.required)(\"mat-select-empty\",e.empty)(\"mat-select-multiple\",e.multiple))},inputs:{disabled:\"disabled\",disableRipple:\"disableRipple\",tabIndex:\"tabIndex\"},exportAs:[\"matSelect\"],features:[o.zb([{provide:ks,useExisting:t},{provide:Yt,useExisting:t}]),o.xb],ngContentSelectors:Bs,decls:9,vars:12,consts:[[\"cdk-overlay-origin\",\"\",1,\"mat-select-trigger\",3,\"click\"],[\"origin\",\"cdkOverlayOrigin\",\"trigger\",\"\"],[1,\"mat-select-value\",3,\"ngSwitch\"],[\"class\",\"mat-select-placeholder mat-select-min-line\",4,\"ngSwitchCase\"],[\"class\",\"mat-select-value-text\",3,\"ngSwitch\",4,\"ngSwitchCase\"],[1,\"mat-select-arrow-wrapper\"],[1,\"mat-select-arrow\"],[\"cdk-connected-overlay\",\"\",\"cdkConnectedOverlayLockPosition\",\"\",\"cdkConnectedOverlayHasBackdrop\",\"\",\"cdkConnectedOverlayBackdropClass\",\"cdk-overlay-transparent-backdrop\",3,\"cdkConnectedOverlayPanelClass\",\"cdkConnectedOverlayScrollStrategy\",\"cdkConnectedOverlayOrigin\",\"cdkConnectedOverlayOpen\",\"cdkConnectedOverlayPositions\",\"cdkConnectedOverlayMinWidth\",\"cdkConnectedOverlayOffsetY\",\"backdropClick\",\"attach\",\"detach\"],[1,\"mat-select-placeholder\",\"mat-select-min-line\"],[1,\"mat-select-value-text\",3,\"ngSwitch\"],[\"class\",\"mat-select-min-line\",4,\"ngSwitchDefault\"],[4,\"ngSwitchCase\"],[1,\"mat-select-min-line\"],[1,\"mat-select-panel-wrap\"],[\"role\",\"listbox\",\"tabindex\",\"-1\",3,\"ngClass\",\"keydown\"],[\"panel\",\"\"]],template:function(t,e){if(1&t&&(o.dc(Ls),o.Sb(0,\"div\",0,1),o.Zb(\"click\",function(){return e.toggle()}),o.Sb(3,\"div\",2),o.sc(4,Ps,2,1,\"span\",3),o.sc(5,Ts,3,2,\"span\",4),o.Rb(),o.Sb(6,\"div\",5),o.Nb(7,\"div\",6),o.Rb(),o.Rb(),o.sc(8,Ds,4,14,\"ng-template\",7),o.Zb(\"backdropClick\",function(){return e.close()})(\"attach\",function(){return e._onAttached()})(\"detach\",function(){return e.close()})),2&t){const t=o.lc(1);o.Bb(\"aria-owns\",e.panelOpen?e.id+\"-panel\":null),o.Ab(3),o.ec(\"ngSwitch\",e.empty),o.Bb(\"id\",e._valueId),o.Ab(1),o.ec(\"ngSwitchCase\",!0),o.Ab(1),o.ec(\"ngSwitchCase\",!1),o.Ab(3),o.ec(\"cdkConnectedOverlayPanelClass\",e._overlayPanelClass)(\"cdkConnectedOverlayScrollStrategy\",e._scrollStrategy)(\"cdkConnectedOverlayOrigin\",t)(\"cdkConnectedOverlayOpen\",e.panelOpen)(\"cdkConnectedOverlayPositions\",e._positions)(\"cdkConnectedOverlayMinWidth\",null==e._triggerRect?null:e._triggerRect.width)(\"cdkConnectedOverlayOffsetY\",e._offsetY)}},directives:[ys,s.l,s.m,ws,s.n,s.h],styles:['.mat-select{display:inline-block;width:100%;outline:none}.mat-select-trigger{display:inline-table;cursor:pointer;position:relative;box-sizing:border-box}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-value{display:table-cell;max-width:0;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{display:table-cell;vertical-align:middle}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel-wrap{flex-basis:100%}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px;outline:0}.cdk-high-contrast-active .mat-select-panel{outline:solid 1px}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}.mat-select-min-line:empty::before{content:\" \";white-space:pre;width:1px}\\n'],encapsulation:2,data:{animation:[js.transformPanelWrap,js.transformPanel]},changeDetection:0}),t})();const Gs=o.Ub(Zs);let Js=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},providers:[Vs],imports:[[s.b,Cs,ee,Ot],Oe,Os,ee,Ot]}),t})(),Us=(()=>{class t{constructor(){}ngOnInit(){console.log(\"item\",this.item)}}return t.\\u0275fac=function(e){return new(e||t)},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"app-email-mobile-verification\"]],inputs:{item:\"item\"},decls:13,vars:0,consts:[[1,\"_m0\",\"_forgotTextColor\"],[1,\"_mt\",\"_inputLabel\"],[\"placeholder\",\"Mobile OTP\",\"type\",\"tel\",\"maxlength\",\"4\",1,\"_inputBox\"],[\"placeholder\",\"Email OTP\",\"type\",\"tel\",\"maxlength\",\"4\",1,\"_inputBox\"],[1,\"_mt\",\"_textCen\"],[\"mat-button\",\"\",1,\"button\",\"_width100\"]],template:function(t,e){1&t&&(o.Sb(0,\"h3\",0),o.uc(1,\"OTP Verify\"),o.Rb(),o.Sb(2,\"div\"),o.Sb(3,\"label\",1),o.uc(4,\"Mobile OTP\"),o.Rb(),o.Nb(5,\"input\",2),o.Rb(),o.Sb(6,\"div\"),o.Sb(7,\"label\",1),o.uc(8,\"Email OTP\"),o.Rb(),o.Nb(9,\"input\",3),o.Rb(),o.Sb(10,\"div\",4),o.Sb(11,\"button\",5),o.uc(12,\" Verify OTP ( Email and Mobilenumber ) \"),o.Rb(),o.Rb())},directives:[xi],styles:[\"\"]}),t})();function $s(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Company name is required \"),o.Rb())}function Qs(t,e){if(1&t&&(o.Sb(0,\"div\",23),o.sc(1,$s,2,0,\"div\",24),o.Rb()),2&t){const t=o.bc(2);o.Ab(1),o.ec(\"ngIf\",null==t.f.companyName.errors?null:t.f.companyName.errors.required)}}function tn(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\"Email is required\"),o.Rb())}function en(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Email must be a valid email address \"),o.Rb())}function sn(t,e){if(1&t&&(o.Sb(0,\"div\",23),o.sc(1,tn,2,0,\"div\",24),o.sc(2,en,2,0,\"div\",24),o.Rb()),2&t){const t=o.bc(2);o.Ab(1),o.ec(\"ngIf\",t.f.email.errors.required),o.Ab(1),o.ec(\"ngIf\",t.f.email.errors.email)}}function nn(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Mobile Number is required \"),o.Rb())}function on(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Please enter valid mobile number \"),o.Rb())}function rn(t,e){if(1&t&&(o.Sb(0,\"div\",23),o.sc(1,nn,2,0,\"div\",24),o.sc(2,on,2,0,\"div\",24),o.Rb()),2&t){const t=o.bc(2);o.Ab(1),o.ec(\"ngIf\",t.f.mobileNumber.errors.required),o.Ab(1),o.ec(\"ngIf\",null==t.f.mobileNumber.errors.pattern?null:t.f.mobileNumber.errors.pattern.requiredPattern)}}function an(t,e){if(1&t&&(o.Sb(0,\"mat-option\",25),o.uc(1),o.Rb()),2&t){const t=e.$implicit;o.ec(\"value\",t.solution_id),o.Ab(1),o.vc(null==t?null:t.solution_name)}}function ln(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Solution is required \"),o.Rb())}function cn(t,e){if(1&t&&(o.Sb(0,\"div\",23),o.sc(1,ln,2,0,\"div\",24),o.Rb()),2&t){const t=o.bc(2);o.Ab(1),o.ec(\"ngIf\",t.f.solution.errors.required)}}function hn(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Password is required \"),o.Rb())}function dn(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Password must be at least 6 characters \"),o.Rb())}function un(t,e){if(1&t&&(o.Sb(0,\"div\",23),o.sc(1,hn,2,0,\"div\",24),o.sc(2,dn,2,0,\"div\",24),o.Rb()),2&t){const t=o.bc(2);o.Ab(1),o.ec(\"ngIf\",t.f.password.errors.required),o.Ab(1),o.ec(\"ngIf\",t.f.password.errors.minlength)}}function pn(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Confirm Password is required \"),o.Rb())}function bn(t,e){1&t&&(o.Sb(0,\"div\"),o.uc(1,\" Passwords must match \"),o.Rb())}function mn(t,e){if(1&t&&(o.Sb(0,\"div\",23),o.sc(1,pn,2,0,\"div\",24),o.sc(2,bn,2,0,\"div\",24),o.Rb()),2&t){const t=o.bc(2);o.Ab(1),o.ec(\"ngIf\",t.f.confirmPassword.errors.required),o.Ab(1),o.ec(\"ngIf\",t.f.confirmPassword.errors.mustMatch)}}function _n(t,e){if(1&t){const t=o.Tb();o.Sb(0,\"div\"),o.Sb(1,\"form\",8),o.Sb(2,\"h3\",9),o.uc(3,\"Sign up\"),o.Rb(),o.Sb(4,\"div\"),o.Sb(5,\"label\",10),o.uc(6,\"Company name\"),o.Rb(),o.Nb(7,\"input\",11),o.sc(8,Qs,2,1,\"div\",12),o.Rb(),o.Sb(9,\"div\"),o.Sb(10,\"label\",10),o.uc(11,\"Email\"),o.Rb(),o.Nb(12,\"input\",13),o.sc(13,sn,3,2,\"div\",12),o.Rb(),o.Sb(14,\"div\"),o.Sb(15,\"label\",10),o.uc(16,\"Mobile Number\"),o.Rb(),o.Nb(17,\"input\",14),o.sc(18,rn,3,2,\"div\",12),o.Rb(),o.Sb(19,\"div\"),o.Sb(20,\"label\",10),o.uc(21,\"Solution\"),o.Rb(),o.Sb(22,\"mat-select\",15),o.sc(23,an,2,2,\"mat-option\",16),o.Rb(),o.sc(24,cn,2,1,\"div\",12),o.Rb(),o.Sb(25,\"div\"),o.Sb(26,\"label\",10),o.uc(27,\"Password\"),o.Rb(),o.Nb(28,\"input\",17),o.sc(29,un,3,2,\"div\",12),o.Rb(),o.Sb(30,\"div\"),o.Sb(31,\"label\",10),o.uc(32,\"Confirm Password\"),o.Rb(),o.Nb(33,\"input\",18),o.sc(34,mn,3,2,\"div\",12),o.Rb(),o.Sb(35,\"div\",19),o.Sb(36,\"button\",20),o.Zb(\"click\",function(){return o.mc(t),o.bc().signInSumbit()}),o.uc(37,\" Sign in \"),o.Rb(),o.Rb(),o.Sb(38,\"div\",21),o.uc(39,\" Already have login and password?\"),o.Sb(40,\"span\",22),o.uc(41,\"\\xa0Sign in\"),o.Rb(),o.Rb(),o.Rb(),o.Rb()}if(2&t){const t=o.bc();o.Ab(1),o.ec(\"formGroup\",t.signInForm),o.Ab(7),o.ec(\"ngIf\",t.submitted&&(null==t.f.companyName?null:t.f.companyName.errors)),o.Ab(5),o.ec(\"ngIf\",t.submitted&&t.f.email.errors),o.Ab(5),o.ec(\"ngIf\",t.submitted&&t.f.mobileNumber.errors),o.Ab(5),o.ec(\"ngForOf\",t.solutionListData),o.Ab(1),o.ec(\"ngIf\",t.submitted&&t.f.solution.errors),o.Ab(5),o.ec(\"ngIf\",t.submitted&&t.f.password.errors),o.Ab(5),o.ec(\"ngIf\",t.submitted&&t.f.confirmPassword.errors)}}function gn(t,e){if(1&t&&o.Nb(0,\"app-email-mobile-verification\",26),2&t){const t=o.bc();o.ec(\"item\",t.solutionListData)}}const fn=[{path:\"login\",component:Oi},{path:\"forgot-password\",component:Fi},{path:\"registration\",component:(()=>{class t{constructor(t,e,i){this.endPoints=t,this.toastMessage=e,this.formBuilder=i,this.signBasicDetailsStatus=!1,this.submitted=!1,this.solutionListData=[{solution_id:1,solution_key:\"rIbXOMaLTg3rTLv3\",solution_name:\"Food Delivery\"}]}ngOnInit(){this.signInForm=this.formBuilder.group({companyName:[\"\",Ri.k.required],email:[\"\",[Ri.k.required,Ri.k.email]],mobileNumber:[\"\",[Ri.k.required,Ri.k.pattern(\"^((\\\\+91-?)|0)?[0-9]{10}$\")]],solution:[\"\",Ri.k.required],password:[\"\",[Ri.k.required,Ri.k.minLength(6)]],confirmPassword:[\"\",Ri.k.required]},{validator:Ii(\"password\",\"confirmPassword\")})}get f(){var t;return null===(t=this.signInForm)||void 0===t?void 0:t.controls}signInSumbit(){var t;console.log(\"form\",this.signInForm),this.submitted=!0,(null===(t=this.signInForm)||void 0===t?void 0:t.valid)&&(this.signBasicDetailsStatus=!0)}}return t.\\u0275fac=function(e){return new(e||t)(o.Mb(Wi),o.Mb(Ni.a),o.Mb(Ri.b))},t.\\u0275cmp=o.Gb({type:t,selectors:[[\"app-registration\"]],decls:11,vars:2,consts:[[1,\"row\",\"_width100\",2,\"height\",\"100%\",\"margin\",\"0px\"],[1,\"col-xl-5\",\"col-lg-5\",\"col-md-5\",\"col-sm-12\",\"col-xs-12\",\"_imgDiv\"],[\"src\",\"/assets/Register-Img.png\",2,\"width\",\"100%\"],[1,\"col-xl-7\",\"col-lg-7\",\"col-md-7\",\"col-sm-12\",\"col-xs-12\"],[1,\"_rightSideContainer\"],[1,\"_m0\",\"_fw700\"],[4,\"ngIf\",\"ngIfElse\"],[\"verifyOTP\",\"\"],[3,\"formGroup\"],[1,\"_m0\",\"_forgotTextColor\"],[1,\"_mt\",\"_inputLabel\"],[\"placeholder\",\"Company name\",\"formControlName\",\"companyName\",\"type\",\"text\",1,\"_inputBox\"],[\"class\",\"_alertTextColor\",4,\"ngIf\"],[\"placeholder\",\"Email\",\"formControlName\",\"email\",\"type\",\"text\",1,\"_inputBox\"],[\"placeholder\",\"Mobile Number\",\"formControlName\",\"mobileNumber\",\"type\",\"tel\",1,\"_inputBox\"],[\"formControlName\",\"solution\",\"placeholder\",\"Solution\",1,\"_inputBox\"],[3,\"value\",4,\"ngFor\",\"ngForOf\"],[\"placeholder\",\"Password\",\"formControlName\",\"password\",\"type\",\"password\",1,\"_inputBox\"],[\"placeholder\",\"Confirm Password\",\"formControlName\",\"confirmPassword\",\"type\",\"password\",1,\"_inputBox\"],[1,\"_mt\",\"_textCen\"],[\"mat-button\",\"\",1,\"button\",\"_width100\",3,\"click\"],[1,\"_textStart\",\"_mt\"],[\"routerLink\",\"/login\",1,\"_cursorPointer\",\"_primaryTextColor\"],[1,\"_alertTextColor\"],[4,\"ngIf\"],[3,\"value\"],[3,\"item\"]],template:function(t,e){if(1&t&&(o.Sb(0,\"div\",0),o.Sb(1,\"div\",1),o.Nb(2,\"img\",2),o.Rb(),o.Sb(3,\"div\",3),o.Sb(4,\"div\",4),o.Sb(5,\"div\"),o.Sb(6,\"h1\",5),o.uc(7,\"ConvoBot360\"),o.Rb(),o.sc(8,_n,42,8,\"div\",6),o.sc(9,gn,1,1,\"ng-template\",null,7,o.tc),o.Rb(),o.Rb(),o.Rb(),o.Rb()),2&t){const t=o.lc(10);o.Ab(8),o.ec(\"ngIf\",!e.signBasicDetailsStatus)(\"ngIfElse\",t)}},directives:[s.j,Ri.l,Ri.h,Ri.d,Ri.a,Ri.g,Ri.c,Zs,s.i,xi,n.a,Qt,Us],styles:[\"._rightSideContainer[_ngcontent-%COMP%]{width:500px;margin:30px auto}._imgDiv[_ngcontent-%COMP%]{padding:0}@media (max-width:500px){._rightSideContainer[_ngcontent-%COMP%]{width:auto;margin:30px auto}}@media (max-width:768px){._imgDiv[_ngcontent-%COMP%]{display:none}}\"]}),t})()},{path:\"\",redirectTo:\"login\",pathMatch:\"full\"},{path:\"**\",redirectTo:\"login\",pathMatch:\"full\"}];let vn=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},imports:[[n.b.forChild(fn)],n.b]}),t})();i(\"P/hZ\");let yn=(()=>{let t=class{};return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},imports:[[s.b]]}),t})();var wn=i(\"arS9\");let xn=(()=>{class t{}return t.\\u0275mod=o.Kb({type:t}),t.\\u0275inj=o.Jb({factory:function(e){return new(e||t)},providers:[Wi,Ni.a],imports:[[s.b,vn,_i,Ci,Ri.j,Js,Ri.e,yn,wn.b]]}),t})()}}]);","name":"4.fd1dbcaf1a97ebb49d67.js","input":"(window[\"webpackJsonp\"] = window[\"webpackJsonp\"] || []).push([[4],{\n\n/***/ \"305l\":\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, \"AuthModule\", function() { return /* binding */ auth_module_AuthModule; });\n\n// EXTERNAL MODULE: ./node_modules/@angular/common/__ivy_ngcc__/fesm2015/common.js\nvar common = __webpack_require__(\"ofXK\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/router/__ivy_ngcc__/fesm2015/router.js + 15 modules\nvar router = __webpack_require__(\"tyNb\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/core/__ivy_ngcc__/fesm2015/core.js + 4 modules\nvar core = __webpack_require__(\"fXoL\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subject.js\nvar Subject = __webpack_require__(\"XNiG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscription.js + 1 modules\nvar Subscription = __webpack_require__(\"quSY\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/of.js\nvar of = __webpack_require__(\"LRne\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/keycodes.js\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAC_ENTER = 3;\nconst BACKSPACE = 8;\nconst TAB = 9;\nconst NUM_CENTER = 12;\nconst ENTER = 13;\nconst SHIFT = 16;\nconst CONTROL = 17;\nconst ALT = 18;\nconst PAUSE = 19;\nconst CAPS_LOCK = 20;\nconst ESCAPE = 27;\nconst SPACE = 32;\nconst PAGE_UP = 33;\nconst PAGE_DOWN = 34;\nconst END = 35;\nconst HOME = 36;\nconst LEFT_ARROW = 37;\nconst UP_ARROW = 38;\nconst RIGHT_ARROW = 39;\nconst DOWN_ARROW = 40;\nconst PLUS_SIGN = 43;\nconst PRINT_SCREEN = 44;\nconst INSERT = 45;\nconst DELETE = 46;\nconst ZERO = 48;\nconst ONE = 49;\nconst TWO = 50;\nconst THREE = 51;\nconst FOUR = 52;\nconst FIVE = 53;\nconst SIX = 54;\nconst SEVEN = 55;\nconst EIGHT = 56;\nconst NINE = 57;\nconst FF_SEMICOLON = 59; // Firefox (Gecko) fires this for semicolon instead of 186\nconst FF_EQUALS = 61; // Firefox (Gecko) fires this for equals instead of 187\nconst QUESTION_MARK = 63;\nconst AT_SIGN = 64;\nconst A = 65;\nconst B = 66;\nconst C = 67;\nconst D = 68;\nconst E = 69;\nconst F = 70;\nconst G = 71;\nconst H = 72;\nconst I = 73;\nconst J = 74;\nconst K = 75;\nconst L = 76;\nconst M = 77;\nconst N = 78;\nconst O = 79;\nconst P = 80;\nconst Q = 81;\nconst R = 82;\nconst S = 83;\nconst T = 84;\nconst U = 85;\nconst V = 86;\nconst W = 87;\nconst X = 88;\nconst Y = 89;\nconst Z = 90;\nconst META = 91; // WIN_KEY_LEFT\nconst MAC_WK_CMD_LEFT = 91;\nconst MAC_WK_CMD_RIGHT = 93;\nconst CONTEXT_MENU = 93;\nconst NUMPAD_ZERO = 96;\nconst NUMPAD_ONE = 97;\nconst NUMPAD_TWO = 98;\nconst NUMPAD_THREE = 99;\nconst NUMPAD_FOUR = 100;\nconst NUMPAD_FIVE = 101;\nconst NUMPAD_SIX = 102;\nconst NUMPAD_SEVEN = 103;\nconst NUMPAD_EIGHT = 104;\nconst NUMPAD_NINE = 105;\nconst NUMPAD_MULTIPLY = 106;\nconst NUMPAD_PLUS = 107;\nconst NUMPAD_MINUS = 109;\nconst NUMPAD_PERIOD = 110;\nconst NUMPAD_DIVIDE = 111;\nconst F1 = 112;\nconst F2 = 113;\nconst F3 = 114;\nconst F4 = 115;\nconst F5 = 116;\nconst F6 = 117;\nconst F7 = 118;\nconst F8 = 119;\nconst F9 = 120;\nconst F10 = 121;\nconst F11 = 122;\nconst F12 = 123;\nconst NUM_LOCK = 144;\nconst SCROLL_LOCK = 145;\nconst FIRST_MEDIA = 166;\nconst FF_MINUS = 173;\nconst MUTE = 173; // Firefox (Gecko) fires 181 for MUTE\nconst VOLUME_DOWN = 174; // Firefox (Gecko) fires 182 for VOLUME_DOWN\nconst VOLUME_UP = 175; // Firefox (Gecko) fires 183 for VOLUME_UP\nconst FF_MUTE = 181;\nconst FF_VOLUME_DOWN = 182;\nconst LAST_MEDIA = 183;\nconst FF_VOLUME_UP = 183;\nconst SEMICOLON = 186; // Firefox (Gecko) fires 59 for SEMICOLON\nconst EQUALS = 187; // Firefox (Gecko) fires 61 for EQUALS\nconst COMMA = 188;\nconst DASH = 189; // Firefox (Gecko) fires 173 for DASH/MINUS\nconst PERIOD = 190;\nconst SLASH = 191;\nconst APOSTROPHE = 192;\nconst TILDE = 192;\nconst OPEN_SQUARE_BRACKET = 219;\nconst BACKSLASH = 220;\nconst CLOSE_SQUARE_BRACKET = 221;\nconst SINGLE_QUOTE = 222;\nconst MAC_META = 224;\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Checks whether a modifier key is pressed.\n * @param event Event to be checked.\n */\nfunction hasModifierKey(event, ...modifiers) {\n    if (modifiers.length) {\n        return modifiers.some(modifier => event[modifier]);\n    }\n    return event.altKey || event.shiftKey || event.ctrlKey || event.metaKey;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=keycodes.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/tap.js + 1 modules\nvar tap = __webpack_require__(\"vkgz\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Subscriber.js\nvar Subscriber = __webpack_require__(\"7o/Q\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/Action.js\n\nclass Action_Action extends Subscription[\"a\" /* Subscription */] {\n    constructor(scheduler, work) {\n        super();\n    }\n    schedule(state, delay = 0) {\n        return this;\n    }\n}\n//# sourceMappingURL=Action.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncAction.js\n\nclass AsyncAction_AsyncAction extends Action_Action {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n        this.pending = false;\n    }\n    schedule(state, delay = 0) {\n        if (this.closed) {\n            return this;\n        }\n        this.state = state;\n        const id = this.id;\n        const scheduler = this.scheduler;\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, delay);\n        }\n        this.pending = true;\n        this.delay = delay;\n        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);\n        return this;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        return setInterval(scheduler.flush.bind(scheduler, this), delay);\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && this.delay === delay && this.pending === false) {\n            return id;\n        }\n        clearInterval(id);\n        return undefined;\n    }\n    execute(state, delay) {\n        if (this.closed) {\n            return new Error('executing a cancelled action');\n        }\n        this.pending = false;\n        const error = this._execute(state, delay);\n        if (error) {\n            return error;\n        }\n        else if (this.pending === false && this.id != null) {\n            this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n        }\n    }\n    _execute(state, delay) {\n        let errored = false;\n        let errorValue = undefined;\n        try {\n            this.work(state);\n        }\n        catch (e) {\n            errored = true;\n            errorValue = !!e && e || new Error(e);\n        }\n        if (errored) {\n            this.unsubscribe();\n            return errorValue;\n        }\n    }\n    _unsubscribe() {\n        const id = this.id;\n        const scheduler = this.scheduler;\n        const actions = scheduler.actions;\n        const index = actions.indexOf(this);\n        this.work = null;\n        this.state = null;\n        this.pending = false;\n        this.scheduler = null;\n        if (index !== -1) {\n            actions.splice(index, 1);\n        }\n        if (id != null) {\n            this.id = this.recycleAsyncId(scheduler, id, null);\n        }\n        this.delay = null;\n    }\n}\n//# sourceMappingURL=AsyncAction.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/Scheduler.js\nlet Scheduler = /*@__PURE__*/ (() => {\n    class Scheduler {\n        constructor(SchedulerAction, now = Scheduler.now) {\n            this.SchedulerAction = SchedulerAction;\n            this.now = now;\n        }\n        schedule(work, delay = 0, state) {\n            return new this.SchedulerAction(this, work).schedule(state, delay);\n        }\n    }\n    Scheduler.now = () => Date.now();\n    return Scheduler;\n})();\n//# sourceMappingURL=Scheduler.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsyncScheduler.js\n\nclass AsyncScheduler_AsyncScheduler extends Scheduler {\n    constructor(SchedulerAction, now = Scheduler.now) {\n        super(SchedulerAction, () => {\n            if (AsyncScheduler_AsyncScheduler.delegate && AsyncScheduler_AsyncScheduler.delegate !== this) {\n                return AsyncScheduler_AsyncScheduler.delegate.now();\n            }\n            else {\n                return now();\n            }\n        });\n        this.actions = [];\n        this.active = false;\n        this.scheduled = undefined;\n    }\n    schedule(work, delay = 0, state) {\n        if (AsyncScheduler_AsyncScheduler.delegate && AsyncScheduler_AsyncScheduler.delegate !== this) {\n            return AsyncScheduler_AsyncScheduler.delegate.schedule(work, delay, state);\n        }\n        else {\n            return super.schedule(work, delay, state);\n        }\n    }\n    flush(action) {\n        const { actions } = this;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        let error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift());\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n//# sourceMappingURL=AsyncScheduler.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/async.js\n\n\nconst asyncScheduler = /*@__PURE__*/ new AsyncScheduler_AsyncScheduler(AsyncAction_AsyncAction);\nconst async_async = asyncScheduler;\n//# sourceMappingURL=async.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/debounceTime.js\n\n\nfunction debounceTime(dueTime, scheduler = async_async) {\n    return (source) => source.lift(new DebounceTimeOperator(dueTime, scheduler));\n}\nclass DebounceTimeOperator {\n    constructor(dueTime, scheduler) {\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new debounceTime_DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));\n    }\n}\nclass debounceTime_DebounceTimeSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination, dueTime, scheduler) {\n        super(destination);\n        this.dueTime = dueTime;\n        this.scheduler = scheduler;\n        this.debouncedSubscription = null;\n        this.lastValue = null;\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.clearDebounce();\n        this.lastValue = value;\n        this.hasValue = true;\n        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext, this.dueTime, this));\n    }\n    _complete() {\n        this.debouncedNext();\n        this.destination.complete();\n    }\n    debouncedNext() {\n        this.clearDebounce();\n        if (this.hasValue) {\n            const { lastValue } = this;\n            this.lastValue = null;\n            this.hasValue = false;\n            this.destination.next(lastValue);\n        }\n    }\n    clearDebounce() {\n        const debouncedSubscription = this.debouncedSubscription;\n        if (debouncedSubscription !== null) {\n            this.remove(debouncedSubscription);\n            debouncedSubscription.unsubscribe();\n            this.debouncedSubscription = null;\n        }\n    }\n}\nfunction dispatchNext(subscriber) {\n    subscriber.debouncedNext();\n}\n//# sourceMappingURL=debounceTime.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/filter.js\nvar filter = __webpack_require__(\"pLZG\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/map.js\nvar map = __webpack_require__(\"lJxs\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/take.js\nvar take = __webpack_require__(\"IzEk\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/fesm2015/coercion.js\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Coerces a data-bound value (typically a string) to a boolean. */\nfunction coerceBooleanProperty(value) {\n    return value != null && `${value}` !== 'false';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction coerceNumberProperty(value, fallbackValue = 0) {\n    return _isNumberValue(value) ? Number(value) : fallbackValue;\n}\n/**\n * Whether the provided value is considered a number.\n * @docs-private\n */\nfunction _isNumberValue(value) {\n    // parseFloat(value) handles most of the cases we're interested in (it treats null, empty string,\n    // and other non-number values as NaN, where Number just uses 0) but it considers the string\n    // '123hello' to be a valid number. Therefore we also check if Number(value) is NaN.\n    return !isNaN(parseFloat(value)) && !isNaN(Number(value));\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nfunction coerceArray(value) {\n    return Array.isArray(value) ? value : [value];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Coerces a value to a CSS pixel value. */\nfunction coerceCssPixelValue(value) {\n    if (value == null) {\n        return '';\n    }\n    return typeof value === 'string' ? value : `${value}px`;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Coerces an ElementRef or an Element into an element.\n * Useful for APIs that can accept either a ref or the native element itself.\n */\nfunction coerceElement(elementOrRef) {\n    return elementOrRef instanceof core[\"l\" /* ElementRef */] ? elementOrRef.nativeElement : elementOrRef;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Coerces a value to an array of trimmed non-empty strings.\n * Any input that is not an array, `null` or `undefined` will be turned into a string\n * via `toString()` and subsequently split with the given separator.\n * `null` and `undefined` will result in an empty array.\n * This results in the following outcomes:\n * - `null` -&gt; `[]`\n * - `[null]` -&gt; `[\"null\"]`\n * - `[\"a\", \"b \", \" \"]` -&gt; `[\"a\", \"b\"]`\n * - `[1, [2, 3]]` -&gt; `[\"1\", \"2,3\"]`\n * - `[{ a: 0 }]` -&gt; `[\"[object Object]\"]`\n * - `{ a: 0 }` -&gt; `[\"[object\", \"Object]\"]`\n *\n * Useful for defining CSS classes or table columns.\n * @param value the value to coerce into an array of strings\n * @param separator split-separator if value isn't an array\n */\nfunction coerceStringArray(value, separator = /\\s+/) {\n    const result = [];\n    if (value != null) {\n        const sourceValues = Array.isArray(value) ? value : `${value}`.split(separator);\n        for (const sourceValue of sourceValues) {\n            const trimmedString = `${sourceValue}`.trim();\n            if (trimmedString) {\n                result.push(trimmedString);\n            }\n        }\n    }\n    return result;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n//# sourceMappingURL=coercion.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/platform.js\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Whether the current platform supports the V8 Break Iterator. The V8 check\n// is necessary to detect all Blink based browsers.\n\nlet hasV8BreakIterator;\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\ntry {\n    hasV8BreakIterator = (typeof Intl !== 'undefined' && Intl.v8BreakIterator);\n}\ncatch (_a) {\n    hasV8BreakIterator = false;\n}\nlet platform_Platform = /*@__PURE__*/ (() => {\n    class Platform {\n        constructor(_platformId) {\n            this._platformId = _platformId;\n            // We want to use the Angular platform check because if the Document is shimmed\n            // without the navigator, the following checks will fail. This is preferred because\n            // sometimes the Document may be shimmed without the user's knowledge or intention\n            /** Whether the Angular application is being rendered in the browser. */\n            this.isBrowser = this._platformId ?\n                Object(common[\"s\" /* isPlatformBrowser */])(this._platformId) : typeof document === 'object' && !!document;\n            /** Whether the current browser is Microsoft Edge. */\n            this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent);\n            /** Whether the current rendering engine is Microsoft Trident. */\n            this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent);\n            // EdgeHTML and Trident mock Blink specific things and need to be excluded from this check.\n            /** Whether the current rendering engine is Blink. */\n            this.BLINK = this.isBrowser && (!!(window.chrome || hasV8BreakIterator) &&\n                typeof CSS !== 'undefined' && !this.EDGE && !this.TRIDENT);\n            // Webkit is part of the userAgent in EdgeHTML, Blink and Trident. Therefore we need to\n            // ensure that Webkit runs standalone and is not used as another engine's base.\n            /** Whether the current rendering engine is WebKit. */\n            this.WEBKIT = this.isBrowser &&\n                /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT;\n            /** Whether the current platform is Apple iOS. */\n            this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) &&\n                !('MSStream' in window);\n            // It's difficult to detect the plain Gecko engine, because most of the browsers identify\n            // them self as Gecko-like browsers and modify the userAgent's according to that.\n            // Since we only cover one explicit Firefox case, we can simply check for Firefox\n            // instead of having an unstable check for Gecko.\n            /** Whether the current browser is Firefox. */\n            this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent);\n            /** Whether the current platform is Android. */\n            // Trident on mobile adds the android platform to the userAgent to trick detections.\n            this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT;\n            // Safari browsers will include the Safari keyword in their userAgent. Some browsers may fake\n            // this and just place the Safari keyword in the userAgent. To be more safe about Safari every\n            // Safari browser should also use Webkit as its layout engine.\n            /** Whether the current browser is Safari. */\n            this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT;\n        }\n    }\n    Platform.fac = function Platform_Factory(t) { return new (t || Platform)(core[\"Wb\" /* inject */](core[\"C\" /* PLATFORM_ID */])); };\n    Platform.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function Platform_Factory() { return new Platform(Object(core[\"Wb\" /* inject */])(core[\"C\" /* PLATFORM_ID */])); }, token: Platform, providedIn: \"root\" });\n    return Platform;\n})();\nlet platform_PlatformModule = /*@__PURE__*/ (() => {\n    class PlatformModule {\n    }\n    PlatformModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: PlatformModule });\n    PlatformModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function PlatformModule_Factory(t) { return new (t || PlatformModule)(); } });\n    return PlatformModule;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result Set of input types support by the current browser. */\nlet supportedInputTypes;\n/** Types of `<input>` that *might* be supported. */\nconst candidateInputTypes = [\n    // `color` must come first. Chrome 56 shows a warning if we change the type to `color` after\n    // first changing it to something else:\n    // The specified value \"\" does not conform to the required format.\n    // The format is \"#rrggbb\" where rr, gg, bb are two-digit hexadecimal numbers.\n    'color',\n    'button',\n    'checkbox',\n    'date',\n    'datetime-local',\n    'email',\n    'file',\n    'hidden',\n    'image',\n    'month',\n    'number',\n    'password',\n    'radio',\n    'range',\n    'reset',\n    'search',\n    'submit',\n    'tel',\n    'text',\n    'time',\n    'url',\n    'week',\n];\n/** @returns The input types supported by this browser. */\nfunction getSupportedInputTypes() {\n    // Result is cached.\n    if (supportedInputTypes) {\n        return supportedInputTypes;\n    }\n    // We can't check if an input type is not supported until we're on the browser, so say that\n    // everything is supported when not on the browser. We don't use `Platform` here since it's\n    // just a helper function and can't inject it.\n    if (typeof document !== 'object' || !document) {\n        supportedInputTypes = new Set(candidateInputTypes);\n        return supportedInputTypes;\n    }\n    let featureTestInput = document.createElement('input');\n    supportedInputTypes = new Set(candidateInputTypes.filter(value => {\n        featureTestInput.setAttribute('type', value);\n        return featureTestInput.type === value;\n    }));\n    return supportedInputTypes;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result of whether the user's browser supports passive event listeners. */\nlet supportsPassiveEvents;\n/**\n * Checks whether the user's browser supports passive event listeners.\n * See: https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md\n */\nfunction supportsPassiveEventListeners() {\n    if (supportsPassiveEvents == null && typeof window !== 'undefined') {\n        try {\n            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {\n                get: () => supportsPassiveEvents = true\n            }));\n        }\n        finally {\n            supportsPassiveEvents = supportsPassiveEvents || false;\n        }\n    }\n    return supportsPassiveEvents;\n}\n/**\n * Normalizes an `AddEventListener` object to something that can be passed\n * to `addEventListener` on any browser, no matter whether it supports the\n * `options` parameter.\n * @param options Object to be normalized.\n */\nfunction normalizePassiveListenerOptions(options) {\n    return supportsPassiveEventListeners() ? options : !!options.capture;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Cached result of the way the browser handles the horizontal scroll axis in RTL mode. */\nlet rtlScrollAxisType;\n/** Cached result of the check that indicates whether the browser supports scroll behaviors. */\nlet scrollBehaviorSupported;\n/** Check whether the browser supports scroll behaviors. */\nfunction supportsScrollBehavior() {\n    if (scrollBehaviorSupported == null) {\n        // If we're not in the browser, it can't be supported. Also check for `Element`, because\n        // some projects stub out the global `document` during SSR which can throw us off.\n        if (typeof document !== 'object' || !document || typeof Element !== 'function' || !Element) {\n            scrollBehaviorSupported = false;\n            return scrollBehaviorSupported;\n        }\n        // If the element can have a `scrollBehavior` style, we can be sure that it's supported.\n        if ('scrollBehavior' in document.documentElement.style) {\n            scrollBehaviorSupported = true;\n        }\n        else {\n            // At this point we have 3 possibilities: `scrollTo` isn't supported at all, it's\n            // supported but it doesn't handle scroll behavior, or it has been polyfilled.\n            const scrollToFunction = Element.prototype.scrollTo;\n            if (scrollToFunction) {\n                // We can detect if the function has been polyfilled by calling `toString` on it. Native\n                // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get\n                // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider\n                // polyfilled functions as supporting scroll behavior.\n                scrollBehaviorSupported = !/\\{\\s*\\[native code\\]\\s*\\}/.test(scrollToFunction.toString());\n            }\n            else {\n                scrollBehaviorSupported = false;\n            }\n        }\n    }\n    return scrollBehaviorSupported;\n}\n/**\n * Checks the type of RTL scroll axis used by this browser. As of time of writing, Chrome is NORMAL,\n * Firefox & Safari are NEGATED, and IE & Edge are INVERTED.\n */\nfunction getRtlScrollAxisType() {\n    // We can't check unless we're on the browser. Just assume 'normal' if we're not.\n    if (typeof document !== 'object' || !document) {\n        return 0 /* NORMAL */;\n    }\n    if (rtlScrollAxisType == null) {\n        // Create a 1px wide scrolling container and a 2px wide content element.\n        const scrollContainer = document.createElement('div');\n        const containerStyle = scrollContainer.style;\n        scrollContainer.dir = 'rtl';\n        containerStyle.width = '1px';\n        containerStyle.overflow = 'auto';\n        containerStyle.visibility = 'hidden';\n        containerStyle.pointerEvents = 'none';\n        containerStyle.position = 'absolute';\n        const content = document.createElement('div');\n        const contentStyle = content.style;\n        contentStyle.width = '2px';\n        contentStyle.height = '1px';\n        scrollContainer.appendChild(content);\n        document.body.appendChild(scrollContainer);\n        rtlScrollAxisType = 0 /* NORMAL */;\n        // The viewport starts scrolled all the way to the right in RTL mode. If we are in a NORMAL\n        // browser this would mean that the scrollLeft should be 1. If it's zero instead we know we're\n        // dealing with one of the other two types of browsers.\n        if (scrollContainer.scrollLeft === 0) {\n            // In a NEGATED browser the scrollLeft is always somewhere in [-maxScrollAmount, 0]. For an\n            // INVERTED browser it is always somewhere in [0, maxScrollAmount]. We can determine which by\n            // setting to the scrollLeft to 1. This is past the max for a NEGATED browser, so it will\n            // return 0 when we read it again.\n            scrollContainer.scrollLeft = 1;\n            rtlScrollAxisType =\n                scrollContainer.scrollLeft === 0 ? 1 /* NEGATED */ : 2 /* INVERTED */;\n        }\n        scrollContainer.parentNode.removeChild(scrollContainer);\n    }\n    return rtlScrollAxisType;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet shadowDomIsSupported;\n/** Checks whether the user's browser support Shadow DOM. */\nfunction _supportsShadowDom() {\n    if (shadowDomIsSupported == null) {\n        const head = typeof document !== 'undefined' ? document.head : null;\n        shadowDomIsSupported = !!(head && (head.createShadowRoot || head.attachShadow));\n    }\n    return shadowDomIsSupported;\n}\n/** Gets the shadow root of an element, if supported and the element is inside the Shadow DOM. */\nfunction _getShadowRoot(element) {\n    if (_supportsShadowDom()) {\n        const rootNode = element.getRootNode ? element.getRootNode() : null;\n        // Note that this should be caught by `_supportsShadowDom`, but some\n        // teams have been able to hit this code path on unsupported browsers.\n        if (typeof ShadowRoot !== 'undefined' && ShadowRoot && rootNode instanceof ShadowRoot) {\n            return rootNode;\n        }\n    }\n    return null;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=platform.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/Observable.js + 3 modules\nvar Observable = __webpack_require__(\"HDdC\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/observers.js\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Factory that creates a new MutationObserver and allows us to stub it out in unit tests.\n * @docs-private\n */\n\nlet observers_MutationObserverFactory = /*@__PURE__*/ (() => {\n    class MutationObserverFactory {\n        create(callback) {\n            return typeof MutationObserver === 'undefined' ? null : new MutationObserver(callback);\n        }\n    }\n    MutationObserverFactory.fac = function MutationObserverFactory_Factory(t) { return new (t || MutationObserverFactory)(); };\n    MutationObserverFactory.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function MutationObserverFactory_Factory() { return new MutationObserverFactory(); }, token: MutationObserverFactory, providedIn: \"root\" });\n    return MutationObserverFactory;\n})();\nlet observers_ContentObserver = /*@__PURE__*/ (() => {\n    class ContentObserver {\n        constructor(_mutationObserverFactory) {\n            this._mutationObserverFactory = _mutationObserverFactory;\n            /** Keeps track of the existing MutationObservers so they can be reused. */\n            this._observedElements = new Map();\n        }\n        ngOnDestroy() {\n            this._observedElements.forEach((_, element) => this._cleanupObserver(element));\n        }\n        observe(elementOrRef) {\n            const element = coerceElement(elementOrRef);\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                const stream = this._observeElement(element);\n                const subscription = stream.subscribe(observer);\n                return () => {\n                    subscription.unsubscribe();\n                    this._unobserveElement(element);\n                };\n            });\n        }\n        /**\n         * Observes the given element by using the existing MutationObserver if available, or creating a\n         * new one if not.\n         */\n        _observeElement(element) {\n            if (!this._observedElements.has(element)) {\n                const stream = new Subject[\"a\" /* Subject */]();\n                const observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));\n                if (observer) {\n                    observer.observe(element, {\n                        characterData: true,\n                        childList: true,\n                        subtree: true\n                    });\n                }\n                this._observedElements.set(element, { observer, stream, count: 1 });\n            }\n            else {\n                this._observedElements.get(element).count++;\n            }\n            return this._observedElements.get(element).stream;\n        }\n        /**\n         * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n         * observing this element.\n         */\n        _unobserveElement(element) {\n            if (this._observedElements.has(element)) {\n                this._observedElements.get(element).count--;\n                if (!this._observedElements.get(element).count) {\n                    this._cleanupObserver(element);\n                }\n            }\n        }\n        /** Clean up the underlying MutationObserver for the specified element. */\n        _cleanupObserver(element) {\n            if (this._observedElements.has(element)) {\n                const { observer, stream } = this._observedElements.get(element);\n                if (observer) {\n                    observer.disconnect();\n                }\n                stream.complete();\n                this._observedElements.delete(element);\n            }\n        }\n    }\n    ContentObserver.fac = function ContentObserver_Factory(t) { return new (t || ContentObserver)(core[\"Wb\" /* inject */](observers_MutationObserverFactory)); };\n    ContentObserver.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function ContentObserver_Factory() { return new ContentObserver(Object(core[\"Wb\" /* inject */])(observers_MutationObserverFactory)); }, token: ContentObserver, providedIn: \"root\" });\n    return ContentObserver;\n})();\nlet observers_CdkObserveContent = /*@__PURE__*/ (() => {\n    class CdkObserveContent {\n        constructor(_contentObserver, _elementRef, _ngZone) {\n            this._contentObserver = _contentObserver;\n            this._elementRef = _elementRef;\n            this._ngZone = _ngZone;\n            /** Event emitted for each change in the element's content. */\n            this.event = new core[\"n\" /* EventEmitter */]();\n            this._disabled = false;\n            this._currentSubscription = null;\n        }\n        /**\n         * Whether observing content is disabled. This option can be used\n         * to disconnect the underlying MutationObserver until it is needed.\n         */\n        get disabled() { return this._disabled; }\n        set disabled(value) {\n            this._disabled = coerceBooleanProperty(value);\n            this._disabled ? this._unsubscribe() : this._subscribe();\n        }\n        /** Debounce interval for emitting the changes. */\n        get debounce() { return this._debounce; }\n        set debounce(value) {\n            this._debounce = coerceNumberProperty(value);\n            this._subscribe();\n        }\n        ngAfterContentInit() {\n            if (!this._currentSubscription && !this.disabled) {\n                this._subscribe();\n            }\n        }\n        ngOnDestroy() {\n            this._unsubscribe();\n        }\n        _subscribe() {\n            this._unsubscribe();\n            const stream = this._contentObserver.observe(this._elementRef);\n            // TODO(mmalerba): We shouldn't be emitting on this @Output() outside the zone.\n            // Consider brining it back inside the zone next time we're making breaking changes.\n            // Bringing it back inside can cause things like infinite change detection loops and changed\n            // after checked errors if people's code isn't handling it properly.\n            this._ngZone.runOutsideAngular(() => {\n                this._currentSubscription =\n                    (this.debounce ? stream.pipe(debounceTime(this.debounce)) : stream).subscribe(this.event);\n            });\n        }\n        _unsubscribe() {\n            var _a;\n            (_a = this._currentSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();\n        }\n    }\n    CdkObserveContent.fac = function CdkObserveContent_Factory(t) { return new (t || CdkObserveContent)(core[\"Mb\" /* directiveInject */](observers_ContentObserver), core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */])); };\n    CdkObserveContent.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: CdkObserveContent, selectors: [[\"\", \"cdkObserveContent\", \"\"]], inputs: { disabled: [\"cdkObserveContentDisabled\", \"disabled\"], debounce: \"debounce\" }, outputs: { event: \"cdkObserveContent\" }, exportAs: [\"cdkObserveContent\"] });\n    return CdkObserveContent;\n})();\nlet observers_ObserversModule = /*@__PURE__*/ (() => {\n    class ObserversModule {\n    }\n    ObserversModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: ObserversModule });\n    ObserversModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function ObserversModule_Factory(t) { return new (t || ObserversModule)(); }, providers: [observers_MutationObserverFactory] });\n    return ObserversModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](observers_ObserversModule, { declarations: [observers_CdkObserveContent], exports: [observers_CdkObserveContent] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=observers.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/a11y.js\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** IDs are delimited by an empty space, as per the spec. */\n\n\n\nconst ID_DELIMITER = ' ';\n/**\n * Adds the given ID to the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction addAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    if (ids.some(existingId => existingId.trim() == id.trim())) {\n        return;\n    }\n    ids.push(id.trim());\n    el.setAttribute(attr, ids.join(ID_DELIMITER));\n}\n/**\n * Removes the given ID from the specified ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction removeAriaReferencedId(el, attr, id) {\n    const ids = getAriaReferenceIds(el, attr);\n    const filteredIds = ids.filter(val => val != id.trim());\n    if (filteredIds.length) {\n        el.setAttribute(attr, filteredIds.join(ID_DELIMITER));\n    }\n    else {\n        el.removeAttribute(attr);\n    }\n}\n/**\n * Gets the list of IDs referenced by the given ARIA attribute on an element.\n * Used for attributes such as aria-labelledby, aria-owns, etc.\n */\nfunction getAriaReferenceIds(el, attr) {\n    // Get string array of all individual ids (whitespace delimited) in the attribute value\n    return (el.getAttribute(attr) || '').match(/\\S+/g) || [];\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** ID used for the body container where all messages are appended. */\nconst MESSAGES_CONTAINER_ID = 'cdk-describedby-message-container';\n/** ID prefix used for each created message element. */\nconst CDK_DESCRIBEDBY_ID_PREFIX = 'cdk-describedby-message';\n/** Attribute given to each host element that is described by a message element. */\nconst CDK_DESCRIBEDBY_HOST_ATTRIBUTE = 'cdk-describedby-host';\n/** Global incremental identifier for each registered message element. */\nlet nextId = 0;\n/** Global map of all registered message elements that have been placed into the document. */\nconst messageRegistry = /*@__PURE__*/ new Map();\n/** Container for all registered messages. */\nlet messagesContainer = null;\nlet a11y_AriaDescriber = /*@__PURE__*/ (() => {\n    class AriaDescriber {\n        constructor(_document) {\n            this._document = _document;\n        }\n        describe(hostElement, message, role) {\n            if (!this._canBeDescribed(hostElement, message)) {\n                return;\n            }\n            const key = getKey(message, role);\n            if (typeof message !== 'string') {\n                // We need to ensure that the element has an ID.\n                setMessageId(message);\n                messageRegistry.set(key, { messageElement: message, referenceCount: 0 });\n            }\n            else if (!messageRegistry.has(key)) {\n                this._createMessageElement(message, role);\n            }\n            if (!this._isElementDescribedByMessage(hostElement, key)) {\n                this._addMessageReference(hostElement, key);\n            }\n        }\n        removeDescription(hostElement, message, role) {\n            if (!message || !this._isElementNode(hostElement)) {\n                return;\n            }\n            const key = getKey(message, role);\n            if (this._isElementDescribedByMessage(hostElement, key)) {\n                this._removeMessageReference(hostElement, key);\n            }\n            // If the message is a string, it means that it's one that we created for the\n            // consumer so we can remove it safely, otherwise we should leave it in place.\n            if (typeof message === 'string') {\n                const registeredMessage = messageRegistry.get(key);\n                if (registeredMessage && registeredMessage.referenceCount === 0) {\n                    this._deleteMessageElement(key);\n                }\n            }\n            if (messagesContainer && messagesContainer.childNodes.length === 0) {\n                this._deleteMessagesContainer();\n            }\n        }\n        /** Unregisters all created message elements and removes the message container. */\n        ngOnDestroy() {\n            const describedElements = this._document.querySelectorAll(`[${CDK_DESCRIBEDBY_HOST_ATTRIBUTE}]`);\n            for (let i = 0; i < describedElements.length; i++) {\n                this._removeCdkDescribedByReferenceIds(describedElements[i]);\n                describedElements[i].removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n            }\n            if (messagesContainer) {\n                this._deleteMessagesContainer();\n            }\n            messageRegistry.clear();\n        }\n        /**\n         * Creates a new element in the visually hidden message container element with the message\n         * as its content and adds it to the message registry.\n         */\n        _createMessageElement(message, role) {\n            const messageElement = this._document.createElement('div');\n            setMessageId(messageElement);\n            messageElement.textContent = message;\n            if (role) {\n                messageElement.setAttribute('role', role);\n            }\n            this._createMessagesContainer();\n            messagesContainer.appendChild(messageElement);\n            messageRegistry.set(getKey(message, role), { messageElement, referenceCount: 0 });\n        }\n        /** Deletes the message element from the global messages container. */\n        _deleteMessageElement(key) {\n            const registeredMessage = messageRegistry.get(key);\n            const messageElement = registeredMessage && registeredMessage.messageElement;\n            if (messagesContainer && messageElement) {\n                messagesContainer.removeChild(messageElement);\n            }\n            messageRegistry.delete(key);\n        }\n        /** Creates the global container for all aria-describedby messages. */\n        _createMessagesContainer() {\n            if (!messagesContainer) {\n                const preExistingContainer = this._document.getElementById(MESSAGES_CONTAINER_ID);\n                // When going from the server to the client, we may end up in a situation where there's\n                // already a container on the page, but we don't have a reference to it. Clear the\n                // old container so we don't get duplicates. Doing this, instead of emptying the previous\n                // container, should be slightly faster.\n                if (preExistingContainer && preExistingContainer.parentNode) {\n                    preExistingContainer.parentNode.removeChild(preExistingContainer);\n                }\n                messagesContainer = this._document.createElement('div');\n                messagesContainer.id = MESSAGES_CONTAINER_ID;\n                // We add `visibility: hidden` in order to prevent text in this container from\n                // being searchable by the browser's Ctrl + F functionality.\n                // Screen-readers will still read the description for elements with aria-describedby even\n                // when the description element is not visible.\n                messagesContainer.style.visibility = 'hidden';\n                // Even though we use `visibility: hidden`, we still apply `cdk-visually-hidden` so that\n                // the description element doesn't impact page layout.\n                messagesContainer.classList.add('cdk-visually-hidden');\n                this._document.body.appendChild(messagesContainer);\n            }\n        }\n        /** Deletes the global messages container. */\n        _deleteMessagesContainer() {\n            if (messagesContainer && messagesContainer.parentNode) {\n                messagesContainer.parentNode.removeChild(messagesContainer);\n                messagesContainer = null;\n            }\n        }\n        /** Removes all cdk-describedby messages that are hosted through the element. */\n        _removeCdkDescribedByReferenceIds(element) {\n            // Remove all aria-describedby reference IDs that are prefixed by CDK_DESCRIBEDBY_ID_PREFIX\n            const originalReferenceIds = getAriaReferenceIds(element, 'aria-describedby')\n                .filter(id => id.indexOf(CDK_DESCRIBEDBY_ID_PREFIX) != 0);\n            element.setAttribute('aria-describedby', originalReferenceIds.join(' '));\n        }\n        /**\n         * Adds a message reference to the element using aria-describedby and increments the registered\n         * message's reference count.\n         */\n        _addMessageReference(element, key) {\n            const registeredMessage = messageRegistry.get(key);\n            // Add the aria-describedby reference and set the\n            // describedby_host attribute to mark the element.\n            addAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.setAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE, '');\n            registeredMessage.referenceCount++;\n        }\n        /**\n         * Removes a message reference from the element using aria-describedby\n         * and decrements the registered message's reference count.\n         */\n        _removeMessageReference(element, key) {\n            const registeredMessage = messageRegistry.get(key);\n            registeredMessage.referenceCount--;\n            removeAriaReferencedId(element, 'aria-describedby', registeredMessage.messageElement.id);\n            element.removeAttribute(CDK_DESCRIBEDBY_HOST_ATTRIBUTE);\n        }\n        /** Returns true if the element has been described by the provided message ID. */\n        _isElementDescribedByMessage(element, key) {\n            const referenceIds = getAriaReferenceIds(element, 'aria-describedby');\n            const registeredMessage = messageRegistry.get(key);\n            const messageId = registeredMessage && registeredMessage.messageElement.id;\n            return !!messageId && referenceIds.indexOf(messageId) != -1;\n        }\n        /** Determines whether a message can be described on a particular element. */\n        _canBeDescribed(element, message) {\n            if (!this._isElementNode(element)) {\n                return false;\n            }\n            if (message && typeof message === 'object') {\n                // We'd have to make some assumptions about the description element's text, if the consumer\n                // passed in an element. Assume that if an element is passed in, the consumer has verified\n                // that it can be used as a description.\n                return true;\n            }\n            const trimmedMessage = message == null ? '' : `${message}`.trim();\n            const ariaLabel = element.getAttribute('aria-label');\n            // We shouldn't set descriptions if they're exactly the same as the `aria-label` of the\n            // element, because screen readers will end up reading out the same text twice in a row.\n            return trimmedMessage ? (!ariaLabel || ariaLabel.trim() !== trimmedMessage) : false;\n        }\n        /** Checks whether a node is an Element node. */\n        _isElementNode(element) {\n            return element.nodeType === this._document.ELEMENT_NODE;\n        }\n    }\n    AriaDescriber.fac = function AriaDescriber_Factory(t) { return new (t || AriaDescriber)(core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */])); };\n    AriaDescriber.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function AriaDescriber_Factory() { return new AriaDescriber(Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */])); }, token: AriaDescriber, providedIn: \"root\" });\n    return AriaDescriber;\n})();\n/** Gets a key that can be used to look messages up in the registry. */\nfunction getKey(message, role) {\n    return typeof message === 'string' ? `${role || ''}/${message}` : message;\n}\n/** Assigns a unique ID to an element, if it doesn't have one already. */\nfunction setMessageId(element) {\n    if (!element.id) {\n        element.id = `${CDK_DESCRIBEDBY_ID_PREFIX}-${nextId++}`;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * This class manages keyboard events for selectable lists. If you pass it a query list\n * of items, it will set the active item correctly when arrow events occur.\n */\nclass a11y_ListKeyManager {\n    constructor(_items) {\n        this._items = _items;\n        this._activeItemIndex = -1;\n        this._activeItem = null;\n        this._wrap = false;\n        this._letterKeyStream = new Subject[\"a\" /* Subject */]();\n        this._typeaheadSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        this._vertical = true;\n        this._allowedModifierKeys = [];\n        this._homeAndEnd = false;\n        /**\n         * Predicate function that can be used to check whether an item should be skipped\n         * by the key manager. By default, disabled items are skipped.\n         */\n        this._skipPredicateFn = (item) => item.disabled;\n        // Buffer for the letters that the user has pressed when the typeahead option is turned on.\n        this._pressedLetters = [];\n        /**\n         * Stream that emits any time the TAB key is pressed, so components can react\n         * when focus is shifted off of the list.\n         */\n        this.tabOut = new Subject[\"a\" /* Subject */]();\n        /** Stream that emits whenever the active item of the list manager changes. */\n        this.change = new Subject[\"a\" /* Subject */]();\n        // We allow for the items to be an array because, in some cases, the consumer may\n        // not have access to a QueryList of the items they want to manage (e.g. when the\n        // items aren't being collected via `ViewChildren` or `ContentChildren`).\n        if (_items instanceof core[\"E\" /* QueryList */]) {\n            _items.changes.subscribe((newItems) => {\n                if (this._activeItem) {\n                    const itemArray = newItems.toArray();\n                    const newIndex = itemArray.indexOf(this._activeItem);\n                    if (newIndex > -1 && newIndex !== this._activeItemIndex) {\n                        this._activeItemIndex = newIndex;\n                    }\n                }\n            });\n        }\n    }\n    /**\n     * Sets the predicate function that determines which items should be skipped by the\n     * list key manager.\n     * @param predicate Function that determines whether the given item should be skipped.\n     */\n    skipPredicate(predicate) {\n        this._skipPredicateFn = predicate;\n        return this;\n    }\n    /**\n     * Configures wrapping mode, which determines whether the active item will wrap to\n     * the other end of list when there are no more items in the given direction.\n     * @param shouldWrap Whether the list should wrap when reaching the end.\n     */\n    withWrap(shouldWrap = true) {\n        this._wrap = shouldWrap;\n        return this;\n    }\n    /**\n     * Configures whether the key manager should be able to move the selection vertically.\n     * @param enabled Whether vertical selection should be enabled.\n     */\n    withVerticalOrientation(enabled = true) {\n        this._vertical = enabled;\n        return this;\n    }\n    /**\n     * Configures the key manager to move the selection horizontally.\n     * Passing in `null` will disable horizontal movement.\n     * @param direction Direction in which the selection can be moved.\n     */\n    withHorizontalOrientation(direction) {\n        this._horizontal = direction;\n        return this;\n    }\n    /**\n     * Modifier keys which are allowed to be held down and whose default actions will be prevented\n     * as the user is pressing the arrow keys. Defaults to not allowing any modifier keys.\n     */\n    withAllowedModifierKeys(keys) {\n        this._allowedModifierKeys = keys;\n        return this;\n    }\n    /**\n     * Turns on typeahead mode which allows users to set the active item by typing.\n     * @param debounceInterval Time to wait after the last keystroke before setting the active item.\n     */\n    withTypeAhead(debounceInterval = 200) {\n        if ((typeof ngDevMode === 'undefined' || ngDevMode) && (this._items.length &&\n            this._items.some(item => typeof item.getLabel !== 'function'))) {\n            throw Error('ListKeyManager items in typeahead mode must implement the `getLabel` method.');\n        }\n        this._typeaheadSubscription.unsubscribe();\n        // Debounce the presses of non-navigational keys, collect the ones that correspond to letters\n        // and convert those letters back into a string. Afterwards find the first item that starts\n        // with that string and select it.\n        this._typeaheadSubscription = this._letterKeyStream.pipe(Object(tap[\"a\" /* tap */])(letter => this._pressedLetters.push(letter)), debounceTime(debounceInterval), Object(filter[\"a\" /* filter */])(() => this._pressedLetters.length > 0), Object(map[\"a\" /* map */])(() => this._pressedLetters.join(''))).subscribe(inputString => {\n            const items = this._getItemsArray();\n            // Start at 1 because we want to start searching at the item immediately\n            // following the current active item.\n            for (let i = 1; i < items.length + 1; i++) {\n                const index = (this._activeItemIndex + i) % items.length;\n                const item = items[index];\n                if (!this._skipPredicateFn(item) &&\n                    item.getLabel().toUpperCase().trim().indexOf(inputString) === 0) {\n                    this.setActiveItem(index);\n                    break;\n                }\n            }\n            this._pressedLetters = [];\n        });\n        return this;\n    }\n    /**\n     * Configures the key manager to activate the first and last items\n     * respectively when the Home or End key is pressed.\n     * @param enabled Whether pressing the Home or End key activates the first/last item.\n     */\n    withHomeAndEnd(enabled = true) {\n        this._homeAndEnd = enabled;\n        return this;\n    }\n    setActiveItem(item) {\n        const previousActiveItem = this._activeItem;\n        this.updateActiveItem(item);\n        if (this._activeItem !== previousActiveItem) {\n            this.change.next(this._activeItemIndex);\n        }\n    }\n    /**\n     * Sets the active item depending on the key event passed in.\n     * @param event Keyboard event to be used for determining which element should be active.\n     */\n    onKeydown(event) {\n        const keyCode = event.keyCode;\n        const modifiers = ['altKey', 'ctrlKey', 'metaKey', 'shiftKey'];\n        const isModifierAllowed = modifiers.every(modifier => {\n            return !event[modifier] || this._allowedModifierKeys.indexOf(modifier) > -1;\n        });\n        switch (keyCode) {\n            case TAB:\n                this.tabOut.next();\n                return;\n            case DOWN_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case UP_ARROW:\n                if (this._vertical && isModifierAllowed) {\n                    this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case RIGHT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setPreviousItemActive() : this.setNextItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case LEFT_ARROW:\n                if (this._horizontal && isModifierAllowed) {\n                    this._horizontal === 'rtl' ? this.setNextItemActive() : this.setPreviousItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case HOME:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setFirstItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            case END:\n                if (this._homeAndEnd && isModifierAllowed) {\n                    this.setLastItemActive();\n                    break;\n                }\n                else {\n                    return;\n                }\n            default:\n                if (isModifierAllowed || hasModifierKey(event, 'shiftKey')) {\n                    // Attempt to use the `event.key` which also maps it to the user's keyboard language,\n                    // otherwise fall back to resolving alphanumeric characters via the keyCode.\n                    if (event.key && event.key.length === 1) {\n                        this._letterKeyStream.next(event.key.toLocaleUpperCase());\n                    }\n                    else if ((keyCode >= A && keyCode <= Z) || (keyCode >= ZERO && keyCode <= NINE)) {\n                        this._letterKeyStream.next(String.fromCharCode(keyCode));\n                    }\n                }\n                // Note that we return here, in order to avoid preventing\n                // the default action of non-navigational keys.\n                return;\n        }\n        this._pressedLetters = [];\n        event.preventDefault();\n    }\n    /** Index of the currently active item. */\n    get activeItemIndex() {\n        return this._activeItemIndex;\n    }\n    /** The active item. */\n    get activeItem() {\n        return this._activeItem;\n    }\n    /** Gets whether the user is currently typing into the manager using the typeahead feature. */\n    isTyping() {\n        return this._pressedLetters.length > 0;\n    }\n    /** Sets the active item to the first enabled item in the list. */\n    setFirstItemActive() {\n        this._setActiveItemByIndex(0, 1);\n    }\n    /** Sets the active item to the last enabled item in the list. */\n    setLastItemActive() {\n        this._setActiveItemByIndex(this._items.length - 1, -1);\n    }\n    /** Sets the active item to the next enabled item in the list. */\n    setNextItemActive() {\n        this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1);\n    }\n    /** Sets the active item to a previous enabled item in the list. */\n    setPreviousItemActive() {\n        this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive()\n            : this._setActiveItemByDelta(-1);\n    }\n    updateActiveItem(item) {\n        const itemArray = this._getItemsArray();\n        const index = typeof item === 'number' ? item : itemArray.indexOf(item);\n        const activeItem = itemArray[index];\n        // Explicitly check for `null` and `undefined` because other falsy values are valid.\n        this._activeItem = activeItem == null ? null : activeItem;\n        this._activeItemIndex = index;\n    }\n    /**\n     * This method sets the active item, given a list of items and the delta between the\n     * currently active item and the new active item. It will calculate differently\n     * depending on whether wrap mode is turned on.\n     */\n    _setActiveItemByDelta(delta) {\n        this._wrap ? this._setActiveInWrapMode(delta) : this._setActiveInDefaultMode(delta);\n    }\n    /**\n     * Sets the active item properly given \"wrap\" mode. In other words, it will continue to move\n     * down the list until it finds an item that is not disabled, and it will wrap if it\n     * encounters either end of the list.\n     */\n    _setActiveInWrapMode(delta) {\n        const items = this._getItemsArray();\n        for (let i = 1; i <= items.length; i++) {\n            const index = (this._activeItemIndex + (delta * i) + items.length) % items.length;\n            const item = items[index];\n            if (!this._skipPredicateFn(item)) {\n                this.setActiveItem(index);\n                return;\n            }\n        }\n    }\n    /**\n     * Sets the active item properly given the default mode. In other words, it will\n     * continue to move down the list until it finds an item that is not disabled. If\n     * it encounters either end of the list, it will stop and not wrap.\n     */\n    _setActiveInDefaultMode(delta) {\n        this._setActiveItemByIndex(this._activeItemIndex + delta, delta);\n    }\n    /**\n     * Sets the active item to the first enabled item starting at the index specified. If the\n     * item is disabled, it will move in the fallbackDelta direction until it either\n     * finds an enabled item or encounters the end of the list.\n     */\n    _setActiveItemByIndex(index, fallbackDelta) {\n        const items = this._getItemsArray();\n        if (!items[index]) {\n            return;\n        }\n        while (this._skipPredicateFn(items[index])) {\n            index += fallbackDelta;\n            if (!items[index]) {\n                return;\n            }\n        }\n        this.setActiveItem(index);\n    }\n    /** Returns the items as an array. */\n    _getItemsArray() {\n        return this._items instanceof core[\"E\" /* QueryList */] ? this._items.toArray() : this._items;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass ActiveDescendantKeyManager extends a11y_ListKeyManager {\n    setActiveItem(index) {\n        if (this.activeItem) {\n            this.activeItem.setInactiveStyles();\n        }\n        super.setActiveItem(index);\n        if (this.activeItem) {\n            this.activeItem.setActiveStyles();\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nclass FocusKeyManager extends a11y_ListKeyManager {\n    constructor() {\n        super(...arguments);\n        this._origin = 'program';\n    }\n    /**\n     * Sets the focus origin that will be passed in to the items for any subsequent `focus` calls.\n     * @param origin Focus origin to be used when focusing items.\n     */\n    setFocusOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    setActiveItem(item) {\n        super.setActiveItem(item);\n        if (this.activeItem) {\n            this.activeItem.focus(this._origin);\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Configuration for the isFocusable method.\n */\nclass IsFocusableConfig {\n    constructor() {\n        /**\n         * Whether to count an element as focusable even if it is not currently visible.\n         */\n        this.ignoreVisibility = false;\n    }\n}\nlet a11y_InteractivityChecker = /*@__PURE__*/ (() => {\n    class InteractivityChecker {\n        constructor(_platform) {\n            this._platform = _platform;\n        }\n        /**\n         * Gets whether an element is disabled.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is disabled.\n         */\n        isDisabled(element) {\n            // This does not capture some cases, such as a non-form control with a disabled attribute or\n            // a form control inside of a disabled form, but should capture the most common cases.\n            return element.hasAttribute('disabled');\n        }\n        /**\n         * Gets whether an element is visible for the purposes of interactivity.\n         *\n         * This will capture states like `display: none` and `visibility: hidden`, but not things like\n         * being clipped by an `overflow: hidden` parent or being outside the viewport.\n         *\n         * @returns Whether the element is visible.\n         */\n        isVisible(element) {\n            return hasGeometry(element) && getComputedStyle(element).visibility === 'visible';\n        }\n        /**\n         * Gets whether an element can be reached via Tab key.\n         * Assumes that the element has already been checked with isFocusable.\n         *\n         * @param element Element to be checked.\n         * @returns Whether the element is tabbable.\n         */\n        isTabbable(element) {\n            // Nothing is tabbable on the server \n            if (!this._platform.isBrowser) {\n                return false;\n            }\n            const frameElement = getFrameElement(getWindow(element));\n            if (frameElement) {\n                // Frame elements inherit their tabindex onto all child elements.\n                if (getTabIndexValue(frameElement) === -1) {\n                    return false;\n                }\n                // Browsers disable tabbing to an element inside of an invisible frame.\n                if (!this.isVisible(frameElement)) {\n                    return false;\n                }\n            }\n            let nodeName = element.nodeName.toLowerCase();\n            let tabIndexValue = getTabIndexValue(element);\n            if (element.hasAttribute('contenteditable')) {\n                return tabIndexValue !== -1;\n            }\n            if (nodeName === 'iframe' || nodeName === 'object') {\n                // The frame or object's content may be tabbable depending on the content, but it's\n                // not possibly to reliably detect the content of the frames. We always consider such\n                // elements as non-tabbable.\n                return false;\n            }\n            // In iOS, the browser only considers some specific elements as tabbable.\n            if (this._platform.WEBKIT && this._platform.IOS && !isPotentiallyTabbableIOS(element)) {\n                return false;\n            }\n            if (nodeName === 'audio') {\n                // Audio elements without controls enabled are never tabbable, regardless\n                // of the tabindex attribute explicitly being set.\n                if (!element.hasAttribute('controls')) {\n                    return false;\n                }\n                // Audio elements with controls are by default tabbable unless the\n                // tabindex attribute is set to `-1` explicitly.\n                return tabIndexValue !== -1;\n            }\n            if (nodeName === 'video') {\n                // For all video elements, if the tabindex attribute is set to `-1`, the video\n                // is not tabbable. Note: We cannot rely on the default `HTMLElement.tabIndex`\n                // property as that one is set to `-1` in Chrome, Edge and Safari v13.1. The\n                // tabindex attribute is the source of truth here.\n                if (tabIndexValue === -1) {\n                    return false;\n                }\n                // If the tabindex is explicitly set, and not `-1` (as per check before), the\n                // video element is always tabbable (regardless of whether it has controls or not).\n                if (tabIndexValue !== null) {\n                    return true;\n                }\n                // Otherwise (when no explicit tabindex is set), a video is only tabbable if it\n                // has controls enabled. Firefox is special as videos are always tabbable regardless\n                // of whether there are controls or not.\n                return this._platform.FIREFOX || element.hasAttribute('controls');\n            }\n            return element.tabIndex >= 0;\n        }\n        /**\n         * Gets whether an element can be focused by the user.\n         *\n         * @param element Element to be checked.\n         * @param config The config object with options to customize this method's behavior\n         * @returns Whether the element is focusable.\n         */\n        isFocusable(element, config) {\n            // Perform checks in order of left to most expensive.\n            // Again, naive approach that does not capture many edge cases and browser quirks.\n            return isPotentiallyFocusable(element) && !this.isDisabled(element) &&\n                ((config === null || config === void 0 ? void 0 : config.ignoreVisibility) || this.isVisible(element));\n        }\n    }\n    InteractivityChecker.fac = function InteractivityChecker_Factory(t) { return new (t || InteractivityChecker)(core[\"Wb\" /* inject */](platform_Platform)); };\n    InteractivityChecker.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function InteractivityChecker_Factory() { return new InteractivityChecker(Object(core[\"Wb\" /* inject */])(platform_Platform)); }, token: InteractivityChecker, providedIn: \"root\" });\n    return InteractivityChecker;\n})();\n/**\n * Returns the frame element from a window object. Since browsers like MS Edge throw errors if\n * the frameElement property is being accessed from a different host address, this property\n * should be accessed carefully.\n */\nfunction getFrameElement(window) {\n    try {\n        return window.frameElement;\n    }\n    catch (_a) {\n        return null;\n    }\n}\n/** Checks whether the specified element has any geometry / rectangles. */\nfunction hasGeometry(element) {\n    // Use logic from jQuery to check for an invisible element.\n    // See https://github.com/jquery/jquery/blob/master/src/css/hiddenVisibleSelectors.js#L12\n    return !!(element.offsetWidth || element.offsetHeight ||\n        (typeof element.getClientRects === 'function' && element.getClientRects().length));\n}\n/** Gets whether an element's  */\nfunction isNativeFormElement(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    return nodeName === 'input' ||\n        nodeName === 'select' ||\n        nodeName === 'button' ||\n        nodeName === 'textarea';\n}\n/** Gets whether an element is an `<input type=\"hidden\">`. */\nfunction isHiddenInput(element) {\n    return isInputElement(element) && element.type == 'hidden';\n}\n/** Gets whether an element is an anchor that has an href attribute. */\nfunction isAnchorWithHref(element) {\n    return isAnchorElement(element) && element.hasAttribute('href');\n}\n/** Gets whether an element is an input element. */\nfunction isInputElement(element) {\n    return element.nodeName.toLowerCase() == 'input';\n}\n/** Gets whether an element is an anchor element. */\nfunction isAnchorElement(element) {\n    return element.nodeName.toLowerCase() == 'a';\n}\n/** Gets whether an element has a valid tabindex. */\nfunction hasValidTabIndex(element) {\n    if (!element.hasAttribute('tabindex') || element.tabIndex === undefined) {\n        return false;\n    }\n    let tabIndex = element.getAttribute('tabindex');\n    // IE11 parses tabindex=\"\" as the value \"-32768\"\n    if (tabIndex == '-32768') {\n        return false;\n    }\n    return !!(tabIndex && !isNaN(parseInt(tabIndex, 10)));\n}\n/**\n * Returns the parsed tabindex from the element attributes instead of returning the\n * evaluated tabindex from the browsers defaults.\n */\nfunction getTabIndexValue(element) {\n    if (!hasValidTabIndex(element)) {\n        return null;\n    }\n    // See browser issue in Gecko https://bugzilla.mozilla.org/show_bug.cgi?id=1128054\n    const tabIndex = parseInt(element.getAttribute('tabindex') || '', 10);\n    return isNaN(tabIndex) ? -1 : tabIndex;\n}\n/** Checks whether the specified element is potentially tabbable on iOS */\nfunction isPotentiallyTabbableIOS(element) {\n    let nodeName = element.nodeName.toLowerCase();\n    let inputType = nodeName === 'input' && element.type;\n    return inputType === 'text'\n        || inputType === 'password'\n        || nodeName === 'select'\n        || nodeName === 'textarea';\n}\n/**\n * Gets whether an element is potentially focusable without taking current visible/disabled state\n * into account.\n */\nfunction isPotentiallyFocusable(element) {\n    // Inputs are potentially focusable *unless* they're type=\"hidden\".\n    if (isHiddenInput(element)) {\n        return false;\n    }\n    return isNativeFormElement(element) ||\n        isAnchorWithHref(element) ||\n        element.hasAttribute('contenteditable') ||\n        hasValidTabIndex(element);\n}\n/** Gets the parent window of a DOM node with regards of being inside of an iframe. */\nfunction getWindow(node) {\n    // ownerDocument is null if `node` itself *is* a document.\n    return node.ownerDocument && node.ownerDocument.defaultView || window;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class currently uses a relatively simple approach to focus trapping.\n * It assumes that the tab order is the same as DOM order, which is not necessarily true.\n * Things like `tabIndex > 0`, flex `order`, and shadow roots can cause the two to be misaligned.\n *\n * @deprecated Use `ConfigurableFocusTrap` instead.\n * @breaking-change 11.0.0\n */\nclass a11y_FocusTrap {\n    constructor(_element, _checker, _ngZone, _document, deferAnchors = false) {\n        this._element = _element;\n        this._checker = _checker;\n        this._ngZone = _ngZone;\n        this._document = _document;\n        this._hasAttached = false;\n        // Event listeners for the anchors. Need to be regular functions so that we can unbind them later.\n        this.startAnchorListener = () => this.focusLastTabbableElement();\n        this.endAnchorListener = () => this.focusFirstTabbableElement();\n        this._enabled = true;\n        if (!deferAnchors) {\n            this.attachAnchors();\n        }\n    }\n    /** Whether the focus trap is active. */\n    get enabled() { return this._enabled; }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(value, this._startAnchor);\n            this._toggleAnchorTabIndex(value, this._endAnchor);\n        }\n    }\n    /** Destroys the focus trap by cleaning up the anchors. */\n    destroy() {\n        const startAnchor = this._startAnchor;\n        const endAnchor = this._endAnchor;\n        if (startAnchor) {\n            startAnchor.removeEventListener('focus', this.startAnchorListener);\n            if (startAnchor.parentNode) {\n                startAnchor.parentNode.removeChild(startAnchor);\n            }\n        }\n        if (endAnchor) {\n            endAnchor.removeEventListener('focus', this.endAnchorListener);\n            if (endAnchor.parentNode) {\n                endAnchor.parentNode.removeChild(endAnchor);\n            }\n        }\n        this._startAnchor = this._endAnchor = null;\n        this._hasAttached = false;\n    }\n    /**\n     * Inserts the anchors into the DOM. This is usually done automatically\n     * in the constructor, but can be deferred for cases like directives with `*ngIf`.\n     * @returns Whether the focus trap managed to attach successfully. This may not be the case\n     * if the target element isn't currently in the DOM.\n     */\n    attachAnchors() {\n        // If we're not on the browser, there can be no focus to trap.\n        if (this._hasAttached) {\n            return true;\n        }\n        this._ngZone.runOutsideAngular(() => {\n            if (!this._startAnchor) {\n                this._startAnchor = this._createAnchor();\n                this._startAnchor.addEventListener('focus', this.startAnchorListener);\n            }\n            if (!this._endAnchor) {\n                this._endAnchor = this._createAnchor();\n                this._endAnchor.addEventListener('focus', this.endAnchorListener);\n            }\n        });\n        if (this._element.parentNode) {\n            this._element.parentNode.insertBefore(this._startAnchor, this._element);\n            this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling);\n            this._hasAttached = true;\n        }\n        return this._hasAttached;\n    }\n    /**\n     * Waits for the zone to stabilize, then either focuses the first element that the\n     * user specified, or the first tabbable element.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusInitialElementWhenReady() {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusInitialElement()));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the first tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusFirstTabbableElementWhenReady() {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusFirstTabbableElement()));\n        });\n    }\n    /**\n     * Waits for the zone to stabilize, then focuses\n     * the last tabbable element within the focus trap region.\n     * @returns Returns a promise that resolves with a boolean, depending\n     * on whether focus was moved successfully.\n     */\n    focusLastTabbableElementWhenReady() {\n        return new Promise(resolve => {\n            this._executeOnStable(() => resolve(this.focusLastTabbableElement()));\n        });\n    }\n    /**\n     * Get the specified boundary element of the trapped region.\n     * @param bound The boundary to get (start or end of trapped region).\n     * @returns The boundary element.\n     */\n    _getRegionBoundary(bound) {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        let markers = this._element.querySelectorAll(`[cdk-focus-region-${bound}], ` +\n            `[cdkFocusRegion${bound}], ` +\n            `[cdk-focus-${bound}]`);\n        for (let i = 0; i < markers.length; i++) {\n            // @breaking-change 8.0.0\n            if (markers[i].hasAttribute(`cdk-focus-${bound}`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-${bound}', ` +\n                    `use 'cdkFocusRegion${bound}' instead. The deprecated ` +\n                    `attribute will be removed in 8.0.0.`, markers[i]);\n            }\n            else if (markers[i].hasAttribute(`cdk-focus-region-${bound}`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-region-${bound}', ` +\n                    `use 'cdkFocusRegion${bound}' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0.`, markers[i]);\n            }\n        }\n        if (bound == 'start') {\n            return markers.length ? markers[0] : this._getFirstTabbableElement(this._element);\n        }\n        return markers.length ?\n            markers[markers.length - 1] : this._getLastTabbableElement(this._element);\n    }\n    /**\n     * Focuses the element that should be focused when the focus trap is initialized.\n     * @returns Whether focus was moved successfully.\n     */\n    focusInitialElement() {\n        // Contains the deprecated version of selector, for temporary backwards comparability.\n        const redirectToElement = this._element.querySelector(`[cdk-focus-initial], ` +\n            `[cdkFocusInitial]`);\n        if (redirectToElement) {\n            // @breaking-change 8.0.0\n            if (redirectToElement.hasAttribute(`cdk-focus-initial`)) {\n                console.warn(`Found use of deprecated attribute 'cdk-focus-initial', ` +\n                    `use 'cdkFocusInitial' instead. The deprecated attribute ` +\n                    `will be removed in 8.0.0`, redirectToElement);\n            }\n            // Warn the consumer if the element they've pointed to\n            // isn't focusable, when not in production mode.\n            if ((typeof ngDevMode === 'undefined' || ngDevMode) &&\n                !this._checker.isFocusable(redirectToElement)) {\n                console.warn(`Element matching '[cdkFocusInitial]' is not focusable.`, redirectToElement);\n            }\n            if (!this._checker.isFocusable(redirectToElement)) {\n                const focusableChild = this._getFirstTabbableElement(redirectToElement);\n                focusableChild === null || focusableChild === void 0 ? void 0 : focusableChild.focus();\n                return !!focusableChild;\n            }\n            redirectToElement.focus();\n            return true;\n        }\n        return this.focusFirstTabbableElement();\n    }\n    /**\n     * Focuses the first tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusFirstTabbableElement() {\n        const redirectToElement = this._getRegionBoundary('start');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Focuses the last tabbable element within the focus trap region.\n     * @returns Whether focus was moved successfully.\n     */\n    focusLastTabbableElement() {\n        const redirectToElement = this._getRegionBoundary('end');\n        if (redirectToElement) {\n            redirectToElement.focus();\n        }\n        return !!redirectToElement;\n    }\n    /**\n     * Checks whether the focus trap has successfully been attached.\n     */\n    hasAttached() {\n        return this._hasAttached;\n    }\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\n    _getFirstTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in DOM order. Note that IE doesn't have `children` for SVG so we fall\n        // back to `childNodes` which includes text nodes, comments etc.\n        let children = root.children || root.childNodes;\n        for (let i = 0; i < children.length; i++) {\n            let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getFirstTabbableElement(children[i]) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Get the last tabbable element from a DOM subtree (inclusive). */\n    _getLastTabbableElement(root) {\n        if (this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n            return root;\n        }\n        // Iterate in reverse DOM order.\n        let children = root.children || root.childNodes;\n        for (let i = children.length - 1; i >= 0; i--) {\n            let tabbableChild = children[i].nodeType === this._document.ELEMENT_NODE ?\n                this._getLastTabbableElement(children[i]) :\n                null;\n            if (tabbableChild) {\n                return tabbableChild;\n            }\n        }\n        return null;\n    }\n    /** Creates an anchor element. */\n    _createAnchor() {\n        const anchor = this._document.createElement('div');\n        this._toggleAnchorTabIndex(this._enabled, anchor);\n        anchor.classList.add('cdk-visually-hidden');\n        anchor.classList.add('cdk-focus-trap-anchor');\n        anchor.setAttribute('aria-hidden', 'true');\n        return anchor;\n    }\n    /**\n     * Toggles the `tabindex` of an anchor, based on the enabled state of the focus trap.\n     * @param isEnabled Whether the focus trap is enabled.\n     * @param anchor Anchor on which to toggle the tabindex.\n     */\n    _toggleAnchorTabIndex(isEnabled, anchor) {\n        // Remove the tabindex completely, rather than setting it to -1, because if the\n        // element has a tabindex, the user might still hit it when navigating with the arrow keys.\n        isEnabled ? anchor.setAttribute('tabindex', '0') : anchor.removeAttribute('tabindex');\n    }\n    /**\n     * Toggles the`tabindex` of both anchors to either trap Tab focus or allow it to escape.\n     * @param enabled: Whether the anchors should trap Tab.\n     */\n    toggleAnchors(enabled) {\n        if (this._startAnchor && this._endAnchor) {\n            this._toggleAnchorTabIndex(enabled, this._startAnchor);\n            this._toggleAnchorTabIndex(enabled, this._endAnchor);\n        }\n    }\n    /** Executes a function when the zone is stable. */\n    _executeOnStable(fn) {\n        if (this._ngZone.isStable) {\n            fn();\n        }\n        else {\n            this._ngZone.onStable.pipe(Object(take[\"a\" /* take */])(1)).subscribe(fn);\n        }\n    }\n}\nlet a11y_FocusTrapFactory = /*@__PURE__*/ (() => {\n    class FocusTrapFactory {\n        constructor(_checker, _ngZone, _document) {\n            this._checker = _checker;\n            this._ngZone = _ngZone;\n            this._document = _document;\n        }\n        /**\n         * Creates a focus-trapped region around the given element.\n         * @param element The element around which focus will be trapped.\n         * @param deferCaptureElements Defers the creation of focus-capturing elements to be done\n         *     manually by the user.\n         * @returns The created focus trap instance.\n         */\n        create(element, deferCaptureElements = false) {\n            return new a11y_FocusTrap(element, this._checker, this._ngZone, this._document, deferCaptureElements);\n        }\n    }\n    FocusTrapFactory.fac = function FocusTrapFactory_Factory(t) { return new (t || FocusTrapFactory)(core[\"Wb\" /* inject */](a11y_InteractivityChecker), core[\"Wb\" /* inject */](core[\"A\" /* NgZone */]), core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */])); };\n    FocusTrapFactory.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function FocusTrapFactory_Factory() { return new FocusTrapFactory(Object(core[\"Wb\" /* inject */])(a11y_InteractivityChecker), Object(core[\"Wb\" /* inject */])(core[\"A\" /* NgZone */]), Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */])); }, token: FocusTrapFactory, providedIn: \"root\" });\n    return FocusTrapFactory;\n})();\nlet a11y_CdkTrapFocus = /*@__PURE__*/ (() => {\n    class CdkTrapFocus {\n        constructor(_elementRef, _focusTrapFactory, _document) {\n            this._elementRef = _elementRef;\n            this._focusTrapFactory = _focusTrapFactory;\n            /** Previously focused element to restore focus to upon destroy when using autoCapture. */\n            this._previouslyFocusedElement = null;\n            this._document = _document;\n            this.focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement, true);\n        }\n        /** Whether the focus trap is active. */\n        get enabled() { return this.focusTrap.enabled; }\n        set enabled(value) { this.focusTrap.enabled = coerceBooleanProperty(value); }\n        /**\n         * Whether the directive should automatically move focus into the trapped region upon\n         * initialization and return focus to the previous activeElement upon destruction.\n         */\n        get autoCapture() { return this._autoCapture; }\n        set autoCapture(value) { this._autoCapture = coerceBooleanProperty(value); }\n        ngOnDestroy() {\n            this.focusTrap.destroy();\n            // If we stored a previously focused element when using autoCapture, return focus to that\n            // element now that the trapped region is being destroyed.\n            if (this._previouslyFocusedElement) {\n                this._previouslyFocusedElement.focus();\n                this._previouslyFocusedElement = null;\n            }\n        }\n        ngAfterContentInit() {\n            this.focusTrap.attachAnchors();\n            if (this.autoCapture) {\n                this._captureFocus();\n            }\n        }\n        ngDoCheck() {\n            if (!this.focusTrap.hasAttached()) {\n                this.focusTrap.attachAnchors();\n            }\n        }\n        ngOnChanges(changes) {\n            const autoCaptureChange = changes['autoCapture'];\n            if (autoCaptureChange && !autoCaptureChange.firstChange && this.autoCapture &&\n                this.focusTrap.hasAttached()) {\n                this._captureFocus();\n            }\n        }\n        _captureFocus() {\n            var _a, _b;\n            // If the `activeElement` is inside a shadow root, `document.activeElement` will\n            // point to the shadow root so we have to descend into it ourselves.\n            const activeElement = (_a = this._document) === null || _a === void 0 ? void 0 : _a.activeElement;\n            this._previouslyFocusedElement =\n                ((_b = activeElement === null || activeElement === void 0 ? void 0 : activeElement.shadowRoot) === null || _b === void 0 ? void 0 : _b.activeElement) || activeElement;\n            this.focusTrap.focusInitialElementWhenReady();\n        }\n    }\n    CdkTrapFocus.fac = function CdkTrapFocus_Factory(t) { return new (t || CdkTrapFocus)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](a11y_FocusTrapFactory), core[\"Mb\" /* directiveInject */](common[\"c\" /* DOCUMENT */])); };\n    CdkTrapFocus.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: CdkTrapFocus, selectors: [[\"\", \"cdkTrapFocus\", \"\"]], inputs: { enabled: [\"cdkTrapFocus\", \"enabled\"], autoCapture: [\"cdkTrapFocusAutoCapture\", \"autoCapture\"] }, exportAs: [\"cdkTrapFocus\"], features: [core[\"yb\" /* NgOnChangesFeature */]] });\n    return CdkTrapFocus;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class that allows for trapping focus within a DOM element.\n *\n * This class uses a strategy pattern that determines how it traps focus.\n * See FocusTrapInertStrategy.\n */\nclass ConfigurableFocusTrap extends a11y_FocusTrap {\n    constructor(_element, _checker, _ngZone, _document, _focusTrapManager, _inertStrategy, config) {\n        super(_element, _checker, _ngZone, _document, config.defer);\n        this._focusTrapManager = _focusTrapManager;\n        this._inertStrategy = _inertStrategy;\n        this._focusTrapManager.register(this);\n    }\n    /** Whether the FocusTrap is enabled. */\n    get enabled() { return this._enabled; }\n    set enabled(value) {\n        this._enabled = value;\n        if (this._enabled) {\n            this._focusTrapManager.register(this);\n        }\n        else {\n            this._focusTrapManager.deregister(this);\n        }\n    }\n    /** Notifies the FocusTrapManager that this FocusTrap will be destroyed. */\n    destroy() {\n        this._focusTrapManager.deregister(this);\n        super.destroy();\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _enable() {\n        this._inertStrategy.preventFocus(this);\n        this.toggleAnchors(true);\n    }\n    /** @docs-private Implemented as part of ManagedFocusTrap. */\n    _disable() {\n        this._inertStrategy.allowFocus(this);\n        this.toggleAnchors(false);\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** IE 11 compatible closest implementation that is able to start from non-Element Nodes. */\nfunction closest(element, selector) {\n    if (!(element instanceof Node)) {\n        return null;\n    }\n    let curr = element;\n    while (curr != null && !(curr instanceof Element)) {\n        curr = curr.parentNode;\n    }\n    return curr && (hasNativeClosest ?\n        curr.closest(selector) : polyfillClosest(curr, selector));\n}\n/** Polyfill for browsers without Element.closest. */\nfunction polyfillClosest(element, selector) {\n    let curr = element;\n    while (curr != null && !(curr instanceof Element && matches(curr, selector))) {\n        curr = curr.parentNode;\n    }\n    return (curr || null);\n}\nconst hasNativeClosest = typeof Element != 'undefined' && !!Element.prototype.closest;\n/** IE 11 compatible matches implementation. */\nfunction matches(element, selector) {\n    return element.matches ?\n        element.matches(selector) :\n        element['msMatchesSelector'](selector);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Lightweight FocusTrapInertStrategy that adds a document focus event\n * listener to redirect focus back inside the FocusTrap.\n */\nclass EventListenerFocusTrapInertStrategy {\n    constructor() {\n        /** Focus event handler. */\n        this._listener = null;\n    }\n    /** Adds a document event listener that keeps focus inside the FocusTrap. */\n    preventFocus(focusTrap) {\n        // Ensure there's only one listener per document\n        if (this._listener) {\n            focusTrap._document.removeEventListener('focus', this._listener, true);\n        }\n        this._listener = (e) => this._trapFocus(focusTrap, e);\n        focusTrap._ngZone.runOutsideAngular(() => {\n            focusTrap._document.addEventListener('focus', this._listener, true);\n        });\n    }\n    /** Removes the event listener added in preventFocus. */\n    allowFocus(focusTrap) {\n        if (!this._listener) {\n            return;\n        }\n        focusTrap._document.removeEventListener('focus', this._listener, true);\n        this._listener = null;\n    }\n    /**\n     * Refocuses the first element in the FocusTrap if the focus event target was outside\n     * the FocusTrap.\n     *\n     * This is an event listener callback. The event listener is added in runOutsideAngular,\n     * so all this code runs outside Angular as well.\n     */\n    _trapFocus(focusTrap, event) {\n        const target = event.target;\n        const focusTrapRoot = focusTrap._element;\n        // Don't refocus if target was in an overlay, because the overlay might be associated\n        // with an element inside the FocusTrap, ex. mat-select.\n        if (!focusTrapRoot.contains(target) && closest(target, 'div.cdk-overlay-pane') === null) {\n            // Some legacy FocusTrap usages have logic that focuses some element on the page\n            // just before FocusTrap is destroyed. For backwards compatibility, wait\n            // to be sure FocusTrap is still enabled before refocusing.\n            setTimeout(() => {\n                // Check whether focus wasn't put back into the focus trap while the timeout was pending.\n                if (focusTrap.enabled && !focusTrapRoot.contains(focusTrap._document.activeElement)) {\n                    focusTrap.focusFirstTabbableElement();\n                }\n            });\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Configuration for creating a ConfigurableFocusTrap.\n */\nclass ConfigurableFocusTrapConfig {\n    constructor() {\n        /**\n         * Whether to defer the creation of FocusTrap elements to be\n         * done manually by the user. Default is to create them\n         * automatically.\n         */\n        this.defer = false;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The injection token used to specify the inert strategy. */\nconst FOCUS_TRAP_INERT_STRATEGY = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('FOCUS_TRAP_INERT_STRATEGY');\nlet a11y_FocusTrapManager = /*@__PURE__*/ (() => {\n    class FocusTrapManager {\n        constructor() {\n            // A stack of the FocusTraps on the page. Only the FocusTrap at the\n            // top of the stack is active.\n            this._focusTrapStack = [];\n        }\n        /**\n         * Disables the FocusTrap at the top of the stack, and then pushes\n         * the new FocusTrap onto the stack.\n         */\n        register(focusTrap) {\n            // Dedupe focusTraps that register multiple times.\n            this._focusTrapStack = this._focusTrapStack.filter((ft) => ft !== focusTrap);\n            let stack = this._focusTrapStack;\n            if (stack.length) {\n                stack[stack.length - 1]._disable();\n            }\n            stack.push(focusTrap);\n            focusTrap._enable();\n        }\n        /**\n         * Removes the FocusTrap from the stack, and activates the\n         * FocusTrap that is the new top of the stack.\n         */\n        deregister(focusTrap) {\n            focusTrap._disable();\n            const stack = this._focusTrapStack;\n            const i = stack.indexOf(focusTrap);\n            if (i !== -1) {\n                stack.splice(i, 1);\n                if (stack.length) {\n                    stack[stack.length - 1]._enable();\n                }\n            }\n        }\n    }\n    FocusTrapManager.fac = function FocusTrapManager_Factory(t) { return new (t || FocusTrapManager)(); };\n    FocusTrapManager.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function FocusTrapManager_Factory() { return new FocusTrapManager(); }, token: FocusTrapManager, providedIn: \"root\" });\n    return FocusTrapManager;\n})();\nlet a11y_ConfigurableFocusTrapFactory = /*@__PURE__*/ (() => {\n    class ConfigurableFocusTrapFactory {\n        constructor(_checker, _ngZone, _focusTrapManager, _document, _inertStrategy) {\n            this._checker = _checker;\n            this._ngZone = _ngZone;\n            this._focusTrapManager = _focusTrapManager;\n            this._document = _document;\n            // TODO split up the strategies into different modules, similar to DateAdapter.\n            this._inertStrategy = _inertStrategy || new EventListenerFocusTrapInertStrategy();\n        }\n        create(element, config = new ConfigurableFocusTrapConfig()) {\n            let configObject;\n            if (typeof config === 'boolean') {\n                configObject = new ConfigurableFocusTrapConfig();\n                configObject.defer = config;\n            }\n            else {\n                configObject = config;\n            }\n            return new ConfigurableFocusTrap(element, this._checker, this._ngZone, this._document, this._focusTrapManager, this._inertStrategy, configObject);\n        }\n    }\n    ConfigurableFocusTrapFactory.fac = function ConfigurableFocusTrapFactory_Factory(t) { return new (t || ConfigurableFocusTrapFactory)(core[\"Wb\" /* inject */](a11y_InteractivityChecker), core[\"Wb\" /* inject */](core[\"A\" /* NgZone */]), core[\"Wb\" /* inject */](a11y_FocusTrapManager), core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */]), core[\"Wb\" /* inject */](FOCUS_TRAP_INERT_STRATEGY, 8)); };\n    ConfigurableFocusTrapFactory.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function ConfigurableFocusTrapFactory_Factory() { return new ConfigurableFocusTrapFactory(Object(core[\"Wb\" /* inject */])(a11y_InteractivityChecker), Object(core[\"Wb\" /* inject */])(core[\"A\" /* NgZone */]), Object(core[\"Wb\" /* inject */])(a11y_FocusTrapManager), Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */]), Object(core[\"Wb\" /* inject */])(FOCUS_TRAP_INERT_STRATEGY, 8)); }, token: ConfigurableFocusTrapFactory, providedIn: \"root\" });\n    return ConfigurableFocusTrapFactory;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst LIVE_ANNOUNCER_ELEMENT_TOKEN = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('liveAnnouncerElement', {\n    providedIn: 'root',\n    factory: LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY,\n});\n/** @docs-private */\nfunction LIVE_ANNOUNCER_ELEMENT_TOKEN_FACTORY() {\n    return null;\n}\n/** Injection token that can be used to configure the default options for the LiveAnnouncer. */\nconst LIVE_ANNOUNCER_DEFAULT_OPTIONS = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('LIVE_ANNOUNCER_DEFAULT_OPTIONS');\nlet a11y_LiveAnnouncer = /*@__PURE__*/ (() => {\n    class LiveAnnouncer {\n        constructor(elementToken, _ngZone, _document, _defaultOptions) {\n            this._ngZone = _ngZone;\n            this._defaultOptions = _defaultOptions;\n            // We inject the live element and document as `any` because the constructor signature cannot\n            // reference browser globals (HTMLElement, Document) on non-browser environments, since having\n            // a class decorator causes TypeScript to preserve the constructor signature types.\n            this._document = _document;\n            this._liveElement = elementToken || this._createLiveElement();\n        }\n        announce(message, ...args) {\n            const defaultOptions = this._defaultOptions;\n            let politeness;\n            let duration;\n            if (args.length === 1 && typeof args[0] === 'number') {\n                duration = args[0];\n            }\n            else {\n                [politeness, duration] = args;\n            }\n            this.clear();\n            clearTimeout(this._previousTimeout);\n            if (!politeness) {\n                politeness =\n                    (defaultOptions && defaultOptions.politeness) ? defaultOptions.politeness : 'polite';\n            }\n            if (duration == null && defaultOptions) {\n                duration = defaultOptions.duration;\n            }\n            // TODO: ensure changing the politeness works on all environments we support.\n            this._liveElement.setAttribute('aria-live', politeness);\n            // This 100ms timeout is necessary for some browser + screen-reader combinations:\n            // - Both JAWS and NVDA over IE11 will not announce anything without a non-zero timeout.\n            // - With Chrome and IE11 with NVDA or JAWS, a repeated (identical) message won't be read a\n            //   second time without clearing and then using a non-zero delay.\n            // (using JAWS 17 at time of this writing).\n            return this._ngZone.runOutsideAngular(() => {\n                return new Promise(resolve => {\n                    clearTimeout(this._previousTimeout);\n                    this._previousTimeout = setTimeout(() => {\n                        this._liveElement.textContent = message;\n                        resolve();\n                        if (typeof duration === 'number') {\n                            this._previousTimeout = setTimeout(() => this.clear(), duration);\n                        }\n                    }, 100);\n                });\n            });\n        }\n        /**\n         * Clears the current text from the announcer element. Can be used to prevent\n         * screen readers from reading the text out again while the user is going\n         * through the page landmarks.\n         */\n        clear() {\n            if (this._liveElement) {\n                this._liveElement.textContent = '';\n            }\n        }\n        ngOnDestroy() {\n            clearTimeout(this._previousTimeout);\n            if (this._liveElement && this._liveElement.parentNode) {\n                this._liveElement.parentNode.removeChild(this._liveElement);\n                this._liveElement = null;\n            }\n        }\n        _createLiveElement() {\n            const elementClass = 'cdk-live-announcer-element';\n            const previousElements = this._document.getElementsByClassName(elementClass);\n            const liveEl = this._document.createElement('div');\n            // Remove any old containers. This can happen when coming in from a server-side-rendered page.\n            for (let i = 0; i < previousElements.length; i++) {\n                previousElements[i].parentNode.removeChild(previousElements[i]);\n            }\n            liveEl.classList.add(elementClass);\n            liveEl.classList.add('cdk-visually-hidden');\n            liveEl.setAttribute('aria-atomic', 'true');\n            liveEl.setAttribute('aria-live', 'polite');\n            this._document.body.appendChild(liveEl);\n            return liveEl;\n        }\n    }\n    LiveAnnouncer.fac = function LiveAnnouncer_Factory(t) { return new (t || LiveAnnouncer)(core[\"Wb\" /* inject */](LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), core[\"Wb\" /* inject */](core[\"A\" /* NgZone */]), core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */]), core[\"Wb\" /* inject */](LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); };\n    LiveAnnouncer.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function LiveAnnouncer_Factory() { return new LiveAnnouncer(Object(core[\"Wb\" /* inject */])(LIVE_ANNOUNCER_ELEMENT_TOKEN, 8), Object(core[\"Wb\" /* inject */])(core[\"A\" /* NgZone */]), Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */]), Object(core[\"Wb\" /* inject */])(LIVE_ANNOUNCER_DEFAULT_OPTIONS, 8)); }, token: LiveAnnouncer, providedIn: \"root\" });\n    return LiveAnnouncer;\n})();\nlet a11y_CdkAriaLive = /*@__PURE__*/ (() => {\n    class CdkAriaLive {\n        constructor(_elementRef, _liveAnnouncer, _contentObserver, _ngZone) {\n            this._elementRef = _elementRef;\n            this._liveAnnouncer = _liveAnnouncer;\n            this._contentObserver = _contentObserver;\n            this._ngZone = _ngZone;\n            this._politeness = 'polite';\n        }\n        /** The aria-live politeness level to use when announcing messages. */\n        get politeness() { return this._politeness; }\n        set politeness(value) {\n            this._politeness = value === 'off' || value === 'assertive' ? value : 'polite';\n            if (this._politeness === 'off') {\n                if (this._subscription) {\n                    this._subscription.unsubscribe();\n                    this._subscription = null;\n                }\n            }\n            else if (!this._subscription) {\n                this._subscription = this._ngZone.runOutsideAngular(() => {\n                    return this._contentObserver\n                        .observe(this._elementRef)\n                        .subscribe(() => {\n                        // Note that we use textContent here, rather than innerText, in order to avoid a reflow.\n                        const elementText = this._elementRef.nativeElement.textContent;\n                        // The `MutationObserver` fires also for attribute\n                        // changes which we don't want to announce.\n                        if (elementText !== this._previousAnnouncedText) {\n                            this._liveAnnouncer.announce(elementText, this._politeness);\n                            this._previousAnnouncedText = elementText;\n                        }\n                    });\n                });\n            }\n        }\n        ngOnDestroy() {\n            if (this._subscription) {\n                this._subscription.unsubscribe();\n            }\n        }\n    }\n    CdkAriaLive.fac = function CdkAriaLive_Factory(t) { return new (t || CdkAriaLive)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](a11y_LiveAnnouncer), core[\"Mb\" /* directiveInject */](observers_ContentObserver), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */])); };\n    CdkAriaLive.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: CdkAriaLive, selectors: [[\"\", \"cdkAriaLive\", \"\"]], inputs: { politeness: [\"cdkAriaLive\", \"politeness\"] }, exportAs: [\"cdkAriaLive\"] });\n    return CdkAriaLive;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Gets whether an event could be a faked `mousedown` event dispatched by a screen reader. */\nfunction isFakeMousedownFromScreenReader(event) {\n    // We can typically distinguish between these faked mousedown events and real mousedown events\n    // using the \"buttons\" property. While real mousedowns will indicate the mouse button that was\n    // pressed (e.g. \"1\" for the left mouse button), faked mousedowns will usually set the property\n    // value to 0.\n    return event.buttons === 0;\n}\n/** Gets whether an event could be a faked `touchstart` event dispatched by a screen reader. */\nfunction isFakeTouchstartFromScreenReader(event) {\n    const touch = (event.touches && event.touches[0]) ||\n        (event.changedTouches && event.changedTouches[0]);\n    // A fake `touchstart` can be distinguished from a real one by looking at the `identifier`\n    // which is typically >= 0 on a real device versus -1 from a screen reader. Just to be safe,\n    // we can also look at `radiusX` and `radiusY`. This behavior was observed against a Windows 10\n    // device with a touch screen running NVDA v2020.4 and Firefox 85 or Chrome 88.\n    return !!touch && touch.identifier === -1 && (touch.radiusX == null || touch.radiusX === 1) &&\n        (touch.radiusY == null || touch.radiusY === 1);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// This is the value used by AngularJS Material. Through trial and error (on iPhone 6S) they found\n// that a value of around 650ms seems appropriate.\nconst TOUCH_BUFFER_MS = 650;\n/** InjectionToken for FocusMonitorOptions. */\nconst FOCUS_MONITOR_DEFAULT_OPTIONS = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('cdk-focus-monitor-default-options');\n/**\n * Event listener options that enable capturing and also\n * mark the listener as passive if the browser supports it.\n */\nconst captureEventListenerOptions = /*@__PURE__*/ normalizePassiveListenerOptions({\n    passive: true,\n    capture: true\n});\nlet a11y_FocusMonitor = /*@__PURE__*/ (() => {\n    class FocusMonitor {\n        constructor(_ngZone, _platform, \n        /** @breaking-change 11.0.0 make document required */\n        document, options) {\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            /** The focus origin that the next focus event is a result of. */\n            this._origin = null;\n            /** Whether the window has just been focused. */\n            this._windowFocused = false;\n            /** Map of elements being monitored to their info. */\n            this._elementInfo = new Map();\n            /** The number of elements currently being monitored. */\n            this._monitoredElementCount = 0;\n            /**\n             * Keeps track of the root nodes to which we've currently bound a focus/blur handler,\n             * as well as the number of monitored elements that they contain. We have to treat focus/blur\n             * handlers differently from the rest of the events, because the browser won't emit events\n             * to the document when focus moves inside of a shadow root.\n             */\n            this._rootNodeFocusListenerCount = new Map();\n            /**\n             * Event listener for `keydown` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentKeydownListener = () => {\n                // On keydown record the origin and clear any touch event that may be in progress.\n                this._lastTouchTarget = null;\n                this._setOriginForCurrentEventQueue('keyboard');\n            };\n            /**\n             * Event listener for `mousedown` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentMousedownListener = (event) => {\n                // On mousedown record the origin only if there is not touch\n                // target, since a mousedown can happen as a result of a touch event.\n                if (!this._lastTouchTarget) {\n                    // In some cases screen readers fire fake `mousedown` events instead of `keydown`.\n                    // Resolve the focus source to `keyboard` if we detect one of them.\n                    const source = isFakeMousedownFromScreenReader(event) ? 'keyboard' : 'mouse';\n                    this._setOriginForCurrentEventQueue(source);\n                }\n            };\n            /**\n             * Event listener for `touchstart` events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._documentTouchstartListener = (event) => {\n                // Some screen readers will fire a fake `touchstart` event if an element is activated using\n                // the keyboard while on a device with a touchsreen. Consider such events as keyboard focus.\n                if (!isFakeTouchstartFromScreenReader(event)) {\n                    // When the touchstart event fires the focus event is not yet in the event queue. This means\n                    // we can't rely on the trick used above (setting timeout of 1ms). Instead we wait 650ms to\n                    // see if a focus happens.\n                    if (this._touchTimeoutId != null) {\n                        clearTimeout(this._touchTimeoutId);\n                    }\n                    this._lastTouchTarget = getTarget(event);\n                    this._touchTimeoutId = setTimeout(() => this._lastTouchTarget = null, TOUCH_BUFFER_MS);\n                }\n                else if (!this._lastTouchTarget) {\n                    this._setOriginForCurrentEventQueue('keyboard');\n                }\n            };\n            /**\n             * Event listener for `focus` events on the window.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._windowFocusListener = () => {\n                // Make a note of when the window regains focus, so we can\n                // restore the origin info for the focused element.\n                this._windowFocused = true;\n                this._windowFocusTimeoutId = setTimeout(() => this._windowFocused = false);\n            };\n            /**\n             * Event listener for `focus` and 'blur' events on the document.\n             * Needs to be an arrow function in order to preserve the context when it gets bound.\n             */\n            this._rootNodeFocusAndBlurListener = (event) => {\n                const target = getTarget(event);\n                const handler = event.type === 'focus' ? this._onFocus : this._onBlur;\n                // We need to walk up the ancestor chain in order to support `checkChildren`.\n                for (let element = target; element; element = element.parentElement) {\n                    handler.call(this, event, element);\n                }\n            };\n            this._document = document;\n            this._detectionMode = (options === null || options === void 0 ? void 0 : options.detectionMode) || 0 /* IMMEDIATE */;\n        }\n        monitor(element, checkChildren = false) {\n            const nativeElement = coerceElement(element);\n            // Do nothing if we're not on the browser platform or the passed in node isn't an element.\n            if (!this._platform.isBrowser || nativeElement.nodeType !== 1) {\n                return Object(of[\"a\" /* of */])(null);\n            }\n            // If the element is inside the shadow DOM, we need to bind our focus/blur listeners to\n            // the shadow root, rather than the `document`, because the browser won't emit focus events\n            // to the `document`, if focus is moving within the same shadow root.\n            const rootNode = _getShadowRoot(nativeElement) || this._getDocument();\n            const cachedInfo = this._elementInfo.get(nativeElement);\n            // Check if we're already monitoring this element.\n            if (cachedInfo) {\n                if (checkChildren) {\n                    // TODO(COMP-318): this can be problematic, because it'll turn all non-checkChildren\n                    // observers into ones that behave as if `checkChildren` was turned on. We need a more\n                    // robust solution.\n                    cachedInfo.checkChildren = true;\n                }\n                return cachedInfo.subject;\n            }\n            // Create monitored element info.\n            const info = {\n                checkChildren: checkChildren,\n                subject: new Subject[\"a\" /* Subject */](),\n                rootNode\n            };\n            this._elementInfo.set(nativeElement, info);\n            this._registerGlobalListeners(info);\n            return info.subject;\n        }\n        stopMonitoring(element) {\n            const nativeElement = coerceElement(element);\n            const elementInfo = this._elementInfo.get(nativeElement);\n            if (elementInfo) {\n                elementInfo.subject.complete();\n                this._setClasses(nativeElement);\n                this._elementInfo.delete(nativeElement);\n                this._removeGlobalListeners(elementInfo);\n            }\n        }\n        focusVia(element, origin, options) {\n            const nativeElement = coerceElement(element);\n            const focusedElement = this._getDocument().activeElement;\n            // If the element is focused already, calling `focus` again won't trigger the event listener\n            // which means that the focus classes won't be updated. If that's the case, update the classes\n            // directly without waiting for an event.\n            if (nativeElement === focusedElement) {\n                this._getClosestElementsInfo(nativeElement)\n                    .forEach(([currentElement, info]) => this._originChanged(currentElement, origin, info));\n            }\n            else {\n                this._setOriginForCurrentEventQueue(origin);\n                // `focus` isn't available on the server\n                if (typeof nativeElement.focus === 'function') {\n                    nativeElement.focus(options);\n                }\n            }\n        }\n        ngOnDestroy() {\n            this._elementInfo.forEach((_info, element) => this.stopMonitoring(element));\n        }\n        /** Access injected document if available or fallback to global document reference */\n        _getDocument() {\n            return this._document || document;\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            const doc = this._getDocument();\n            return doc.defaultView || window;\n        }\n        _toggleClass(element, className, shouldSet) {\n            if (shouldSet) {\n                element.classList.add(className);\n            }\n            else {\n                element.classList.remove(className);\n            }\n        }\n        _getFocusOrigin(event) {\n            // If we couldn't detect a cause for the focus event, it's due to one of three reasons:\n            // 1) The window has just regained focus, in which case we want to restore the focused state of\n            //    the element from before the window blurred.\n            // 2) It was caused by a touch event, in which case we mark the origin as 'touch'.\n            // 3) The element was programmatically focused, in which case we should mark the origin as\n            //    'program'.\n            if (this._origin) {\n                return this._origin;\n            }\n            if (this._windowFocused && this._lastFocusOrigin) {\n                return this._lastFocusOrigin;\n            }\n            else if (this._wasCausedByTouch(event)) {\n                return 'touch';\n            }\n            else {\n                return 'program';\n            }\n        }\n        /**\n         * Sets the focus classes on the element based on the given focus origin.\n         * @param element The element to update the classes on.\n         * @param origin The focus origin.\n         */\n        _setClasses(element, origin) {\n            this._toggleClass(element, 'cdk-focused', !!origin);\n            this._toggleClass(element, 'cdk-touch-focused', origin === 'touch');\n            this._toggleClass(element, 'cdk-keyboard-focused', origin === 'keyboard');\n            this._toggleClass(element, 'cdk-mouse-focused', origin === 'mouse');\n            this._toggleClass(element, 'cdk-program-focused', origin === 'program');\n        }\n        /**\n         * Sets the origin and schedules an async function to clear it at the end of the event queue.\n         * If the detection mode is 'eventual', the origin is never cleared.\n         * @param origin The origin to set.\n         */\n        _setOriginForCurrentEventQueue(origin) {\n            this._ngZone.runOutsideAngular(() => {\n                this._origin = origin;\n                if (this._detectionMode === 0 /* IMMEDIATE */) {\n                    // Sometimes the focus origin won't be valid in Firefox because Firefox seems to focus *one*\n                    // tick after the interaction event fired. To ensure the focus origin is always correct,\n                    // the focus origin will be determined at the beginning of the next tick.\n                    this._originTimeoutId = setTimeout(() => this._origin = null, 1);\n                }\n            });\n        }\n        /**\n         * Checks whether the given focus event was caused by a touchstart event.\n         * @param event The focus event to check.\n         * @returns Whether the event was caused by a touch.\n         */\n        _wasCausedByTouch(event) {\n            // Note(mmalerba): This implementation is not quite perfect, there is a small edge case.\n            // Consider the following dom structure:\n            //\n            // <div #parent tabindex=\"0\" cdkFocusClasses>\n            //   <div #child (click)=\"#parent.focus()\"></div>\n            // </div>\n            //\n            // If the user touches the #child element and the #parent is programmatically focused as a\n            // result, this code will still consider it to have been caused by the touch event and will\n            // apply the cdk-touch-focused class rather than the cdk-program-focused class. This is a\n            // relatively small edge-case that can be worked around by using\n            // focusVia(parentEl, 'program') to focus the parent element.\n            //\n            // If we decide that we absolutely must handle this case correctly, we can do so by listening\n            // for the first focus event after the touchstart, and then the first blur event after that\n            // focus event. When that blur event fires we know that whatever follows is not a result of the\n            // touchstart.\n            const focusTarget = getTarget(event);\n            return this._lastTouchTarget instanceof Node && focusTarget instanceof Node &&\n                (focusTarget === this._lastTouchTarget || focusTarget.contains(this._lastTouchTarget));\n        }\n        /**\n         * Handles focus events on a registered element.\n         * @param event The focus event.\n         * @param element The monitored element.\n         */\n        _onFocus(event, element) {\n            // NOTE(mmalerba): We currently set the classes based on the focus origin of the most recent\n            // focus event affecting the monitored element. If we want to use the origin of the first event\n            // instead we should check for the cdk-focused class here and return if the element already has\n            // it. (This only matters for elements that have includesChildren = true).\n            // If we are not counting child-element-focus as focused, make sure that the event target is the\n            // monitored element itself.\n            const elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (!elementInfo.checkChildren && element !== getTarget(event))) {\n                return;\n            }\n            this._originChanged(element, this._getFocusOrigin(event), elementInfo);\n        }\n        /**\n         * Handles blur events on a registered element.\n         * @param event The blur event.\n         * @param element The monitored element.\n         */\n        _onBlur(event, element) {\n            // If we are counting child-element-focus as focused, make sure that we aren't just blurring in\n            // order to focus another child of the monitored element.\n            const elementInfo = this._elementInfo.get(element);\n            if (!elementInfo || (elementInfo.checkChildren && event.relatedTarget instanceof Node &&\n                element.contains(event.relatedTarget))) {\n                return;\n            }\n            this._setClasses(element);\n            this._emitOrigin(elementInfo.subject, null);\n        }\n        _emitOrigin(subject, origin) {\n            this._ngZone.run(() => subject.next(origin));\n        }\n        _registerGlobalListeners(elementInfo) {\n            if (!this._platform.isBrowser) {\n                return;\n            }\n            const rootNode = elementInfo.rootNode;\n            const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode) || 0;\n            if (!rootNodeFocusListeners) {\n                this._ngZone.runOutsideAngular(() => {\n                    rootNode.addEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                    rootNode.addEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                });\n            }\n            this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners + 1);\n            // Register global listeners when first element is monitored.\n            if (++this._monitoredElementCount === 1) {\n                // Note: we listen to events in the capture phase so we\n                // can detect them even if the user stops propagation.\n                this._ngZone.runOutsideAngular(() => {\n                    const document = this._getDocument();\n                    const window = this._getWindow();\n                    document.addEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);\n                    document.addEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);\n                    document.addEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);\n                    window.addEventListener('focus', this._windowFocusListener);\n                });\n            }\n        }\n        _removeGlobalListeners(elementInfo) {\n            const rootNode = elementInfo.rootNode;\n            if (this._rootNodeFocusListenerCount.has(rootNode)) {\n                const rootNodeFocusListeners = this._rootNodeFocusListenerCount.get(rootNode);\n                if (rootNodeFocusListeners > 1) {\n                    this._rootNodeFocusListenerCount.set(rootNode, rootNodeFocusListeners - 1);\n                }\n                else {\n                    rootNode.removeEventListener('focus', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                    rootNode.removeEventListener('blur', this._rootNodeFocusAndBlurListener, captureEventListenerOptions);\n                    this._rootNodeFocusListenerCount.delete(rootNode);\n                }\n            }\n            // Unregister global listeners when last element is unmonitored.\n            if (!--this._monitoredElementCount) {\n                const document = this._getDocument();\n                const window = this._getWindow();\n                document.removeEventListener('keydown', this._documentKeydownListener, captureEventListenerOptions);\n                document.removeEventListener('mousedown', this._documentMousedownListener, captureEventListenerOptions);\n                document.removeEventListener('touchstart', this._documentTouchstartListener, captureEventListenerOptions);\n                window.removeEventListener('focus', this._windowFocusListener);\n                // Clear timeouts for all potentially pending timeouts to prevent the leaks.\n                clearTimeout(this._windowFocusTimeoutId);\n                clearTimeout(this._touchTimeoutId);\n                clearTimeout(this._originTimeoutId);\n            }\n        }\n        /** Updates all the state on an element once its focus origin has changed. */\n        _originChanged(element, origin, elementInfo) {\n            this._setClasses(element, origin);\n            this._emitOrigin(elementInfo.subject, origin);\n            this._lastFocusOrigin = origin;\n        }\n        /**\n         * Collects the `MonitoredElementInfo` of a particular element and\n         * all of its ancestors that have enabled `checkChildren`.\n         * @param element Element from which to start the search.\n         */\n        _getClosestElementsInfo(element) {\n            const results = [];\n            this._elementInfo.forEach((info, currentElement) => {\n                if (currentElement === element || (info.checkChildren && currentElement.contains(element))) {\n                    results.push([currentElement, info]);\n                }\n            });\n            return results;\n        }\n    }\n    FocusMonitor.fac = function FocusMonitor_Factory(t) { return new (t || FocusMonitor)(core[\"Wb\" /* inject */](core[\"A\" /* NgZone */]), core[\"Wb\" /* inject */](platform_Platform), core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */], 8), core[\"Wb\" /* inject */](FOCUS_MONITOR_DEFAULT_OPTIONS, 8)); };\n    FocusMonitor.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function FocusMonitor_Factory() { return new FocusMonitor(Object(core[\"Wb\" /* inject */])(core[\"A\" /* NgZone */]), Object(core[\"Wb\" /* inject */])(platform_Platform), Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */], 8), Object(core[\"Wb\" /* inject */])(FOCUS_MONITOR_DEFAULT_OPTIONS, 8)); }, token: FocusMonitor, providedIn: \"root\" });\n    return FocusMonitor;\n})();\n/** Gets the target of an event, accounting for Shadow DOM. */\nfunction getTarget(event) {\n    // If an event is bound outside the Shadow DOM, the `event.target` will\n    // point to the shadow root so we have to use `composedPath` instead.\n    return (event.composedPath ? event.composedPath()[0] : event.target);\n}\nlet a11y_CdkMonitorFocus = /*@__PURE__*/ (() => {\n    class CdkMonitorFocus {\n        constructor(_elementRef, _focusMonitor) {\n            this._elementRef = _elementRef;\n            this._focusMonitor = _focusMonitor;\n            this.cdkFocusChange = new core[\"n\" /* EventEmitter */]();\n        }\n        ngAfterViewInit() {\n            const element = this._elementRef.nativeElement;\n            this._monitorSubscription = this._focusMonitor.monitor(element, element.nodeType === 1 && element.hasAttribute('cdkMonitorSubtreeFocus'))\n                .subscribe(origin => this.cdkFocusChange.emit(origin));\n        }\n        ngOnDestroy() {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n            if (this._monitorSubscription) {\n                this._monitorSubscription.unsubscribe();\n            }\n        }\n    }\n    CdkMonitorFocus.fac = function CdkMonitorFocus_Factory(t) { return new (t || CdkMonitorFocus)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](a11y_FocusMonitor)); };\n    CdkMonitorFocus.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: CdkMonitorFocus, selectors: [[\"\", \"cdkMonitorElementFocus\", \"\"], [\"\", \"cdkMonitorSubtreeFocus\", \"\"]], outputs: { cdkFocusChange: \"cdkFocusChange\" } });\n    return CdkMonitorFocus;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** CSS class applied to the document body when in black-on-white high-contrast mode. */\nconst BLACK_ON_WHITE_CSS_CLASS = 'cdk-high-contrast-black-on-white';\n/** CSS class applied to the document body when in white-on-black high-contrast mode. */\nconst WHITE_ON_BLACK_CSS_CLASS = 'cdk-high-contrast-white-on-black';\n/** CSS class applied to the document body when in high-contrast mode. */\nconst HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS = 'cdk-high-contrast-active';\nlet a11y_HighContrastModeDetector = /*@__PURE__*/ (() => {\n    class HighContrastModeDetector {\n        constructor(_platform, document) {\n            this._platform = _platform;\n            this._document = document;\n        }\n        /** Gets the current high-contrast-mode for the page. */\n        getHighContrastMode() {\n            if (!this._platform.isBrowser) {\n                return 0 /* NONE */;\n            }\n            // Create a test element with an arbitrary background-color that is neither black nor\n            // white; high-contrast mode will coerce the color to either black or white. Also ensure that\n            // appending the test element to the DOM does not affect layout by absolutely positioning it\n            const testElement = this._document.createElement('div');\n            testElement.style.backgroundColor = 'rgb(1,2,3)';\n            testElement.style.position = 'absolute';\n            this._document.body.appendChild(testElement);\n            // Get the computed style for the background color, collapsing spaces to normalize between\n            // browsers. Once we get this color, we no longer need the test element. Access the `window`\n            // via the document so we can fake it in tests. Note that we have extra null checks, because\n            // this logic will likely run during app bootstrap and throwing can break the entire app.\n            const documentWindow = this._document.defaultView || window;\n            const computedStyle = (documentWindow && documentWindow.getComputedStyle) ?\n                documentWindow.getComputedStyle(testElement) : null;\n            const computedColor = (computedStyle && computedStyle.backgroundColor || '').replace(/ /g, '');\n            this._document.body.removeChild(testElement);\n            switch (computedColor) {\n                case 'rgb(0,0,0)': return 2 /* WHITE_ON_BLACK */;\n                case 'rgb(255,255,255)': return 1 /* BLACK_ON_WHITE */;\n            }\n            return 0 /* NONE */;\n        }\n        /** Applies CSS classes indicating high-contrast mode to document body (browser-only). */\n        _applyBodyHighContrastModeCssClasses() {\n            if (this._platform.isBrowser && this._document.body) {\n                const bodyClasses = this._document.body.classList;\n                // IE11 doesn't support `classList` operations with multiple arguments\n                bodyClasses.remove(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n                bodyClasses.remove(BLACK_ON_WHITE_CSS_CLASS);\n                bodyClasses.remove(WHITE_ON_BLACK_CSS_CLASS);\n                const mode = this.getHighContrastMode();\n                if (mode === 1 /* BLACK_ON_WHITE */) {\n                    bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n                    bodyClasses.add(BLACK_ON_WHITE_CSS_CLASS);\n                }\n                else if (mode === 2 /* WHITE_ON_BLACK */) {\n                    bodyClasses.add(HIGH_CONTRAST_MODE_ACTIVE_CSS_CLASS);\n                    bodyClasses.add(WHITE_ON_BLACK_CSS_CLASS);\n                }\n            }\n        }\n    }\n    HighContrastModeDetector.fac = function HighContrastModeDetector_Factory(t) { return new (t || HighContrastModeDetector)(core[\"Wb\" /* inject */](platform_Platform), core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */])); };\n    HighContrastModeDetector.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function HighContrastModeDetector_Factory() { return new HighContrastModeDetector(Object(core[\"Wb\" /* inject */])(platform_Platform), Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */])); }, token: HighContrastModeDetector, providedIn: \"root\" });\n    return HighContrastModeDetector;\n})();\nlet a11y_A11yModule = /*@__PURE__*/ (() => {\n    class A11yModule {\n        constructor(highContrastModeDetector) {\n            highContrastModeDetector._applyBodyHighContrastModeCssClasses();\n        }\n    }\n    A11yModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: A11yModule });\n    A11yModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function A11yModule_Factory(t) { return new (t || A11yModule)(core[\"Wb\" /* inject */](a11y_HighContrastModeDetector)); }, imports: [[platform_PlatformModule, observers_ObserversModule]] });\n    return A11yModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](a11y_A11yModule, { declarations: function () { return [a11y_CdkAriaLive, a11y_CdkTrapFocus, a11y_CdkMonitorFocus]; }, imports: function () { return [platform_PlatformModule, observers_ObserversModule]; }, exports: function () { return [a11y_CdkAriaLive, a11y_CdkTrapFocus, a11y_CdkMonitorFocus]; } }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=a11y.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/portal.js\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Throws an exception when attempting to attach a null portal to a host.\n * @docs-private\n */\n\nfunction throwNullPortalError() {\n    throw Error('Must provide a portal to attach');\n}\n/**\n * Throws an exception when attempting to attach a portal to a host that is already attached.\n * @docs-private\n */\nfunction throwPortalAlreadyAttachedError() {\n    throw Error('Host already has a portal attached');\n}\n/**\n * Throws an exception when attempting to attach a portal to an already-disposed host.\n * @docs-private\n */\nfunction throwPortalOutletAlreadyDisposedError() {\n    throw Error('This PortalOutlet has already been disposed');\n}\n/**\n * Throws an exception when attempting to attach an unknown portal type.\n * @docs-private\n */\nfunction throwUnknownPortalTypeError() {\n    throw Error('Attempting to attach an unknown Portal type. BasePortalOutlet accepts either ' +\n        'a ComponentPortal or a TemplatePortal.');\n}\n/**\n * Throws an exception when attempting to attach a portal to a null host.\n * @docs-private\n */\nfunction throwNullPortalOutletError() {\n    throw Error('Attempting to attach a portal to a null PortalOutlet');\n}\n/**\n * Throws an exception when attempting to detach a portal that is not attached.\n * @docs-private\n */\nfunction throwNoPortalAttachedError() {\n    throw Error('Attempting to detach a portal that is not attached to a host');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A `Portal` is something that you want to render somewhere else.\n * It can be attach to / detached from a `PortalOutlet`.\n */\nclass Portal {\n    /** Attach this portal to a host. */\n    attach(host) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (host == null) {\n                throwNullPortalOutletError();\n            }\n            if (host.hasAttached()) {\n                throwPortalAlreadyAttachedError();\n            }\n        }\n        this._attachedHost = host;\n        return host.attach(this);\n    }\n    /** Detach this portal from its host */\n    detach() {\n        let host = this._attachedHost;\n        if (host != null) {\n            this._attachedHost = null;\n            host.detach();\n        }\n        else if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throwNoPortalAttachedError();\n        }\n    }\n    /** Whether this portal is attached to a host. */\n    get isAttached() {\n        return this._attachedHost != null;\n    }\n    /**\n     * Sets the PortalOutlet reference without performing `attach()`. This is used directly by\n     * the PortalOutlet when it is performing an `attach()` or `detach()`.\n     */\n    setAttachedHost(host) {\n        this._attachedHost = host;\n    }\n}\n/**\n * A `ComponentPortal` is a portal that instantiates some Component upon attachment.\n */\nclass ComponentPortal extends Portal {\n    constructor(component, viewContainerRef, injector, componentFactoryResolver) {\n        super();\n        this.component = component;\n        this.viewContainerRef = viewContainerRef;\n        this.injector = injector;\n        this.componentFactoryResolver = componentFactoryResolver;\n    }\n}\n/**\n * A `TemplatePortal` is a portal that represents some embedded template (TemplateRef).\n */\nclass TemplatePortal extends Portal {\n    constructor(template, viewContainerRef, context) {\n        super();\n        this.templateRef = template;\n        this.viewContainerRef = viewContainerRef;\n        this.context = context;\n    }\n    get origin() {\n        return this.templateRef.elementRef;\n    }\n    /**\n     * Attach the portal to the provided `PortalOutlet`.\n     * When a context is provided it will override the `context` property of the `TemplatePortal`\n     * instance.\n     */\n    attach(host, context = this.context) {\n        this.context = context;\n        return super.attach(host);\n    }\n    detach() {\n        this.context = undefined;\n        return super.detach();\n    }\n}\n/**\n * A `DomPortal` is a portal whose DOM element will be taken from its current position\n * in the DOM and moved into a portal outlet, when it is attached. On detach, the content\n * will be restored to its original position.\n */\nclass portal_DomPortal extends Portal {\n    constructor(element) {\n        super();\n        this.element = element instanceof core[\"l\" /* ElementRef */] ? element.nativeElement : element;\n    }\n}\n/**\n * Partial implementation of PortalOutlet that handles attaching\n * ComponentPortal and TemplatePortal.\n */\nclass BasePortalOutlet {\n    constructor() {\n        /** Whether this host has already been permanently disposed. */\n        this._isDisposed = false;\n        // @breaking-change 10.0.0 `attachDomPortal` to become a required abstract method.\n        this.attachDomPortal = null;\n    }\n    /** Whether this host has an attached portal. */\n    hasAttached() {\n        return !!this._attachedPortal;\n    }\n    /** Attaches a portal. */\n    attach(portal) {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (!portal) {\n                throwNullPortalError();\n            }\n            if (this.hasAttached()) {\n                throwPortalAlreadyAttachedError();\n            }\n            if (this._isDisposed) {\n                throwPortalOutletAlreadyDisposedError();\n            }\n        }\n        if (portal instanceof ComponentPortal) {\n            this._attachedPortal = portal;\n            return this.attachComponentPortal(portal);\n        }\n        else if (portal instanceof TemplatePortal) {\n            this._attachedPortal = portal;\n            return this.attachTemplatePortal(portal);\n            // @breaking-change 10.0.0 remove null check for `this.attachDomPortal`.\n        }\n        else if (this.attachDomPortal && portal instanceof portal_DomPortal) {\n            this._attachedPortal = portal;\n            return this.attachDomPortal(portal);\n        }\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            throwUnknownPortalTypeError();\n        }\n    }\n    /** Detaches a previously attached portal. */\n    detach() {\n        if (this._attachedPortal) {\n            this._attachedPortal.setAttachedHost(null);\n            this._attachedPortal = null;\n        }\n        this._invokeDisposeFn();\n    }\n    /** Permanently dispose of this portal host. */\n    dispose() {\n        if (this.hasAttached()) {\n            this.detach();\n        }\n        this._invokeDisposeFn();\n        this._isDisposed = true;\n    }\n    /** @docs-private */\n    setDisposeFn(fn) {\n        this._disposeFn = fn;\n    }\n    _invokeDisposeFn() {\n        if (this._disposeFn) {\n            this._disposeFn();\n            this._disposeFn = null;\n        }\n    }\n}\n/**\n * @deprecated Use `BasePortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass BasePortalHost extends BasePortalOutlet {\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A PortalOutlet for attaching portals to an arbitrary DOM element outside of the Angular\n * application context.\n */\nclass DomPortalOutlet extends BasePortalOutlet {\n    constructor(\n    /** Element into which the content is projected. */\n    outletElement, _componentFactoryResolver, _appRef, _defaultInjector, \n    /**\n     * @deprecated `_document` Parameter to be made required.\n     * @breaking-change 10.0.0\n     */\n    _document) {\n        super();\n        this.outletElement = outletElement;\n        this._componentFactoryResolver = _componentFactoryResolver;\n        this._appRef = _appRef;\n        this._defaultInjector = _defaultInjector;\n        /**\n         * Attaches a DOM portal by transferring its content into the outlet.\n         * @param portal Portal to be attached.\n         * @deprecated To be turned into a method.\n         * @breaking-change 10.0.0\n         */\n        this.attachDomPortal = (portal) => {\n            // @breaking-change 10.0.0 Remove check and error once the\n            // `_document` constructor parameter is required.\n            if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('Cannot attach DOM portal without _document constructor parameter');\n            }\n            const element = portal.element;\n            if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('DOM portal content must be attached to a parent node.');\n            }\n            // Anchor used to save the element's previous position so\n            // that we can restore it when the portal is detached.\n            const anchorNode = this._document.createComment('dom-portal');\n            element.parentNode.insertBefore(anchorNode, element);\n            this.outletElement.appendChild(element);\n            this._attachedPortal = portal;\n            super.setDisposeFn(() => {\n                // We can't use `replaceWith` here because IE doesn't support it.\n                if (anchorNode.parentNode) {\n                    anchorNode.parentNode.replaceChild(element, anchorNode);\n                }\n            });\n        };\n        this._document = _document;\n    }\n    /**\n     * Attach the given ComponentPortal to DOM element using the ComponentFactoryResolver.\n     * @param portal Portal to be attached\n     * @returns Reference to the created component.\n     */\n    attachComponentPortal(portal) {\n        const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n        const componentFactory = resolver.resolveComponentFactory(portal.component);\n        let componentRef;\n        // If the portal specifies a ViewContainerRef, we will use that as the attachment point\n        // for the component (in terms of Angular's component tree, not rendering).\n        // When the ViewContainerRef is missing, we use the factory to create the component directly\n        // and then manually attach the view to the application.\n        if (portal.viewContainerRef) {\n            componentRef = portal.viewContainerRef.createComponent(componentFactory, portal.viewContainerRef.length, portal.injector || portal.viewContainerRef.injector);\n            this.setDisposeFn(() => componentRef.destroy());\n        }\n        else {\n            componentRef = componentFactory.create(portal.injector || this._defaultInjector);\n            this._appRef.attachView(componentRef.hostView);\n            this.setDisposeFn(() => {\n                this._appRef.detachView(componentRef.hostView);\n                componentRef.destroy();\n            });\n        }\n        // At this point the component has been instantiated, so we move it to the location in the DOM\n        // where we want it to be rendered.\n        this.outletElement.appendChild(this._getComponentRootNode(componentRef));\n        this._attachedPortal = portal;\n        return componentRef;\n    }\n    /**\n     * Attaches a template portal to the DOM as an embedded view.\n     * @param portal Portal to be attached.\n     * @returns Reference to the created embedded view.\n     */\n    attachTemplatePortal(portal) {\n        let viewContainer = portal.viewContainerRef;\n        let viewRef = viewContainer.createEmbeddedView(portal.templateRef, portal.context);\n        // The method `createEmbeddedView` will add the view as a child of the viewContainer.\n        // But for the DomPortalOutlet the view can be added everywhere in the DOM\n        // (e.g Overlay Container) To move the view to the specified host element. We just\n        // re-append the existing root nodes.\n        viewRef.rootNodes.forEach(rootNode => this.outletElement.appendChild(rootNode));\n        // Note that we want to detect changes after the nodes have been moved so that\n        // any directives inside the portal that are looking at the DOM inside a lifecycle\n        // hook won't be invoked too early.\n        viewRef.detectChanges();\n        this.setDisposeFn((() => {\n            let index = viewContainer.indexOf(viewRef);\n            if (index !== -1) {\n                viewContainer.remove(index);\n            }\n        }));\n        this._attachedPortal = portal;\n        // TODO(jelbourn): Return locals from view.\n        return viewRef;\n    }\n    /**\n     * Clears out a portal from the DOM.\n     */\n    dispose() {\n        super.dispose();\n        if (this.outletElement.parentNode != null) {\n            this.outletElement.parentNode.removeChild(this.outletElement);\n        }\n    }\n    /** Gets the root HTMLElement for an instantiated component. */\n    _getComponentRootNode(componentRef) {\n        return componentRef.hostView.rootNodes[0];\n    }\n}\n/**\n * @deprecated Use `DomPortalOutlet` instead.\n * @breaking-change 9.0.0\n */\nclass DomPortalHost extends DomPortalOutlet {\n}\nlet portal_CdkPortal = /*@__PURE__*/ (() => {\n    class CdkPortal extends TemplatePortal {\n        constructor(templateRef, viewContainerRef) {\n            super(templateRef, viewContainerRef);\n        }\n    }\n    CdkPortal.fac = function CdkPortal_Factory(t) { return new (t || CdkPortal)(core[\"Mb\" /* directiveInject */](core[\"M\" /* TemplateRef */]), core[\"Mb\" /* directiveInject */](core[\"Q\" /* ViewContainerRef */])); };\n    CdkPortal.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: CdkPortal, selectors: [[\"\", \"cdkPortal\", \"\"]], exportAs: [\"cdkPortal\"], features: [core[\"xb\" /* InheritDefinitionFeature */]] });\n    return CdkPortal;\n})();\nlet portal_TemplatePortalDirective = /*@__PURE__*/ (() => {\n    class TemplatePortalDirective extends portal_CdkPortal {\n    }\n    TemplatePortalDirective.fac = function TemplatePortalDirective_Factory(t) { return TemplatePortalDirective_BaseFactory(t || TemplatePortalDirective); };\n    TemplatePortalDirective.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: TemplatePortalDirective, selectors: [[\"\", \"cdk-portal\", \"\"], [\"\", \"portal\", \"\"]], exportAs: [\"cdkPortal\"], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{\n                    provide: portal_CdkPortal,\n                    useExisting: TemplatePortalDirective\n                }]), core[\"xb\" /* InheritDefinitionFeature */]] });\n    return TemplatePortalDirective;\n})();\nconst TemplatePortalDirective_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Ub\" /* getInheritedFactory */](portal_TemplatePortalDirective);\nlet portal_CdkPortalOutlet = /*@__PURE__*/ (() => {\n    class CdkPortalOutlet extends BasePortalOutlet {\n        constructor(_componentFactoryResolver, _viewContainerRef, \n        /**\n         * @deprecated `_document` parameter to be made required.\n         * @breaking-change 9.0.0\n         */\n        _document) {\n            super();\n            this._componentFactoryResolver = _componentFactoryResolver;\n            this._viewContainerRef = _viewContainerRef;\n            /** Whether the portal component is initialized. */\n            this._isInitialized = false;\n            /** Emits when a portal is attached to the outlet. */\n            this.attached = new core[\"n\" /* EventEmitter */]();\n            /**\n             * Attaches the given DomPortal to this PortalHost by moving all of the portal content into it.\n             * @param portal Portal to be attached.\n             * @deprecated To be turned into a method.\n             * @breaking-change 10.0.0\n             */\n            this.attachDomPortal = (portal) => {\n                // @breaking-change 9.0.0 Remove check and error once the\n                // `_document` constructor parameter is required.\n                if (!this._document && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                    throw Error('Cannot attach DOM portal without _document constructor parameter');\n                }\n                const element = portal.element;\n                if (!element.parentNode && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                    throw Error('DOM portal content must be attached to a parent node.');\n                }\n                // Anchor used to save the element's previous position so\n                // that we can restore it when the portal is detached.\n                const anchorNode = this._document.createComment('dom-portal');\n                portal.setAttachedHost(this);\n                element.parentNode.insertBefore(anchorNode, element);\n                this._getRootNode().appendChild(element);\n                this._attachedPortal = portal;\n                super.setDisposeFn(() => {\n                    if (anchorNode.parentNode) {\n                        anchorNode.parentNode.replaceChild(element, anchorNode);\n                    }\n                });\n            };\n            this._document = _document;\n        }\n        /** Portal associated with the Portal outlet. */\n        get portal() {\n            return this._attachedPortal;\n        }\n        set portal(portal) {\n            // Ignore the cases where the `portal` is set to a falsy value before the lifecycle hooks have\n            // run. This handles the cases where the user might do something like `<div cdkPortalOutlet>`\n            // and attach a portal programmatically in the parent component. When Angular does the first CD\n            // round, it will fire the setter with empty string, causing the user's content to be cleared.\n            if (this.hasAttached() && !portal && !this._isInitialized) {\n                return;\n            }\n            if (this.hasAttached()) {\n                super.detach();\n            }\n            if (portal) {\n                super.attach(portal);\n            }\n            this._attachedPortal = portal;\n        }\n        /** Component or view reference that is attached to the portal. */\n        get attachedRef() {\n            return this._attachedRef;\n        }\n        ngOnInit() {\n            this._isInitialized = true;\n        }\n        ngOnDestroy() {\n            super.dispose();\n            this._attachedPortal = null;\n            this._attachedRef = null;\n        }\n        /**\n         * Attach the given ComponentPortal to this PortalOutlet using the ComponentFactoryResolver.\n         *\n         * @param portal Portal to be attached to the portal outlet.\n         * @returns Reference to the created component.\n         */\n        attachComponentPortal(portal) {\n            portal.setAttachedHost(this);\n            // If the portal specifies an origin, use that as the logical location of the component\n            // in the application tree. Otherwise use the location of this PortalOutlet.\n            const viewContainerRef = portal.viewContainerRef != null ?\n                portal.viewContainerRef :\n                this._viewContainerRef;\n            const resolver = portal.componentFactoryResolver || this._componentFactoryResolver;\n            const componentFactory = resolver.resolveComponentFactory(portal.component);\n            const ref = viewContainerRef.createComponent(componentFactory, viewContainerRef.length, portal.injector || viewContainerRef.injector);\n            // If we're using a view container that's different from the injected one (e.g. when the portal\n            // specifies its own) we need to move the component into the outlet, otherwise it'll be rendered\n            // inside of the alternate view container.\n            if (viewContainerRef !== this._viewContainerRef) {\n                this._getRootNode().appendChild(ref.hostView.rootNodes[0]);\n            }\n            super.setDisposeFn(() => ref.destroy());\n            this._attachedPortal = portal;\n            this._attachedRef = ref;\n            this.attached.emit(ref);\n            return ref;\n        }\n        /**\n         * Attach the given TemplatePortal to this PortalHost as an embedded View.\n         * @param portal Portal to be attached.\n         * @returns Reference to the created embedded view.\n         */\n        attachTemplatePortal(portal) {\n            portal.setAttachedHost(this);\n            const viewRef = this._viewContainerRef.createEmbeddedView(portal.templateRef, portal.context);\n            super.setDisposeFn(() => this._viewContainerRef.clear());\n            this._attachedPortal = portal;\n            this._attachedRef = viewRef;\n            this.attached.emit(viewRef);\n            return viewRef;\n        }\n        /** Gets the root node of the portal outlet. */\n        _getRootNode() {\n            const nativeElement = this._viewContainerRef.element.nativeElement;\n            // The directive could be set on a template which will result in a comment\n            // node being the root. Use the comment's parent node if that is the case.\n            return (nativeElement.nodeType === nativeElement.ELEMENT_NODE ?\n                nativeElement : nativeElement.parentNode);\n        }\n    }\n    CdkPortalOutlet.fac = function CdkPortalOutlet_Factory(t) { return new (t || CdkPortalOutlet)(core[\"Mb\" /* directiveInject */](core[\"j\" /* ComponentFactoryResolver */]), core[\"Mb\" /* directiveInject */](core[\"Q\" /* ViewContainerRef */]), core[\"Mb\" /* directiveInject */](common[\"c\" /* DOCUMENT */])); };\n    CdkPortalOutlet.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: CdkPortalOutlet, selectors: [[\"\", \"cdkPortalOutlet\", \"\"]], inputs: { portal: [\"cdkPortalOutlet\", \"portal\"] }, outputs: { attached: \"attached\" }, exportAs: [\"cdkPortalOutlet\"], features: [core[\"xb\" /* InheritDefinitionFeature */]] });\n    return CdkPortalOutlet;\n})();\nlet portal_PortalHostDirective = /*@__PURE__*/ (() => {\n    class PortalHostDirective extends portal_CdkPortalOutlet {\n    }\n    PortalHostDirective.fac = function PortalHostDirective_Factory(t) { return PortalHostDirective_BaseFactory(t || PortalHostDirective); };\n    PortalHostDirective.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: PortalHostDirective, selectors: [[\"\", \"cdkPortalHost\", \"\"], [\"\", \"portalHost\", \"\"]], inputs: { portal: [\"cdkPortalHost\", \"portal\"] }, exportAs: [\"cdkPortalHost\"], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{\n                    provide: portal_CdkPortalOutlet,\n                    useExisting: PortalHostDirective\n                }]), core[\"xb\" /* InheritDefinitionFeature */]] });\n    return PortalHostDirective;\n})();\nconst PortalHostDirective_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Ub\" /* getInheritedFactory */](portal_PortalHostDirective);\nlet portal_PortalModule = /*@__PURE__*/ (() => {\n    class PortalModule {\n    }\n    PortalModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: PortalModule });\n    PortalModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function PortalModule_Factory(t) { return new (t || PortalModule)(); } });\n    return PortalModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](portal_PortalModule, { declarations: [portal_CdkPortal, portal_CdkPortalOutlet, portal_TemplatePortalDirective, portal_PortalHostDirective], exports: [portal_CdkPortal, portal_CdkPortalOutlet, portal_TemplatePortalDirective, portal_PortalHostDirective] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Custom injector to be used when providing custom\n * injection tokens to components inside a portal.\n * @docs-private\n * @deprecated Use `Injector.create` instead.\n * @breaking-change 11.0.0\n */\nclass PortalInjector {\n    constructor(_parentInjector, _customTokens) {\n        this._parentInjector = _parentInjector;\n        this._customTokens = _customTokens;\n    }\n    get(token, notFoundValue) {\n        const value = this._customTokens.get(token);\n        if (typeof value !== 'undefined') {\n            return value;\n        }\n        return this._parentInjector.get(token, notFoundValue);\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=portal.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/bidi.js\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token used to inject the document into Directionality.\n * This is used so that the value can be faked in tests.\n *\n * We can't use the real document in tests because changing the real `dir` causes geometry-based\n * tests in Safari to fail.\n *\n * We also can't re-provide the DOCUMENT token from platform-brower because the unit tests\n * themselves use things like `querySelector` in test code.\n *\n * This token is defined in a separate file from Directionality as a workaround for\n * https://github.com/angular/angular/issues/22559\n *\n * @docs-private\n */\n\nconst DIR_DOCUMENT = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('cdk-dir-doc', {\n    providedIn: 'root',\n    factory: DIR_DOCUMENT_FACTORY,\n});\n/** @docs-private */\nfunction DIR_DOCUMENT_FACTORY() {\n    return Object(core[\"V\" /* inject */])(common[\"c\" /* DOCUMENT */]);\n}\nlet bidi_Directionality = /*@__PURE__*/ (() => {\n    class Directionality {\n        constructor(_document) {\n            /** The current 'ltr' or 'rtl' value. */\n            this.value = 'ltr';\n            /** Stream that emits whenever the 'ltr' / 'rtl' state changes. */\n            this.change = new core[\"n\" /* EventEmitter */]();\n            if (_document) {\n                // TODO: handle 'auto' value -\n                // We still need to account for dir=\"auto\".\n                // It looks like HTMLElemenet.dir is also \"auto\" when that's set to the attribute,\n                // but getComputedStyle return either \"ltr\" or \"rtl\". avoiding getComputedStyle for now\n                const bodyDir = _document.body ? _document.body.dir : null;\n                const htmlDir = _document.documentElement ? _document.documentElement.dir : null;\n                const value = bodyDir || htmlDir;\n                this.value = (value === 'ltr' || value === 'rtl') ? value : 'ltr';\n            }\n        }\n        ngOnDestroy() {\n            this.change.complete();\n        }\n    }\n    Directionality.fac = function Directionality_Factory(t) { return new (t || Directionality)(core[\"Wb\" /* inject */](DIR_DOCUMENT, 8)); };\n    Directionality.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function Directionality_Factory() { return new Directionality(Object(core[\"Wb\" /* inject */])(DIR_DOCUMENT, 8)); }, token: Directionality, providedIn: \"root\" });\n    return Directionality;\n})();\nlet bidi_Dir = /*@__PURE__*/ (() => {\n    class Dir {\n        constructor() {\n            /** Normalized direction that accounts for invalid/unsupported values. */\n            this._dir = 'ltr';\n            /** Whether the `value` has been set to its initial value. */\n            this._isInitialized = false;\n            /** Event emitted when the direction changes. */\n            this.change = new core[\"n\" /* EventEmitter */]();\n        }\n        /** @docs-private */\n        get dir() { return this._dir; }\n        set dir(value) {\n            const old = this._dir;\n            const normalizedValue = value ? value.toLowerCase() : value;\n            this._rawDir = value;\n            this._dir = (normalizedValue === 'ltr' || normalizedValue === 'rtl') ? normalizedValue : 'ltr';\n            if (old !== this._dir && this._isInitialized) {\n                this.change.emit(this._dir);\n            }\n        }\n        /** Current layout direction of the element. */\n        get value() { return this.dir; }\n        /** Initialize once default value has been set. */\n        ngAfterContentInit() {\n            this._isInitialized = true;\n        }\n        ngOnDestroy() {\n            this.change.complete();\n        }\n    }\n    Dir.fac = function Dir_Factory(t) { return new (t || Dir)(); };\n    Dir.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: Dir, selectors: [[\"\", \"dir\", \"\"]], hostVars: 1, hostBindings: function Dir_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Bb\" /* attribute */](\"dir\", ctx._rawDir);\n            }\n        }, inputs: { dir: \"dir\" }, outputs: { change: \"dirChange\" }, exportAs: [\"dir\"], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{ provide: bidi_Directionality, useExisting: Dir }])] });\n    return Dir;\n})();\nlet bidi_BidiModule = /*@__PURE__*/ (() => {\n    class BidiModule {\n    }\n    BidiModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: BidiModule });\n    BidiModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function BidiModule_Factory(t) { return new (t || BidiModule)(); } });\n    return BidiModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](bidi_BidiModule, { declarations: [bidi_Dir], exports: [bidi_Dir] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=bidi.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/fesm2015/cdk.js\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Current version of the Angular Component Development Kit. */\nconst VERSION = /*@__PURE__*/ new core[\"P\" /* Version */]('11.2.13');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n//# sourceMappingURL=cdk.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/startWith.js\nvar startWith = __webpack_require__(\"JX91\");\n\n// EXTERNAL MODULE: ./node_modules/@angular/platform-browser/__ivy_ngcc__/fesm2015/animations.js + 1 modules\nvar animations = __webpack_require__(\"R1ws\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/core.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Current version of Angular Material. */\n\n\n\n\nconst _c0 = [\"*\", [[\"mat-option\"], [\"ng-container\"]]];\nconst _c1 = [\"*\", \"mat-option, ng-container\"];\nfunction MatOption_mat_pseudo_checkbox_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Nb\" /* element */](0, \"mat-pseudo-checkbox\", 4);\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"bc\" /* nextContext */]();\n        core[\"ec\" /* property */](\"state\", ctx_r0.selected ? \"checked\" : \"unchecked\")(\"disabled\", ctx_r0.disabled);\n    }\n}\nfunction MatOption_span_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"span\", 5);\n        core[\"uc\" /* text */](1);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r1 = core[\"bc\" /* nextContext */]();\n        core[\"Ab\" /* advance */](1);\n        core[\"wc\" /* textInterpolate1 */](\"(\", ctx_r1.group.label, \")\");\n    }\n}\nconst _c2 = [\"*\"];\nconst core_VERSION = /*@__PURE__*/ new core[\"P\" /* Version */]('11.2.13');\nlet AnimationCurves = /*@__PURE__*/ (() => {\n    class AnimationCurves {\n    }\n    AnimationCurves.STANDARD_CURVE = 'cubic-bezier(0.4,0.0,0.2,1)';\n    AnimationCurves.DECELERATION_CURVE = 'cubic-bezier(0.0,0.0,0.2,1)';\n    AnimationCurves.ACCELERATION_CURVE = 'cubic-bezier(0.4,0.0,1,1)';\n    AnimationCurves.SHARP_CURVE = 'cubic-bezier(0.4,0.0,0.6,1)';\n    return AnimationCurves;\n})();\nlet AnimationDurations = /*@__PURE__*/ (() => {\n    class AnimationDurations {\n    }\n    AnimationDurations.COMPLEX = '375ms';\n    AnimationDurations.ENTERING = '225ms';\n    AnimationDurations.EXITING = '195ms';\n    return AnimationDurations;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Private version constant to circumvent test/build issues,\n// i.e. avoid core to depend on the @angular/material primary entry-point\n// Can be removed once the Material primary entry-point no longer\n// re-exports all secondary entry-points\nconst VERSION$1 = /*@__PURE__*/ new core[\"P\" /* Version */]('11.2.13');\n/** @docs-private */\nfunction MATERIAL_SANITY_CHECKS_FACTORY() {\n    return true;\n}\n/** Injection token that configures whether the Material sanity checks are enabled. */\nconst MATERIAL_SANITY_CHECKS = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('mat-sanity-checks', {\n    providedIn: 'root',\n    factory: MATERIAL_SANITY_CHECKS_FACTORY,\n});\nlet core_MatCommonModule = /*@__PURE__*/ (() => {\n    class MatCommonModule {\n        constructor(highContrastModeDetector, sanityChecks, document) {\n            /** Whether we've done the global sanity checks (e.g. a theme is loaded, there is a doctype). */\n            this._hasDoneGlobalChecks = false;\n            this._document = document;\n            // While A11yModule also does this, we repeat it here to avoid importing A11yModule\n            // in MatCommonModule.\n            highContrastModeDetector._applyBodyHighContrastModeCssClasses();\n            // Note that `_sanityChecks` is typed to `any`, because AoT\n            // throws an error if we use the `SanityChecks` type directly.\n            this._sanityChecks = sanityChecks;\n            if (!this._hasDoneGlobalChecks) {\n                this._checkDoctypeIsDefined();\n                this._checkThemeIsPresent();\n                this._checkCdkVersionMatch();\n                this._hasDoneGlobalChecks = true;\n            }\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            const win = this._document.defaultView || window;\n            return typeof win === 'object' && win ? win : null;\n        }\n        /** Whether any sanity checks are enabled. */\n        _checksAreEnabled() {\n            // TODO(crisbeto): we can't use `ngDevMode` here yet, because ViewEngine apps might not support\n            // it. Since these checks can have performance implications and they aren't tree shakeable\n            // in their current form, we can leave the `isDevMode` check in for now.\n            // tslint:disable-next-line:ban\n            return Object(core[\"W\" /* isDevMode */])() && !this._isTestEnv();\n        }\n        /** Whether the code is running in tests. */\n        _isTestEnv() {\n            const window = this._getWindow();\n            return window && (window.__karma__ || window.jasmine);\n        }\n        _checkDoctypeIsDefined() {\n            const isEnabled = this._checksAreEnabled() &&\n                (this._sanityChecks === true || this._sanityChecks.doctype);\n            if (isEnabled && !this._document.doctype) {\n                console.warn('Current document does not have a doctype. This may cause ' +\n                    'some Angular Material components not to behave as expected.');\n            }\n        }\n        _checkThemeIsPresent() {\n            // We need to assert that the `body` is defined, because these checks run very early\n            // and the `body` won't be defined if the consumer put their scripts in the `head`.\n            const isDisabled = !this._checksAreEnabled() ||\n                (this._sanityChecks === false || !this._sanityChecks.theme);\n            if (isDisabled || !this._document.body || typeof getComputedStyle !== 'function') {\n                return;\n            }\n            const testElement = this._document.createElement('div');\n            testElement.classList.add('mat-theme-loaded-marker');\n            this._document.body.appendChild(testElement);\n            const computedStyle = getComputedStyle(testElement);\n            // In some situations the computed style of the test element can be null. For example in\n            // Firefox, the computed style is null if an application is running inside of a hidden iframe.\n            // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397\n            if (computedStyle && computedStyle.display !== 'none') {\n                console.warn('Could not find Angular Material core theme. Most Material ' +\n                    'components may not work as expected. For more info refer ' +\n                    'to the theming guide: https://material.angular.io/guide/theming');\n            }\n            this._document.body.removeChild(testElement);\n        }\n        /** Checks whether the material version matches the cdk version */\n        _checkCdkVersionMatch() {\n            const isEnabled = this._checksAreEnabled() &&\n                (this._sanityChecks === true || this._sanityChecks.version);\n            if (isEnabled && VERSION$1.full !== VERSION.full) {\n                console.warn('The Angular Material version (' + VERSION$1.full + ') does not match ' +\n                    'the Angular CDK version (' + VERSION.full + ').\\n' +\n                    'Please ensure the versions of these two packages exactly match.');\n            }\n        }\n    }\n    MatCommonModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: MatCommonModule });\n    MatCommonModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function MatCommonModule_Factory(t) { return new (t || MatCommonModule)(core[\"Wb\" /* inject */](a11y_HighContrastModeDetector), core[\"Wb\" /* inject */](MATERIAL_SANITY_CHECKS, 8), core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */])); }, imports: [[bidi_BidiModule], bidi_BidiModule] });\n    return MatCommonModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](core_MatCommonModule, { imports: function () { return [bidi_BidiModule]; }, exports: function () { return [bidi_BidiModule]; } }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mixin to augment a directive with a `disabled` property. */\nfunction mixinDisabled(base) {\n    return class extends base {\n        constructor(...args) {\n            super(...args);\n            this._disabled = false;\n        }\n        get disabled() { return this._disabled; }\n        set disabled(value) { this._disabled = coerceBooleanProperty(value); }\n    };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mixin to augment a directive with a `color` property. */\nfunction mixinColor(base, defaultColor) {\n    return class extends base {\n        constructor(...args) {\n            super(...args);\n            this.defaultColor = defaultColor;\n            // Set the default color that can be specified from the mixin.\n            this.color = defaultColor;\n        }\n        get color() { return this._color; }\n        set color(value) {\n            const colorPalette = value || this.defaultColor;\n            if (colorPalette !== this._color) {\n                if (this._color) {\n                    this._elementRef.nativeElement.classList.remove(`mat-${this._color}`);\n                }\n                if (colorPalette) {\n                    this._elementRef.nativeElement.classList.add(`mat-${colorPalette}`);\n                }\n                this._color = colorPalette;\n            }\n        }\n    };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mixin to augment a directive with a `disableRipple` property. */\nfunction mixinDisableRipple(base) {\n    class Mixin extends base {\n        constructor(...args) {\n            super(...args);\n            this._disableRipple = false;\n        }\n        /** Whether the ripple effect is disabled or not. */\n        get disableRipple() { return this._disableRipple; }\n        set disableRipple(value) { this._disableRipple = coerceBooleanProperty(value); }\n    }\n    // Since we don't directly extend from `base` with it's original types, and we instruct\n    // TypeScript that `T` actually is instantiatable through `new`, the types don't overlap.\n    // This is a limitation in TS as abstract classes cannot be typed properly dynamically.\n    return Mixin;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mixin to augment a directive with a `tabIndex` property. */\nfunction mixinTabIndex(base, defaultTabIndex = 0) {\n    // Note: We cast `base` to `unknown` and then `Constructor`. It could be an abstract class,\n    // but given we `extend` it from another class, we can assume a constructor being accessible.\n    class Mixin extends base {\n        constructor(...args) {\n            super(...args);\n            this._tabIndex = defaultTabIndex;\n            this.defaultTabIndex = defaultTabIndex;\n        }\n        get tabIndex() { return this.disabled ? -1 : this._tabIndex; }\n        set tabIndex(value) {\n            // If the specified tabIndex value is null or undefined, fall back to the default value.\n            this._tabIndex = value != null ? coerceNumberProperty(value) : this.defaultTabIndex;\n        }\n    }\n    // Since we don't directly extend from `base` with it's original types, and we instruct\n    // TypeScript that `T` actually is instantiatable through `new`, the types don't overlap.\n    // This is a limitation in TS as abstract classes cannot be typed properly dynamically.\n    return Mixin;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Mixin to augment a directive with updateErrorState method.\n * For component with `errorState` and need to update `errorState`.\n */\nfunction mixinErrorState(base) {\n    return class extends base {\n        constructor(...args) {\n            super(...args);\n            /** Whether the component is in an error state. */\n            this.errorState = false;\n            /**\n             * Stream that emits whenever the state of the input changes such that the wrapping\n             * `MatFormField` needs to run change detection.\n             */\n            this.stateChanges = new Subject[\"a\" /* Subject */]();\n        }\n        updateErrorState() {\n            const oldState = this.errorState;\n            const parent = this._parentFormGroup || this._parentForm;\n            const matcher = this.errorStateMatcher || this._defaultErrorStateMatcher;\n            const control = this.ngControl ? this.ngControl.control : null;\n            const newState = matcher.isErrorState(control, parent);\n            if (newState !== oldState) {\n                this.errorState = newState;\n                this.stateChanges.next();\n            }\n        }\n    };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Mixin to augment a directive with an initialized property that will emits when ngOnInit ends. */\nfunction mixinInitialized(base) {\n    return class extends base {\n        constructor(...args) {\n            super(...args);\n            /** Whether this directive has been marked as initialized. */\n            this._isInitialized = false;\n            /**\n             * List of subscribers that subscribed before the directive was initialized. Should be notified\n             * during _markInitialized. Set to null after pending subscribers are notified, and should\n             * not expect to be populated after.\n             */\n            this._pendingSubscribers = [];\n            /**\n             * Observable stream that emits when the directive initializes. If already initialized, the\n             * subscriber is stored to be notified once _markInitialized is called.\n             */\n            this.initialized = new Observable[\"a\" /* Observable */](subscriber => {\n                // If initialized, immediately notify the subscriber. Otherwise store the subscriber to notify\n                // when _markInitialized is called.\n                if (this._isInitialized) {\n                    this._notifySubscriber(subscriber);\n                }\n                else {\n                    this._pendingSubscribers.push(subscriber);\n                }\n            });\n        }\n        /**\n         * Marks the state as initialized and notifies pending subscribers. Should be called at the end\n         * of ngOnInit.\n         * @docs-private\n         */\n        _markInitialized() {\n            if (this._isInitialized && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('This directive has already been marked as initialized and ' +\n                    'should not be called twice.');\n            }\n            this._isInitialized = true;\n            this._pendingSubscribers.forEach(this._notifySubscriber);\n            this._pendingSubscribers = null;\n        }\n        /** Emits and completes the subscriber stream (should only emit once). */\n        _notifySubscriber(subscriber) {\n            subscriber.next();\n            subscriber.complete();\n        }\n    };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** InjectionToken for datepicker that can be used to override default locale code. */\nconst MAT_DATE_LOCALE = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MAT_DATE_LOCALE', {\n    providedIn: 'root',\n    factory: MAT_DATE_LOCALE_FACTORY,\n});\n/** @docs-private */\nfunction MAT_DATE_LOCALE_FACTORY() {\n    return Object(core[\"V\" /* inject */])(core[\"v\" /* LOCALE_ID */]);\n}\n/** Adapts type `D` to be usable as a date by cdk-based components that work with dates. */\nclass core_DateAdapter {\n    constructor() {\n        this._localeChanges = new Subject[\"a\" /* Subject */]();\n        /** A stream that emits when the locale changes. */\n        this.localeChanges = this._localeChanges;\n    }\n    /**\n     * Given a potential date object, returns that same date object if it is\n     * a valid date, or `null` if it's not a valid date.\n     * @param obj The object to check.\n     * @returns A date or `null`.\n     */\n    getValidDateOrNull(obj) {\n        return this.isDateInstance(obj) && this.isValid(obj) ? obj : null;\n    }\n    /**\n     * Attempts to deserialize a value to a valid date object. This is different from parsing in that\n     * deserialize should only accept non-ambiguous, locale-independent formats (e.g. a ISO 8601\n     * string). The default implementation does not allow any deserialization, it simply checks that\n     * the given value is already a valid date object or null. The `<mat-datepicker>` will call this\n     * method on all of its `@Input()` properties that accept dates. It is therefore possible to\n     * support passing values from your backend directly to these properties by overriding this method\n     * to also deserialize the format used by your backend.\n     * @param value The value to be deserialized into a date object.\n     * @returns The deserialized date object, either a valid date, null if the value can be\n     *     deserialized into a null date (e.g. the empty string), or an invalid date.\n     */\n    deserialize(value) {\n        if (value == null || this.isDateInstance(value) && this.isValid(value)) {\n            return value;\n        }\n        return this.invalid();\n    }\n    /**\n     * Sets the locale used for all dates.\n     * @param locale The new locale.\n     */\n    setLocale(locale) {\n        this.locale = locale;\n        this._localeChanges.next();\n    }\n    /**\n     * Compares two dates.\n     * @param first The first date to compare.\n     * @param second The second date to compare.\n     * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n     *     a number greater than 0 if the first date is later.\n     */\n    compareDate(first, second) {\n        return this.getYear(first) - this.getYear(second) ||\n            this.getMonth(first) - this.getMonth(second) ||\n            this.getDate(first) - this.getDate(second);\n    }\n    /**\n     * Checks if two dates are equal.\n     * @param first The first date to check.\n     * @param second The second date to check.\n     * @returns Whether the two dates are equal.\n     *     Null dates are considered equal to other null dates.\n     */\n    sameDate(first, second) {\n        if (first && second) {\n            let firstValid = this.isValid(first);\n            let secondValid = this.isValid(second);\n            if (firstValid && secondValid) {\n                return !this.compareDate(first, second);\n            }\n            return firstValid == secondValid;\n        }\n        return first == second;\n    }\n    /**\n     * Clamp the given date between min and max dates.\n     * @param date The date to clamp.\n     * @param min The minimum value to allow. If null or omitted no min is enforced.\n     * @param max The maximum value to allow. If null or omitted no max is enforced.\n     * @returns `min` if `date` is less than `min`, `max` if date is greater than `max`,\n     *     otherwise `date`.\n     */\n    clampDate(date, min, max) {\n        if (min && this.compareDate(date, min) < 0) {\n            return min;\n        }\n        if (max && this.compareDate(date, max) > 0) {\n            return max;\n        }\n        return date;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAT_DATE_FORMATS = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('mat-date-formats');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(mmalerba): Remove when we no longer support safari 9.\n/** Whether the browser supports the Intl API. */\nlet SUPPORTS_INTL_API;\n// We need a try/catch around the reference to `Intl`, because accessing it in some cases can\n// cause IE to throw. These cases are tied to particular versions of Windows and can happen if\n// the consumer is providing a polyfilled `Map`. See:\n// https://github.com/Microsoft/ChakraCore/issues/3189\n// https://github.com/angular/components/issues/15687\ntry {\n    SUPPORTS_INTL_API = typeof Intl != 'undefined';\n}\ncatch (_a) {\n    SUPPORTS_INTL_API = false;\n}\n/** The default month names to use if Intl API is not available. */\nconst DEFAULT_MONTH_NAMES = {\n    'long': [\n        'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September',\n        'October', 'November', 'December'\n    ],\n    'short': ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n    'narrow': ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D']\n};\nconst 0 = i => String(i + 1);\n/** The default date names to use if Intl API is not available. */\nconst DEFAULT_DATE_NAMES = /*@__PURE__*/ range(31, 0);\n/** The default day of the week names to use if Intl API is not available. */\nconst DEFAULT_DAY_OF_WEEK_NAMES = {\n    'long': ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n    'short': ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n    'narrow': ['S', 'M', 'T', 'W', 'T', 'F', 'S']\n};\n/**\n * Matches strings that have the form of a valid RFC 3339 string\n * (https://tools.ietf.org/html/rfc3339). Note that the string may not actually be a valid date\n * because the regex will match strings an with out of bounds month, date, etc.\n */\nconst ISO_8601_REGEX = /^\\d{4}-\\d{2}-\\d{2}(?:T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|(?:(?:\\+|-)\\d{2}:\\d{2}))?)?$/;\n/** Creates an array and fills it with values. */\nfunction range(length, valueFunction) {\n    const valuesArray = Array(length);\n    for (let i = 0; i < length; i++) {\n        valuesArray[i] = valueFunction(i);\n    }\n    return valuesArray;\n}\nlet core_NativeDateAdapter = /*@__PURE__*/ (() => {\n    class NativeDateAdapter extends core_DateAdapter {\n        constructor(matDateLocale, platform) {\n            super();\n            /**\n             * Whether to use `timeZone: 'utc'` with `Intl.DateTimeFormat` when formatting dates.\n             * Without this `Intl.DateTimeFormat` sometimes chooses the wrong timeZone, which can throw off\n             * the result. (e.g. in the en-US locale `new Date(1800, 7, 14).toLocaleDateString()`\n             * will produce `'8/13/1800'`.\n             *\n             * TODO(mmalerba): drop this variable. It's not being used in the code right now. We're now\n             * getting the string representation of a Date object from its utc representation. We're keeping\n             * it here for sometime, just for precaution, in case we decide to revert some of these changes\n             * though.\n             */\n            this.useUtcForDisplay = true;\n            super.setLocale(matDateLocale);\n            // IE does its own time zone correction, so we disable this on IE.\n            this.useUtcForDisplay = !platform.TRIDENT;\n            this._clampDate = platform.TRIDENT || platform.EDGE;\n        }\n        getYear(date) {\n            return date.getFullYear();\n        }\n        getMonth(date) {\n            return date.getMonth();\n        }\n        getDate(date) {\n            return date.getDate();\n        }\n        getDayOfWeek(date) {\n            return date.getDay();\n        }\n        getMonthNames(style) {\n            if (SUPPORTS_INTL_API) {\n                const dtf = new Intl.DateTimeFormat(this.locale, { month: style, timeZone: 'utc' });\n                return range(12, i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, i, 1))));\n            }\n            return DEFAULT_MONTH_NAMES[style];\n        }\n        getDateNames() {\n            if (SUPPORTS_INTL_API) {\n                const dtf = new Intl.DateTimeFormat(this.locale, { day: 'numeric', timeZone: 'utc' });\n                return range(31, i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, 0, i + 1))));\n            }\n            return DEFAULT_DATE_NAMES;\n        }\n        getDayOfWeekNames(style) {\n            if (SUPPORTS_INTL_API) {\n                const dtf = new Intl.DateTimeFormat(this.locale, { weekday: style, timeZone: 'utc' });\n                return range(7, i => this._stripDirectionalityCharacters(this._format(dtf, new Date(2017, 0, i + 1))));\n            }\n            return DEFAULT_DAY_OF_WEEK_NAMES[style];\n        }\n        getYearName(date) {\n            if (SUPPORTS_INTL_API) {\n                const dtf = new Intl.DateTimeFormat(this.locale, { year: 'numeric', timeZone: 'utc' });\n                return this._stripDirectionalityCharacters(this._format(dtf, date));\n            }\n            return String(this.getYear(date));\n        }\n        getFirstDayOfWeek() {\n            // We can't tell using native JS Date what the first day of the week is, we default to Sunday.\n            return 0;\n        }\n        getNumDaysInMonth(date) {\n            return this.getDate(this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + 1, 0));\n        }\n        clone(date) {\n            return new Date(date.getTime());\n        }\n        createDate(year, month, date) {\n            if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                // Check for invalid month and date (except upper bound on date which we have to check after\n                // creating the Date).\n                if (month < 0 || month > 11) {\n                    throw Error(`Invalid month index \"${month}\". Month index has to be between 0 and 11.`);\n                }\n                if (date < 1) {\n                    throw Error(`Invalid date \"${date}\". Date has to be greater than 0.`);\n                }\n            }\n            let result = this._createDateWithOverflow(year, month, date);\n            // Check that the date wasn't above the upper bound for the month, causing the month to overflow\n            if (result.getMonth() != month && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error(`Invalid date \"${date}\" for month with index \"${month}\".`);\n            }\n            return result;\n        }\n        today() {\n            return new Date();\n        }\n        parse(value) {\n            // We have no way using the native JS Date to set the parse format or locale, so we ignore these\n            // parameters.\n            if (typeof value == 'number') {\n                return new Date(value);\n            }\n            return value ? new Date(Date.parse(value)) : null;\n        }\n        format(date, displayFormat) {\n            if (!this.isValid(date)) {\n                throw Error('NativeDateAdapter: Cannot format invalid date.');\n            }\n            if (SUPPORTS_INTL_API) {\n                // On IE and Edge the i18n API will throw a hard error that can crash the entire app\n                // if we attempt to format a date whose year is less than 1 or greater than 9999.\n                if (this._clampDate && (date.getFullYear() < 1 || date.getFullYear() > 9999)) {\n                    date = this.clone(date);\n                    date.setFullYear(Math.max(1, Math.min(9999, date.getFullYear())));\n                }\n                displayFormat = Object.assign(Object.assign({}, displayFormat), { timeZone: 'utc' });\n                const dtf = new Intl.DateTimeFormat(this.locale, displayFormat);\n                return this._stripDirectionalityCharacters(this._format(dtf, date));\n            }\n            return this._stripDirectionalityCharacters(date.toDateString());\n        }\n        addCalendarYears(date, years) {\n            return this.addCalendarMonths(date, years * 12);\n        }\n        addCalendarMonths(date, months) {\n            let newDate = this._createDateWithOverflow(this.getYear(date), this.getMonth(date) + months, this.getDate(date));\n            // It's possible to wind up in the wrong month if the original month has more days than the new\n            // month. In this case we want to go to the last day of the desired month.\n            // Note: the additional + 12 % 12 ensures we end up with a positive number, since JS % doesn't\n            // guarantee this.\n            if (this.getMonth(newDate) != ((this.getMonth(date) + months) % 12 + 12) % 12) {\n                newDate = this._createDateWithOverflow(this.getYear(newDate), this.getMonth(newDate), 0);\n            }\n            return newDate;\n        }\n        addCalendarDays(date, days) {\n            return this._createDateWithOverflow(this.getYear(date), this.getMonth(date), this.getDate(date) + days);\n        }\n        toIso8601(date) {\n            return [\n                date.getUTCFullYear(),\n                this._2digit(date.getUTCMonth() + 1),\n                this._2digit(date.getUTCDate())\n            ].join('-');\n        }\n        /**\n         * Returns the given value if given a valid Date or null. Deserializes valid ISO 8601 strings\n         * (https://www.ietf.org/rfc/rfc3339.txt) into valid Dates and empty string into null. Returns an\n         * invalid date for all other values.\n         */\n        deserialize(value) {\n            if (typeof value === 'string') {\n                if (!value) {\n                    return null;\n                }\n                // The `Date` constructor accepts formats other than ISO 8601, so we need to make sure the\n                // string is the right format first.\n                if (ISO_8601_REGEX.test(value)) {\n                    let date = new Date(value);\n                    if (this.isValid(date)) {\n                        return date;\n                    }\n                }\n            }\n            return super.deserialize(value);\n        }\n        isDateInstance(obj) {\n            return obj instanceof Date;\n        }\n        isValid(date) {\n            return !isNaN(date.getTime());\n        }\n        invalid() {\n            return new Date(NaN);\n        }\n        /** Creates a date but allows the month and date to overflow. */\n        _createDateWithOverflow(year, month, date) {\n            // Passing the year to the constructor causes year numbers <100 to be converted to 19xx.\n            // To work around this we use `setFullYear` and `setHours` instead.\n            const d = new Date();\n            d.setFullYear(year, month, date);\n            d.setHours(0, 0, 0, 0);\n            return d;\n        }\n        /**\n         * Pads a number to make it two digits.\n         * @param n The number to pad.\n         * @returns The padded number.\n         */\n        _2digit(n) {\n            return ('00' + n).slice(-2);\n        }\n        /**\n         * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while\n         * other browsers do not. We remove them to make output consistent and because they interfere with\n         * date parsing.\n         * @param str The string to strip direction characters from.\n         * @returns The stripped string.\n         */\n        _stripDirectionalityCharacters(str) {\n            return str.replace(/[\\u200e\\u200f]/g, '');\n        }\n        /**\n         * When converting Date object to string, javascript built-in functions may return wrong\n         * results because it applies its internal DST rules. The DST rules around the world change\n         * very frequently, and the current valid rule is not always valid in previous years though.\n         * We work around this problem building a new Date object which has its internal UTC\n         * representation with the local date and time.\n         * @param dtf Intl.DateTimeFormat object, containg the desired string format. It must have\n         *    timeZone set to 'utc' to work fine.\n         * @param date Date from which we want to get the string representation according to dtf\n         * @returns A Date object with its UTC representation based on the passed in date info\n         */\n        _format(dtf, date) {\n            // Passing the year to the constructor causes year numbers <100 to be converted to 19xx.\n            // To work around this we use `setUTCFullYear` and `setUTCHours` instead.\n            const d = new Date();\n            d.setUTCFullYear(date.getFullYear(), date.getMonth(), date.getDate());\n            d.setUTCHours(date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n            return dtf.format(d);\n        }\n    }\n    NativeDateAdapter.fac = function NativeDateAdapter_Factory(t) { return new (t || NativeDateAdapter)(core[\"Wb\" /* inject */](MAT_DATE_LOCALE, 8), core[\"Wb\" /* inject */](platform_Platform)); };\n    NativeDateAdapter.prov = /*@__PURE__*/ core[\"Ib\" /* defineInjectable */]({ token: NativeDateAdapter, factory: NativeDateAdapter.fac });\n    return NativeDateAdapter;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst MAT_NATIVE_DATE_FORMATS = {\n    parse: {\n        dateInput: null,\n    },\n    display: {\n        dateInput: { year: 'numeric', month: 'numeric', day: 'numeric' },\n        monthYearLabel: { year: 'numeric', month: 'short' },\n        dateA11yLabel: { year: 'numeric', month: 'long', day: 'numeric' },\n        monthYearA11yLabel: { year: 'numeric', month: 'long' },\n    }\n};\nlet core_NativeDateModule = /*@__PURE__*/ (() => {\n    class NativeDateModule {\n    }\n    NativeDateModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: NativeDateModule });\n    NativeDateModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function NativeDateModule_Factory(t) { return new (t || NativeDateModule)(); }, providers: [\n            { provide: core_DateAdapter, useClass: core_NativeDateAdapter },\n        ], imports: [[platform_PlatformModule]] });\n    return NativeDateModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](core_NativeDateModule, { imports: function () { return [platform_PlatformModule]; } }); })();\nconst 0$1 = MAT_NATIVE_DATE_FORMATS;\nlet core_MatNativeDateModule = /*@__PURE__*/ (() => {\n    class MatNativeDateModule {\n    }\n    MatNativeDateModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: MatNativeDateModule });\n    MatNativeDateModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function MatNativeDateModule_Factory(t) { return new (t || MatNativeDateModule)(); }, providers: [{ provide: MAT_DATE_FORMATS, useValue: 0$1 }], imports: [[core_NativeDateModule]] });\n    return MatNativeDateModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](core_MatNativeDateModule, { imports: [core_NativeDateModule] }); })();\nlet core_ShowOnDirtyErrorStateMatcher = /*@__PURE__*/ (() => {\n    class ShowOnDirtyErrorStateMatcher {\n        isErrorState(control, form) {\n            return !!(control && control.invalid && (control.dirty || (form && form.submitted)));\n        }\n    }\n    ShowOnDirtyErrorStateMatcher.fac = function ShowOnDirtyErrorStateMatcher_Factory(t) { return new (t || ShowOnDirtyErrorStateMatcher)(); };\n    ShowOnDirtyErrorStateMatcher.prov = /*@__PURE__*/ core[\"Ib\" /* defineInjectable */]({ token: ShowOnDirtyErrorStateMatcher, factory: ShowOnDirtyErrorStateMatcher.fac });\n    return ShowOnDirtyErrorStateMatcher;\n})();\nlet core_ErrorStateMatcher = /*@__PURE__*/ (() => {\n    class ErrorStateMatcher {\n        isErrorState(control, form) {\n            return !!(control && control.invalid && (control.touched || (form && form.submitted)));\n        }\n    }\n    ErrorStateMatcher.fac = function ErrorStateMatcher_Factory(t) { return new (t || ErrorStateMatcher)(); };\n    ErrorStateMatcher.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function ErrorStateMatcher_Factory() { return new ErrorStateMatcher(); }, token: ErrorStateMatcher, providedIn: \"root\" });\n    return ErrorStateMatcher;\n})();\nlet core_MatLine = /*@__PURE__*/ (() => {\n    class MatLine {\n    }\n    MatLine.fac = function MatLine_Factory(t) { return new (t || MatLine)(); };\n    MatLine.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatLine, selectors: [[\"\", \"mat-line\", \"\"], [\"\", \"matLine\", \"\"]], hostAttrs: [1, \"mat-line\"] });\n    return MatLine;\n})();\n/**\n * Helper that takes a query list of lines and sets the correct class on the host.\n * @docs-private\n */\nfunction setLines(lines, element, prefix = 'mat') {\n    // Note: doesn't need to unsubscribe, because `changes`\n    // gets completed by Angular when the view is destroyed.\n    lines.changes.pipe(Object(startWith[\"a\" /* startWith */])(lines)).subscribe(({ length }) => {\n        setClass(element, `${prefix}-2-line`, false);\n        setClass(element, `${prefix}-3-line`, false);\n        setClass(element, `${prefix}-multi-line`, false);\n        if (length === 2 || length === 3) {\n            setClass(element, `${prefix}-${length}-line`, true);\n        }\n        else if (length > 3) {\n            setClass(element, `${prefix}-multi-line`, true);\n        }\n    });\n}\n/** Adds or removes a class from an element. */\nfunction setClass(element, className, isAdd) {\n    const classList = element.nativeElement.classList;\n    isAdd ? classList.add(className) : classList.remove(className);\n}\nlet core_MatLineModule = /*@__PURE__*/ (() => {\n    class MatLineModule {\n    }\n    MatLineModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: MatLineModule });\n    MatLineModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function MatLineModule_Factory(t) { return new (t || MatLineModule)(); }, imports: [[core_MatCommonModule], core_MatCommonModule] });\n    return MatLineModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](core_MatLineModule, { declarations: [core_MatLine], imports: [core_MatCommonModule], exports: [core_MatLine, core_MatCommonModule] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Reference to a previously launched ripple element.\n */\nclass RippleRef {\n    constructor(_renderer, \n    /** Reference to the ripple HTML element. */\n    element, \n    /** Ripple configuration used for the ripple. */\n    config) {\n        this._renderer = _renderer;\n        this.element = element;\n        this.config = config;\n        /** Current state of the ripple. */\n        this.state = 3 /* HIDDEN */;\n    }\n    /** Fades out the ripple element. */\n    fadeOut() {\n        this._renderer.fadeOutRipple(this);\n    }\n}\n/**\n * Default ripple animation configuration for ripples without an explicit\n * animation config specified.\n */\nconst defaultRippleAnimationConfig = {\n    enterDuration: 450,\n    exitDuration: 400\n};\n/**\n * Timeout for ignoring mouse events. Mouse events will be temporary ignored after touch\n * events to avoid synthetic mouse events.\n */\nconst ignoreMouseEventsTimeout = 800;\n/** Options that apply to all the event listeners that are bound by the ripple renderer. */\nconst passiveEventOptions = /*@__PURE__*/ normalizePassiveListenerOptions({ passive: true });\n/** Events that signal that the pointer is down. */\nconst pointerDownEvents = ['mousedown', 'touchstart'];\n/** Events that signal that the pointer is up. */\nconst pointerUpEvents = ['mouseup', 'mouseleave', 'touchend', 'touchcancel'];\n/**\n * Helper service that performs DOM manipulations. Not intended to be used outside this module.\n * The constructor takes a reference to the ripple directive's host element and a map of DOM\n * event handlers to be installed on the element that triggers ripple animations.\n * This will eventually become a custom renderer once Angular support exists.\n * @docs-private\n */\nclass core_RippleRenderer {\n    constructor(_target, _ngZone, elementOrElementRef, platform) {\n        this._target = _target;\n        this._ngZone = _ngZone;\n        /** Whether the pointer is currently down or not. */\n        this._isPointerDown = false;\n        /** Set of currently active ripple references. */\n        this._activeRipples = new Set();\n        /** Whether pointer-up event listeners have been registered. */\n        this._pointerUpEventsRegistered = false;\n        // Only do anything if we're on the browser.\n        if (platform.isBrowser) {\n            this._containerElement = coerceElement(elementOrElementRef);\n        }\n    }\n    /**\n     * Fades in a ripple at the given coordinates.\n     * @param x Coordinate within the element, along the X axis at which to start the ripple.\n     * @param y Coordinate within the element, along the Y axis at which to start the ripple.\n     * @param config Extra ripple options.\n     */\n    fadeInRipple(x, y, config = {}) {\n        const containerRect = this._containerRect =\n            this._containerRect || this._containerElement.getBoundingClientRect();\n        const animationConfig = Object.assign(Object.assign({}, defaultRippleAnimationConfig), config.animation);\n        if (config.centered) {\n            x = containerRect.left + containerRect.width / 2;\n            y = containerRect.top + containerRect.height / 2;\n        }\n        const radius = config.radius || distanceToFurthestCorner(x, y, containerRect);\n        const offsetX = x - containerRect.left;\n        const offsetY = y - containerRect.top;\n        const duration = animationConfig.enterDuration;\n        const ripple = document.createElement('div');\n        ripple.classList.add('mat-ripple-element');\n        ripple.style.left = `${offsetX - radius}px`;\n        ripple.style.top = `${offsetY - radius}px`;\n        ripple.style.height = `${radius * 2}px`;\n        ripple.style.width = `${radius * 2}px`;\n        // If a custom color has been specified, set it as inline style. If no color is\n        // set, the default color will be applied through the ripple theme styles.\n        if (config.color != null) {\n            ripple.style.backgroundColor = config.color;\n        }\n        ripple.style.transitionDuration = `${duration}ms`;\n        this._containerElement.appendChild(ripple);\n        // By default the browser does not recalculate the styles of dynamically created\n        // ripple elements. This is critical because then the `scale` would not animate properly.\n        enforceStyleRecalculation(ripple);\n        ripple.style.transform = 'scale(1)';\n        // Exposed reference to the ripple that will be returned.\n        const rippleRef = new RippleRef(this, ripple, config);\n        rippleRef.state = 0 /* FADING_IN */;\n        // Add the ripple reference to the list of all active ripples.\n        this._activeRipples.add(rippleRef);\n        if (!config.persistent) {\n            this._mostRecentTransientRipple = rippleRef;\n        }\n        // Wait for the ripple element to be completely faded in.\n        // Once it's faded in, the ripple can be hidden immediately if the mouse is released.\n        this._runTimeoutOutsideZone(() => {\n            const isMostRecentTransientRipple = rippleRef === this._mostRecentTransientRipple;\n            rippleRef.state = 1 /* VISIBLE */;\n            // When the timer runs out while the user has kept their pointer down, we want to\n            // keep only the persistent ripples and the latest transient ripple. We do this,\n            // because we don't want stacked transient ripples to appear after their enter\n            // animation has finished.\n            if (!config.persistent && (!isMostRecentTransientRipple || !this._isPointerDown)) {\n                rippleRef.fadeOut();\n            }\n        }, duration);\n        return rippleRef;\n    }\n    /** Fades out a ripple reference. */\n    fadeOutRipple(rippleRef) {\n        const wasActive = this._activeRipples.delete(rippleRef);\n        if (rippleRef === this._mostRecentTransientRipple) {\n            this._mostRecentTransientRipple = null;\n        }\n        // Clear out the cached bounding rect if we have no more ripples.\n        if (!this._activeRipples.size) {\n            this._containerRect = null;\n        }\n        // For ripples that are not active anymore, don't re-run the fade-out animation.\n        if (!wasActive) {\n            return;\n        }\n        const rippleEl = rippleRef.element;\n        const animationConfig = Object.assign(Object.assign({}, defaultRippleAnimationConfig), rippleRef.config.animation);\n        rippleEl.style.transitionDuration = `${animationConfig.exitDuration}ms`;\n        rippleEl.style.opacity = '0';\n        rippleRef.state = 2 /* FADING_OUT */;\n        // Once the ripple faded out, the ripple can be safely removed from the DOM.\n        this._runTimeoutOutsideZone(() => {\n            rippleRef.state = 3 /* HIDDEN */;\n            rippleEl.parentNode.removeChild(rippleEl);\n        }, animationConfig.exitDuration);\n    }\n    /** Fades out all currently active ripples. */\n    fadeOutAll() {\n        this._activeRipples.forEach(ripple => ripple.fadeOut());\n    }\n    /** Fades out all currently active non-persistent ripples. */\n    fadeOutAllNonPersistent() {\n        this._activeRipples.forEach(ripple => {\n            if (!ripple.config.persistent) {\n                ripple.fadeOut();\n            }\n        });\n    }\n    /** Sets up the trigger event listeners */\n    setupTriggerEvents(elementOrElementRef) {\n        const element = coerceElement(elementOrElementRef);\n        if (!element || element === this._triggerElement) {\n            return;\n        }\n        // Remove all previously registered event listeners from the trigger element.\n        this._removeTriggerEvents();\n        this._triggerElement = element;\n        this._registerEvents(pointerDownEvents);\n    }\n    /**\n     * Handles all registered events.\n     * @docs-private\n     */\n    handleEvent(event) {\n        if (event.type === 'mousedown') {\n            this._onMousedown(event);\n        }\n        else if (event.type === 'touchstart') {\n            this._onTouchStart(event);\n        }\n        else {\n            this._onPointerUp();\n        }\n        // If pointer-up events haven't been registered yet, do so now.\n        // We do this on-demand in order to reduce the total number of event listeners\n        // registered by the ripples, which speeds up the rendering time for large UIs.\n        if (!this._pointerUpEventsRegistered) {\n            this._registerEvents(pointerUpEvents);\n            this._pointerUpEventsRegistered = true;\n        }\n    }\n    /** Function being called whenever the trigger is being pressed using mouse. */\n    _onMousedown(event) {\n        // Screen readers will fire fake mouse events for space/enter. Skip launching a\n        // ripple in this case for consistency with the non-screen-reader experience.\n        const isFakeMousedown = isFakeMousedownFromScreenReader(event);\n        const isSyntheticEvent = this._lastTouchStartEvent &&\n            Date.now() < this._lastTouchStartEvent + ignoreMouseEventsTimeout;\n        if (!this._target.rippleDisabled && !isFakeMousedown && !isSyntheticEvent) {\n            this._isPointerDown = true;\n            this.fadeInRipple(event.clientX, event.clientY, this._target.rippleConfig);\n        }\n    }\n    /** Function being called whenever the trigger is being pressed using touch. */\n    _onTouchStart(event) {\n        if (!this._target.rippleDisabled && !isFakeTouchstartFromScreenReader(event)) {\n            // Some browsers fire mouse events after a `touchstart` event. Those synthetic mouse\n            // events will launch a second ripple if we don't ignore mouse events for a specific\n            // time after a touchstart event.\n            this._lastTouchStartEvent = Date.now();\n            this._isPointerDown = true;\n            // Use `changedTouches` so we skip any touches where the user put\n            // their finger down, but used another finger to tap the element again.\n            const touches = event.changedTouches;\n            for (let i = 0; i < touches.length; i++) {\n                this.fadeInRipple(touches[i].clientX, touches[i].clientY, this._target.rippleConfig);\n            }\n        }\n    }\n    /** Function being called whenever the trigger is being released. */\n    _onPointerUp() {\n        if (!this._isPointerDown) {\n            return;\n        }\n        this._isPointerDown = false;\n        // Fade-out all ripples that are visible and not persistent.\n        this._activeRipples.forEach(ripple => {\n            // By default, only ripples that are completely visible will fade out on pointer release.\n            // If the `terminateOnPointerUp` option is set, ripples that still fade in will also fade out.\n            const isVisible = ripple.state === 1 /* VISIBLE */ ||\n                ripple.config.terminateOnPointerUp && ripple.state === 0 /* FADING_IN */;\n            if (!ripple.config.persistent && isVisible) {\n                ripple.fadeOut();\n            }\n        });\n    }\n    /** Runs a timeout outside of the Angular zone to avoid triggering the change detection. */\n    _runTimeoutOutsideZone(fn, delay = 0) {\n        this._ngZone.runOutsideAngular(() => setTimeout(fn, delay));\n    }\n    /** Registers event listeners for a given list of events. */\n    _registerEvents(eventTypes) {\n        this._ngZone.runOutsideAngular(() => {\n            eventTypes.forEach((type) => {\n                this._triggerElement.addEventListener(type, this, passiveEventOptions);\n            });\n        });\n    }\n    /** Removes previously registered event listeners from the trigger element. */\n    _removeTriggerEvents() {\n        if (this._triggerElement) {\n            pointerDownEvents.forEach((type) => {\n                this._triggerElement.removeEventListener(type, this, passiveEventOptions);\n            });\n            if (this._pointerUpEventsRegistered) {\n                pointerUpEvents.forEach((type) => {\n                    this._triggerElement.removeEventListener(type, this, passiveEventOptions);\n                });\n            }\n        }\n    }\n}\n/** Enforces a style recalculation of a DOM element by computing its styles. */\nfunction enforceStyleRecalculation(element) {\n    // Enforce a style recalculation by calling `getComputedStyle` and accessing any property.\n    // Calling `getPropertyValue` is important to let optimizers know that this is not a noop.\n    // See: https://gist.github.com/paulirish/5d52fb081b3570c81e3a\n    window.getComputedStyle(element).getPropertyValue('opacity');\n}\n/**\n * Returns the distance from the point (x, y) to the furthest corner of a rectangle.\n */\nfunction distanceToFurthestCorner(x, y, rect) {\n    const distX = Math.max(Math.abs(x - rect.left), Math.abs(x - rect.right));\n    const distY = Math.max(Math.abs(y - rect.top), Math.abs(y - rect.bottom));\n    return Math.sqrt(distX * distX + distY * distY);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token that can be used to specify the global ripple options. */\nconst MAT_RIPPLE_GLOBAL_OPTIONS = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('mat-ripple-global-options');\nlet core_MatRipple = /*@__PURE__*/ (() => {\n    class MatRipple {\n        constructor(_elementRef, ngZone, platform, globalOptions, _animationMode) {\n            this._elementRef = _elementRef;\n            this._animationMode = _animationMode;\n            /**\n             * If set, the radius in pixels of foreground ripples when fully expanded. If unset, the radius\n             * will be the distance from the center of the ripple to the furthest corner of the host element's\n             * bounding rectangle.\n             */\n            this.radius = 0;\n            this._disabled = false;\n            /** Whether ripple directive is initialized and the input bindings are set. */\n            this._isInitialized = false;\n            this._globalOptions = globalOptions || {};\n            this._rippleRenderer = new core_RippleRenderer(this, ngZone, _elementRef, platform);\n        }\n        /**\n         * Whether click events will not trigger the ripple. Ripples can be still launched manually\n         * by using the `launch()` method.\n         */\n        get disabled() { return this._disabled; }\n        set disabled(value) {\n            if (value) {\n                this.fadeOutAllNonPersistent();\n            }\n            this._disabled = value;\n            this._setupTriggerEventsIfEnabled();\n        }\n        /**\n         * The element that triggers the ripple when click events are received.\n         * Defaults to the directive's host element.\n         */\n        get trigger() { return this._trigger || this._elementRef.nativeElement; }\n        set trigger(trigger) {\n            this._trigger = trigger;\n            this._setupTriggerEventsIfEnabled();\n        }\n        ngOnInit() {\n            this._isInitialized = true;\n            this._setupTriggerEventsIfEnabled();\n        }\n        ngOnDestroy() {\n            this._rippleRenderer._removeTriggerEvents();\n        }\n        /** Fades out all currently showing ripple elements. */\n        fadeOutAll() {\n            this._rippleRenderer.fadeOutAll();\n        }\n        /** Fades out all currently showing non-persistent ripple elements. */\n        fadeOutAllNonPersistent() {\n            this._rippleRenderer.fadeOutAllNonPersistent();\n        }\n        /**\n         * Ripple configuration from the directive's input values.\n         * @docs-private Implemented as part of RippleTarget\n         */\n        get rippleConfig() {\n            return {\n                centered: this.centered,\n                radius: this.radius,\n                color: this.color,\n                animation: Object.assign(Object.assign(Object.assign({}, this._globalOptions.animation), (this._animationMode === 'NoopAnimations' ? { enterDuration: 0, exitDuration: 0 } : {})), this.animation),\n                terminateOnPointerUp: this._globalOptions.terminateOnPointerUp,\n            };\n        }\n        /**\n         * Whether ripples on pointer-down are disabled or not.\n         * @docs-private Implemented as part of RippleTarget\n         */\n        get rippleDisabled() {\n            return this.disabled || !!this._globalOptions.disabled;\n        }\n        /** Sets up the trigger event listeners if ripples are enabled. */\n        _setupTriggerEventsIfEnabled() {\n            if (!this.disabled && this._isInitialized) {\n                this._rippleRenderer.setupTriggerEvents(this.trigger);\n            }\n        }\n        /** Launches a manual ripple at the specified coordinated or just by the ripple config. */\n        launch(configOrX, y = 0, config) {\n            if (typeof configOrX === 'number') {\n                return this._rippleRenderer.fadeInRipple(configOrX, y, Object.assign(Object.assign({}, this.rippleConfig), config));\n            }\n            else {\n                return this._rippleRenderer.fadeInRipple(0, 0, Object.assign(Object.assign({}, this.rippleConfig), configOrX));\n            }\n        }\n    }\n    MatRipple.fac = function MatRipple_Factory(t) { return new (t || MatRipple)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](platform_Platform), core[\"Mb\" /* directiveInject */](MAT_RIPPLE_GLOBAL_OPTIONS, 8), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatRipple.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatRipple, selectors: [[\"\", \"mat-ripple\", \"\"], [\"\", \"matRipple\", \"\"]], hostAttrs: [1, \"mat-ripple\"], hostVars: 2, hostBindings: function MatRipple_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* classProp */](\"mat-ripple-unbounded\", ctx.unbounded);\n            }\n        }, inputs: { radius: [\"matRippleRadius\", \"radius\"], disabled: [\"matRippleDisabled\", \"disabled\"], trigger: [\"matRippleTrigger\", \"trigger\"], color: [\"matRippleColor\", \"color\"], unbounded: [\"matRippleUnbounded\", \"unbounded\"], centered: [\"matRippleCentered\", \"centered\"], animation: [\"matRippleAnimation\", \"animation\"] }, exportAs: [\"matRipple\"] });\n    return MatRipple;\n})();\nlet core_MatRippleModule = /*@__PURE__*/ (() => {\n    class MatRippleModule {\n    }\n    MatRippleModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: MatRippleModule });\n    MatRippleModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function MatRippleModule_Factory(t) { return new (t || MatRippleModule)(); }, imports: [[core_MatCommonModule, platform_PlatformModule], core_MatCommonModule] });\n    return MatRippleModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](core_MatRippleModule, { declarations: function () { return [core_MatRipple]; }, imports: function () { return [core_MatCommonModule, platform_PlatformModule]; }, exports: function () { return [core_MatRipple, core_MatCommonModule]; } }); })();\nlet core_MatPseudoCheckbox = /*@__PURE__*/ (() => {\n    class MatPseudoCheckbox {\n        constructor(_animationMode) {\n            this._animationMode = _animationMode;\n            /** Display state of the checkbox. */\n            this.state = 'unchecked';\n            /** Whether the checkbox is disabled. */\n            this.disabled = false;\n        }\n    }\n    MatPseudoCheckbox.fac = function MatPseudoCheckbox_Factory(t) { return new (t || MatPseudoCheckbox)(core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatPseudoCheckbox.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatPseudoCheckbox, selectors: [[\"mat-pseudo-checkbox\"]], hostAttrs: [1, \"mat-pseudo-checkbox\"], hostVars: 8, hostBindings: function MatPseudoCheckbox_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* classProp */](\"mat-pseudo-checkbox-indeterminate\", ctx.state === \"indeterminate\")(\"mat-pseudo-checkbox-checked\", ctx.state === \"checked\")(\"mat-pseudo-checkbox-disabled\", ctx.disabled)(\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n            }\n        }, inputs: { state: \"state\", disabled: \"disabled\" }, decls: 0, vars: 0, template: function MatPseudoCheckbox_Template(rf, ctx) { }, styles: [\".mat-pseudo-checkbox{width:16px;height:16px;border:2px solid;border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:\\\"\\\";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox.mat-pseudo-checkbox-indeterminate{border-color:transparent}._mat-animation-noopable.mat-pseudo-checkbox{transition:none;animation:none}._mat-animation-noopable.mat-pseudo-checkbox::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{top:5px;left:1px;width:10px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{top:2.4px;left:1px;width:8px;height:3px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}\\n\"], encapsulation: 2, changeDetection: 0 });\n    return MatPseudoCheckbox;\n})();\nlet core_MatPseudoCheckboxModule = /*@__PURE__*/ (() => {\n    class MatPseudoCheckboxModule {\n    }\n    MatPseudoCheckboxModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: MatPseudoCheckboxModule });\n    MatPseudoCheckboxModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function MatPseudoCheckboxModule_Factory(t) { return new (t || MatPseudoCheckboxModule)(); }, imports: [[core_MatCommonModule]] });\n    return MatPseudoCheckboxModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](core_MatPseudoCheckboxModule, { declarations: [core_MatPseudoCheckbox], imports: [core_MatCommonModule], exports: [core_MatPseudoCheckbox] }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token used to provide the parent component to options.\n */\nconst MAT_OPTION_PARENT_COMPONENT = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MAT_OPTION_PARENT_COMPONENT');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Notes on the accessibility pattern used for `mat-optgroup`.\n// The option group has two different \"modes\": regular and inert. The regular mode uses the\n// recommended a11y pattern which has `role=\"group\"` on the group element with `aria-labelledby`\n// pointing to the label. This works for `mat-select`, but it seems to hit a bug for autocomplete\n// under VoiceOver where the group doesn't get read out at all. The bug appears to be that if\n// there's __any__ a11y-related attribute on the group (e.g. `role` or `aria-labelledby`),\n// VoiceOver on Safari won't read it out.\n// We've introduced the `inert` mode as a workaround. Under this mode, all a11y attributes are\n// removed from the group, and we get the screen reader to read out the group label by mirroring it\n// inside an invisible element in the option. This is sub-optimal, because the screen reader will\n// repeat the group label on each navigation, whereas the default pattern only reads the group when\n// the user enters a new group. The following alternate approaches were considered:\n// 1. Reading out the group label using the `LiveAnnouncer` solves the problem, but we can't control\n//    when the text will be read out so sometimes it comes in too late or never if the user\n//    navigates quickly.\n// 2. `<mat-option aria-describedby=\"groupLabel\"` - This works on Safari, but VoiceOver in Chrome\n//    won't read out the description at all.\n// 3. `<mat-option aria-labelledby=\"optionLabel groupLabel\"` - This works on Chrome, but Safari\n//     doesn't read out the text at all. Furthermore, on\n// Boilerplate for applying mixins to MatOptgroup.\n/** @docs-private */\nclass MatOptgroupBase {\n}\nconst _MatOptgroupMixinBase = /*@__PURE__*/ mixinDisabled(MatOptgroupBase);\n// Counter for unique group ids.\nlet _uniqueOptgroupIdCounter = 0;\nlet core_MatOptgroupBase = /*@__PURE__*/ (() => {\n    class _MatOptgroupBase extends _MatOptgroupMixinBase {\n        constructor(parent) {\n            var _a;\n            super();\n            /** Unique id for the underlying label. */\n            this._labelId = `mat-optgroup-label-${_uniqueOptgroupIdCounter++}`;\n            this._inert = (_a = parent === null || parent === void 0 ? void 0 : parent.inertGroups) !== null && _a !== void 0 ? _a : false;\n        }\n    }\n    _MatOptgroupBase.fac = function _MatOptgroupBase_Factory(t) { return new (t || _MatOptgroupBase)(core[\"Mb\" /* directiveInject */](MAT_OPTION_PARENT_COMPONENT, 8)); };\n    _MatOptgroupBase.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: _MatOptgroupBase, inputs: { label: \"label\" }, features: [core[\"xb\" /* InheritDefinitionFeature */]] });\n    return _MatOptgroupBase;\n})();\n/**\n * Injection token that can be used to reference instances of `MatOptgroup`. It serves as\n * alternative token to the actual `MatOptgroup` class which could cause unnecessary\n * retention of the class and its component metadata.\n */\nconst MAT_OPTGROUP = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MatOptgroup');\nlet core_MatOptgroup = /*@__PURE__*/ (() => {\n    class MatOptgroup extends core_MatOptgroupBase {\n    }\n    MatOptgroup.fac = function MatOptgroup_Factory(t) { return MatOptgroup_BaseFactory(t || MatOptgroup); };\n    MatOptgroup.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatOptgroup, selectors: [[\"mat-optgroup\"]], hostAttrs: [1, \"mat-optgroup\"], hostVars: 5, hostBindings: function MatOptgroup_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Bb\" /* attribute */](\"role\", ctx._inert ? null : \"group\")(\"aria-disabled\", ctx._inert ? null : ctx.disabled.toString())(\"aria-labelledby\", ctx._inert ? null : ctx._labelId);\n                core[\"Eb\" /* classProp */](\"mat-optgroup-disabled\", ctx.disabled);\n            }\n        }, inputs: { disabled: \"disabled\" }, exportAs: [\"matOptgroup\"], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{ provide: MAT_OPTGROUP, useExisting: MatOptgroup }]), core[\"xb\" /* InheritDefinitionFeature */]], ngContentSelectors: _c1, decls: 4, vars: 2, consts: [[\"aria-hidden\", \"true\", 1, \"mat-optgroup-label\", 3, \"id\"]], template: function MatOptgroup_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"dc\" /* projectionDef */](_c0);\n                core[\"Sb\" /* elementStart */](0, \"span\", 0);\n                core[\"uc\" /* text */](1);\n                core[\"cc\" /* projection */](2);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"cc\" /* projection */](3, 1);\n            }\n            if (rf & 2) {\n                core[\"ec\" /* property */](\"id\", ctx._labelId);\n                core[\"Ab\" /* advance */](1);\n                core[\"wc\" /* textInterpolate1 */](\"\", ctx.label, \" \");\n            }\n        }, styles: [\".mat-optgroup-label{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup-label[disabled]{cursor:default}[dir=rtl] .mat-optgroup-label{text-align:right}.mat-optgroup-label .mat-icon{margin-right:16px;vertical-align:middle}.mat-optgroup-label .mat-icon svg{vertical-align:top}[dir=rtl] .mat-optgroup-label .mat-icon{margin-left:16px;margin-right:0}\\n\"], encapsulation: 2, changeDetection: 0 });\n    return MatOptgroup;\n})();\nconst MatOptgroup_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Ub\" /* getInheritedFactory */](core_MatOptgroup);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Option IDs need to be unique across components, so this counter exists outside of\n * the component definition.\n */\nlet _uniqueIdCounter = 0;\n/** Event object emitted by MatOption when selected or deselected. */\nclass MatOptionSelectionChange {\n    constructor(\n    /** Reference to the option that emitted the event. */\n    source, \n    /** Whether the change in the option's value was a result of a user action. */\n    isUserInput = false) {\n        this.source = source;\n        this.isUserInput = isUserInput;\n    }\n}\nlet core_MatOptionBase = /*@__PURE__*/ (() => {\n    class _MatOptionBase {\n        constructor(_element, _changeDetectorRef, _parent, group) {\n            this._element = _element;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._parent = _parent;\n            this.group = group;\n            this._selected = false;\n            this._active = false;\n            this._disabled = false;\n            this._mostRecentViewValue = '';\n            /** The unique ID of the option. */\n            this.id = `mat-option-${_uniqueIdCounter++}`;\n            /** Event emitted when the option is selected or deselected. */\n            // tslint:disable-next-line:no-output-on-prefix\n            this.onSelectionChange = new core[\"n\" /* EventEmitter */]();\n            /** Emits when the state of the option changes and any parents have to be notified. */\n            this._stateChanges = new Subject[\"a\" /* Subject */]();\n        }\n        /** Whether the wrapping component is in multiple selection mode. */\n        get multiple() { return this._parent && this._parent.multiple; }\n        /** Whether or not the option is currently selected. */\n        get selected() { return this._selected; }\n        /** Whether the option is disabled. */\n        get disabled() { return (this.group && this.group.disabled) || this._disabled; }\n        set disabled(value) { this._disabled = coerceBooleanProperty(value); }\n        /** Whether ripples for the option are disabled. */\n        get disableRipple() { return this._parent && this._parent.disableRipple; }\n        /**\n         * Whether or not the option is currently active and ready to be selected.\n         * An active option displays styles as if it is focused, but the\n         * focus is actually retained somewhere else. This comes in handy\n         * for components like autocomplete where focus must remain on the input.\n         */\n        get active() {\n            return this._active;\n        }\n        /**\n         * The displayed value of the option. It is necessary to show the selected option in the\n         * select's trigger.\n         */\n        get viewValue() {\n            // TODO(kara): Add input property alternative for node envs.\n            return (this._getHostElement().textContent || '').trim();\n        }\n        /** Selects the option. */\n        select() {\n            if (!this._selected) {\n                this._selected = true;\n                this._changeDetectorRef.markForCheck();\n                this._emitSelectionChangeEvent();\n            }\n        }\n        /** Deselects the option. */\n        deselect() {\n            if (this._selected) {\n                this._selected = false;\n                this._changeDetectorRef.markForCheck();\n                this._emitSelectionChangeEvent();\n            }\n        }\n        /** Sets focus onto this option. */\n        focus(_origin, options) {\n            // Note that we aren't using `_origin`, but we need to keep it because some internal consumers\n            // use `MatOption` in a `FocusKeyManager` and we need it to match `FocusableOption`.\n            const element = this._getHostElement();\n            if (typeof element.focus === 'function') {\n                element.focus(options);\n            }\n        }\n        /**\n         * This method sets display styles on the option to make it appear\n         * active. This is used by the ActiveDescendantKeyManager so key\n         * events will display the proper options as active on arrow key events.\n         */\n        setActiveStyles() {\n            if (!this._active) {\n                this._active = true;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        /**\n         * This method removes display styles on the option that made it appear\n         * active. This is used by the ActiveDescendantKeyManager so key\n         * events will display the proper options as active on arrow key events.\n         */\n        setInactiveStyles() {\n            if (this._active) {\n                this._active = false;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        /** Gets the label to be used when determining whether the option should be focused. */\n        getLabel() {\n            return this.viewValue;\n        }\n        /** Ensures the option is selected when activated from the keyboard. */\n        _handleKeydown(event) {\n            if ((event.keyCode === ENTER || event.keyCode === SPACE) && !hasModifierKey(event)) {\n                this._selectViaInteraction();\n                // Prevent the page from scrolling down and form submits.\n                event.preventDefault();\n            }\n        }\n        /**\n         * `Selects the option while indicating the selection came from the user. Used to\n         * determine if the select's view -> model callback should be invoked.`\n         */\n        _selectViaInteraction() {\n            if (!this.disabled) {\n                this._selected = this.multiple ? !this._selected : true;\n                this._changeDetectorRef.markForCheck();\n                this._emitSelectionChangeEvent(true);\n            }\n        }\n        /**\n         * Gets the `aria-selected` value for the option. We explicitly omit the `aria-selected`\n         * attribute from single-selection, unselected options. Including the `aria-selected=\"false\"`\n         * attributes adds a significant amount of noise to screen-reader users without providing useful\n         * information.\n         */\n        _getAriaSelected() {\n            return this.selected || (this.multiple ? false : null);\n        }\n        /** Returns the correct tabindex for the option depending on disabled state. */\n        _getTabIndex() {\n            return this.disabled ? '-1' : '0';\n        }\n        /** Gets the host DOM element. */\n        _getHostElement() {\n            return this._element.nativeElement;\n        }\n        ngAfterViewChecked() {\n            // Since parent components could be using the option's label to display the selected values\n            // (e.g. `mat-select`) and they don't have a way of knowing if the option's label has changed\n            // we have to check for changes in the DOM ourselves and dispatch an event. These checks are\n            // relatively cheap, however we still limit them only to selected options in order to avoid\n            // hitting the DOM too often.\n            if (this._selected) {\n                const viewValue = this.viewValue;\n                if (viewValue !== this._mostRecentViewValue) {\n                    this._mostRecentViewValue = viewValue;\n                    this._stateChanges.next();\n                }\n            }\n        }\n        ngOnDestroy() {\n            this._stateChanges.complete();\n        }\n        /** Emits the selection change event. */\n        _emitSelectionChangeEvent(isUserInput = false) {\n            this.onSelectionChange.emit(new MatOptionSelectionChange(this, isUserInput));\n        }\n    }\n    _MatOptionBase.fac = function _MatOptionBase_Factory(t) { return new (t || _MatOptionBase)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](undefined), core[\"Mb\" /* directiveInject */](core_MatOptgroupBase)); };\n    _MatOptionBase.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: _MatOptionBase, inputs: { id: \"id\", disabled: \"disabled\", value: \"value\" }, outputs: { onSelectionChange: \"onSelectionChange\" } });\n    return _MatOptionBase;\n})();\nlet core_MatOption = /*@__PURE__*/ (() => {\n    class MatOption extends core_MatOptionBase {\n        constructor(element, changeDetectorRef, parent, group) {\n            super(element, changeDetectorRef, parent, group);\n        }\n    }\n    MatOption.fac = function MatOption_Factory(t) { return new (t || MatOption)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](MAT_OPTION_PARENT_COMPONENT, 8), core[\"Mb\" /* directiveInject */](MAT_OPTGROUP, 8)); };\n    MatOption.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatOption, selectors: [[\"mat-option\"]], hostAttrs: [\"role\", \"option\", 1, \"mat-option\", \"mat-focus-indicator\"], hostVars: 12, hostBindings: function MatOption_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                core[\"Zb\" /* listener */](\"click\", function MatOption_click_HostBindingHandler() { return ctx._selectViaInteraction(); })(\"keydown\", function MatOption_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); });\n            }\n            if (rf & 2) {\n                core[\"Vb\" /* hostProperty */](\"id\", ctx.id);\n                core[\"Bb\" /* attribute */](\"tabindex\", ctx._getTabIndex())(\"aria-selected\", ctx._getAriaSelected())(\"aria-disabled\", ctx.disabled.toString());\n                core[\"Eb\" /* classProp */](\"mat-selected\", ctx.selected)(\"mat-option-multiple\", ctx.multiple)(\"mat-active\", ctx.active)(\"mat-option-disabled\", ctx.disabled);\n            }\n        }, exportAs: [\"matOption\"], features: [core[\"xb\" /* InheritDefinitionFeature */]], ngContentSelectors: _c2, decls: 5, vars: 4, consts: [[\"class\", \"mat-option-pseudo-checkbox\", 3, \"state\", \"disabled\", 4, \"ngIf\"], [1, \"mat-option-text\"], [\"class\", \"cdk-visually-hidden\", 4, \"ngIf\"], [\"mat-ripple\", \"\", 1, \"mat-option-ripple\", 3, \"matRippleTrigger\", \"matRippleDisabled\"], [1, \"mat-option-pseudo-checkbox\", 3, \"state\", \"disabled\"], [1, \"cdk-visually-hidden\"]], template: function MatOption_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"dc\" /* projectionDef */]();\n                core[\"sc\" /* template */](0, MatOption_mat_pseudo_checkbox_0_Template, 1, 2, \"mat-pseudo-checkbox\", 0);\n                core[\"Sb\" /* elementStart */](1, \"span\", 1);\n                core[\"cc\" /* projection */](2);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"sc\" /* template */](3, MatOption_span_3_Template, 2, 1, \"span\", 2);\n                core[\"Nb\" /* element */](4, \"div\", 3);\n            }\n            if (rf & 2) {\n                core[\"ec\" /* property */](\"ngIf\", ctx.multiple);\n                core[\"Ab\" /* advance */](3);\n                core[\"ec\" /* property */](\"ngIf\", ctx.group && ctx.group._inert);\n                core[\"Ab\" /* advance */](1);\n                core[\"ec\" /* property */](\"matRippleTrigger\", ctx._getHostElement())(\"matRippleDisabled\", ctx.disabled || ctx.disableRipple);\n            }\n        }, directives: [common[\"j\" /* NgIf */], core_MatRipple, core_MatPseudoCheckbox], styles: [\".mat-option{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative;cursor:pointer;outline:none;display:flex;flex-direction:row;max-width:100%;box-sizing:border-box;align-items:center;-webkit-tap-highlight-color:transparent}.mat-option[disabled]{cursor:default}[dir=rtl] .mat-option{text-align:right}.mat-option .mat-icon{margin-right:16px;vertical-align:middle}.mat-option .mat-icon svg{vertical-align:top}[dir=rtl] .mat-option .mat-icon{margin-left:16px;margin-right:0}.mat-option[aria-disabled=true]{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:32px}[dir=rtl] .mat-optgroup .mat-option:not(.mat-option-multiple){padding-left:16px;padding-right:32px}.cdk-high-contrast-active .mat-option{margin:0 1px}.cdk-high-contrast-active .mat-option.mat-active{border:solid 1px currentColor;margin:0}.cdk-high-contrast-active .mat-option[aria-disabled=true]{opacity:.5}.mat-option-text{display:inline-block;flex-grow:1;overflow:hidden;text-overflow:ellipsis}.mat-option .mat-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-option-pseudo-checkbox{margin-right:8px}[dir=rtl] .mat-option-pseudo-checkbox{margin-left:8px;margin-right:0}\\n\"], encapsulation: 2, changeDetection: 0 });\n    return MatOption;\n})();\n/**\n * Counts the amount of option group labels that precede the specified option.\n * @param optionIndex Index of the option at which to start counting.\n * @param options Flat list of all of the options.\n * @param optionGroups Flat list of all of the option groups.\n * @docs-private\n */\nfunction _countGroupLabelsBeforeOption(optionIndex, options, optionGroups) {\n    if (optionGroups.length) {\n        let optionsArray = options.toArray();\n        let groups = optionGroups.toArray();\n        let groupCounter = 0;\n        for (let i = 0; i < optionIndex + 1; i++) {\n            if (optionsArray[i].group && optionsArray[i].group === groups[groupCounter]) {\n                groupCounter++;\n            }\n        }\n        return groupCounter;\n    }\n    return 0;\n}\n/**\n * Determines the position to which to scroll a panel in order for an option to be into view.\n * @param optionOffset Offset of the option from the top of the panel.\n * @param optionHeight Height of the options.\n * @param currentScrollPosition Current scroll position of the panel.\n * @param panelHeight Height of the panel.\n * @docs-private\n */\nfunction _getOptionScrollPosition(optionOffset, optionHeight, currentScrollPosition, panelHeight) {\n    if (optionOffset < currentScrollPosition) {\n        return optionOffset;\n    }\n    if (optionOffset + optionHeight > currentScrollPosition + panelHeight) {\n        return Math.max(0, optionOffset - panelHeight + optionHeight);\n    }\n    return currentScrollPosition;\n}\nlet core_MatOptionModule = /*@__PURE__*/ (() => {\n    class MatOptionModule {\n    }\n    MatOptionModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: MatOptionModule });\n    MatOptionModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function MatOptionModule_Factory(t) { return new (t || MatOptionModule)(); }, imports: [[core_MatRippleModule, common[\"b\" /* CommonModule */], core_MatCommonModule, core_MatPseudoCheckboxModule]] });\n    return MatOptionModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](core_MatOptionModule, { declarations: function () { return [core_MatOption, core_MatOptgroup]; }, imports: function () { return [core_MatRippleModule, common[\"b\" /* CommonModule */], core_MatCommonModule, core_MatPseudoCheckboxModule]; }, exports: function () { return [core_MatOption, core_MatOptgroup]; } }); })();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=core.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/merge.js\nvar merge = __webpack_require__(\"VRyK\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isArray.js\nvar isArray = __webpack_require__(\"DH7j\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isFunction.js\nvar isFunction = __webpack_require__(\"n6bG\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/fromEvent.js\n\n\n\n\nconst fromEvent_toString = /*@__PURE__*/ (() => Object.prototype.toString)();\nfunction fromEvent(target, eventName, options, resultSelector) {\n    if (Object(isFunction[\"a\" /* isFunction */])(options)) {\n        resultSelector = options;\n        options = undefined;\n    }\n    if (resultSelector) {\n        return fromEvent(target, eventName, options).pipe(Object(map[\"a\" /* map */])(args => Object(isArray[\"a\" /* isArray */])(args) ? resultSelector(...args) : resultSelector(args)));\n    }\n    return new Observable[\"a\" /* Observable */](subscriber => {\n        function handler(e) {\n            if (arguments.length > 1) {\n                subscriber.next(Array.prototype.slice.call(arguments));\n            }\n            else {\n                subscriber.next(e);\n            }\n        }\n        setupSubscription(target, eventName, handler, subscriber, options);\n    });\n}\nfunction setupSubscription(sourceObj, eventName, handler, subscriber, options) {\n    let unsubscribe;\n    if (isEventTarget(sourceObj)) {\n        const source = sourceObj;\n        sourceObj.addEventListener(eventName, handler, options);\n        unsubscribe = () => source.removeEventListener(eventName, handler, options);\n    }\n    else if (isJQueryStyleEventEmitter(sourceObj)) {\n        const source = sourceObj;\n        sourceObj.on(eventName, handler);\n        unsubscribe = () => source.off(eventName, handler);\n    }\n    else if (isNodeStyleEventEmitter(sourceObj)) {\n        const source = sourceObj;\n        sourceObj.addListener(eventName, handler);\n        unsubscribe = () => source.removeListener(eventName, handler);\n    }\n    else if (sourceObj && sourceObj.length) {\n        for (let i = 0, len = sourceObj.length; i < len; i++) {\n            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);\n        }\n    }\n    else {\n        throw new TypeError('Invalid event target');\n    }\n    subscriber.add(unsubscribe);\n}\nfunction isNodeStyleEventEmitter(sourceObj) {\n    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';\n}\nfunction isJQueryStyleEventEmitter(sourceObj) {\n    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';\n}\nfunction isEventTarget(sourceObj) {\n    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';\n}\n//# sourceMappingURL=fromEvent.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/util/isNumeric.js\n\nfunction isNumeric(val) {\n    return !Object(isArray[\"a\" /* isArray */])(val) && (val - parseFloat(val) + 1) >= 0;\n}\n//# sourceMappingURL=isNumeric.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/isScheduler.js\nvar isScheduler = __webpack_require__(\"z+Ro\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/timer.js\n\n\n\n\nfunction timer(dueTime = 0, periodOrScheduler, scheduler) {\n    let period = -1;\n    if (isNumeric(periodOrScheduler)) {\n        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);\n    }\n    else if (Object(isScheduler[\"a\" /* isScheduler */])(periodOrScheduler)) {\n        scheduler = periodOrScheduler;\n    }\n    if (!Object(isScheduler[\"a\" /* isScheduler */])(scheduler)) {\n        scheduler = async_async;\n    }\n    return new Observable[\"a\" /* Observable */](subscriber => {\n        const due = isNumeric(dueTime)\n            ? dueTime\n            : (+dueTime - scheduler.now());\n        return scheduler.schedule(dispatch, due, {\n            index: 0, period, subscriber\n        });\n    });\n}\nfunction dispatch(state) {\n    const { index, period, subscriber } = state;\n    subscriber.next(index);\n    if (subscriber.closed) {\n        return;\n    }\n    else if (period === -1) {\n        return subscriber.complete();\n    }\n    state.index = index + 1;\n    this.schedule(state, period);\n}\n//# sourceMappingURL=timer.js.map\n\n// EXTERNAL MODULE: ./node_modules/@angular/animations/__ivy_ngcc__/fesm2015/animations.js\nvar fesm2015_animations = __webpack_require__(\"R0Ic\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/distinctUntilChanged.js\n\nfunction distinctUntilChanged(compare, keySelector) {\n    return (source) => source.lift(new DistinctUntilChangedOperator(compare, keySelector));\n}\nclass DistinctUntilChangedOperator {\n    constructor(compare, keySelector) {\n        this.compare = compare;\n        this.keySelector = keySelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new distinctUntilChanged_DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n    }\n}\nclass distinctUntilChanged_DistinctUntilChangedSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination, compare, keySelector) {\n        super(destination);\n        this.keySelector = keySelector;\n        this.hasKey = false;\n        if (typeof compare === 'function') {\n            this.compare = compare;\n        }\n    }\n    compare(x, y) {\n        return x === y;\n    }\n    _next(value) {\n        let key;\n        try {\n            const { keySelector } = this;\n            key = keySelector ? keySelector(value) : value;\n        }\n        catch (err) {\n            return this.destination.error(err);\n        }\n        let result = false;\n        if (this.hasKey) {\n            try {\n                const { compare } = this;\n                result = compare(this.key, key);\n            }\n            catch (err) {\n                return this.destination.error(err);\n            }\n        }\n        else {\n            this.hasKey = true;\n        }\n        if (!result) {\n            this.key = key;\n            this.destination.next(value);\n        }\n    }\n}\n//# sourceMappingURL=distinctUntilChanged.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/innerSubscribe.js\nvar innerSubscribe = __webpack_require__(\"zx2A\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeUntil.js\n\nfunction takeUntil(notifier) {\n    return (source) => source.lift(new takeUntil_TakeUntilOperator(notifier));\n}\nclass takeUntil_TakeUntilOperator {\n    constructor(notifier) {\n        this.notifier = notifier;\n    }\n    call(subscriber, source) {\n        const takeUntilSubscriber = new takeUntil_TakeUntilSubscriber(subscriber);\n        const notifierSubscription = Object(innerSubscribe[\"c\" /* innerSubscribe */])(this.notifier, new innerSubscribe[\"a\" /* SimpleInnerSubscriber */](takeUntilSubscriber));\n        if (notifierSubscription && !takeUntilSubscriber.seenValue) {\n            takeUntilSubscriber.add(notifierSubscription);\n            return source.subscribe(takeUntilSubscriber);\n        }\n        return takeUntilSubscriber;\n    }\n}\nclass takeUntil_TakeUntilSubscriber extends innerSubscribe[\"b\" /* SimpleOuterSubscriber */] {\n    constructor(destination) {\n        super(destination);\n        this.seenValue = false;\n    }\n    notifyNext() {\n        this.seenValue = true;\n        this.complete();\n    }\n    notifyComplete() {\n    }\n}\n//# sourceMappingURL=takeUntil.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameAction.js\n\nclass AnimationFrameAction_AnimationFrameAction extends AsyncAction_AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(() => scheduler.flush(null)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            cancelAnimationFrame(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=AnimationFrameAction.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AnimationFrameScheduler.js\n\nclass AnimationFrameScheduler_AnimationFrameScheduler extends AsyncScheduler_AsyncScheduler {\n    flush(action) {\n        this.active = true;\n        this.scheduled = undefined;\n        const { actions } = this;\n        let error;\n        let index = -1;\n        let count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n//# sourceMappingURL=AnimationFrameScheduler.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/animationFrame.js\n\n\nconst animationFrameScheduler = /*@__PURE__*/ new AnimationFrameScheduler_AnimationFrameScheduler(AnimationFrameAction_AnimationFrameAction);\nconst animationFrame = animationFrameScheduler;\n//# sourceMappingURL=animationFrame.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/util/Immediate.js\nlet nextHandle = 1;\nconst RESOLVED = /*@__PURE__*/ (() => Promise.resolve())();\nconst activeHandles = {};\nfunction findAndClearHandle(handle) {\n    if (handle in activeHandles) {\n        delete activeHandles[handle];\n        return true;\n    }\n    return false;\n}\nconst Immediate = {\n    setImmediate(cb) {\n        const handle = nextHandle++;\n        activeHandles[handle] = true;\n        RESOLVED.then(() => findAndClearHandle(handle) && cb());\n        return handle;\n    },\n    clearImmediate(handle) {\n        findAndClearHandle(handle);\n    },\n};\nconst TestTools = {\n    pending() {\n        return Object.keys(activeHandles).length;\n    }\n};\n//# sourceMappingURL=Immediate.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsapAction.js\n\n\nclass AsapAction_AsapAction extends AsyncAction_AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if (delay !== null && delay > 0) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));\n    }\n    recycleAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.recycleAsyncId(scheduler, id, delay);\n        }\n        if (scheduler.actions.length === 0) {\n            Immediate.clearImmediate(id);\n            scheduler.scheduled = undefined;\n        }\n        return undefined;\n    }\n}\n//# sourceMappingURL=AsapAction.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/AsapScheduler.js\n\nclass AsapScheduler_AsapScheduler extends AsyncScheduler_AsyncScheduler {\n    flush(action) {\n        this.active = true;\n        this.scheduled = undefined;\n        const { actions } = this;\n        let error;\n        let index = -1;\n        let count = actions.length;\n        action = action || actions.shift();\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (++index < count && (action = actions.shift()));\n        this.active = false;\n        if (error) {\n            while (++index < count && (action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    }\n}\n//# sourceMappingURL=AsapScheduler.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/asap.js\n\n\nconst asapScheduler = /*@__PURE__*/ new AsapScheduler_AsapScheduler(AsapAction_AsapAction);\nconst asap = asapScheduler;\n//# sourceMappingURL=asap.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/util/isObservable.js\n\nfunction isObservable(obj) {\n    return !!obj && (obj instanceof Observable[\"a\" /* Observable */] || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));\n}\n//# sourceMappingURL=isObservable.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/audit.js\n\nfunction audit(durationSelector) {\n    return function auditOperatorFunction(source) {\n        return source.lift(new AuditOperator(durationSelector));\n    };\n}\nclass AuditOperator {\n    constructor(durationSelector) {\n        this.durationSelector = durationSelector;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new audit_AuditSubscriber(subscriber, this.durationSelector));\n    }\n}\nclass audit_AuditSubscriber extends innerSubscribe[\"b\" /* SimpleOuterSubscriber */] {\n    constructor(destination, durationSelector) {\n        super(destination);\n        this.durationSelector = durationSelector;\n        this.hasValue = false;\n    }\n    _next(value) {\n        this.value = value;\n        this.hasValue = true;\n        if (!this.throttled) {\n            let duration;\n            try {\n                const { durationSelector } = this;\n                duration = durationSelector(value);\n            }\n            catch (err) {\n                return this.destination.error(err);\n            }\n            const innerSubscription = Object(innerSubscribe[\"c\" /* innerSubscribe */])(duration, new innerSubscribe[\"a\" /* SimpleInnerSubscriber */](this));\n            if (!innerSubscription || innerSubscription.closed) {\n                this.clearThrottle();\n            }\n            else {\n                this.add(this.throttled = innerSubscription);\n            }\n        }\n    }\n    clearThrottle() {\n        const { value, hasValue, throttled } = this;\n        if (throttled) {\n            this.remove(throttled);\n            this.throttled = undefined;\n            throttled.unsubscribe();\n        }\n        if (hasValue) {\n            this.value = undefined;\n            this.hasValue = false;\n            this.destination.next(value);\n        }\n    }\n    notifyNext() {\n        this.clearThrottle();\n    }\n    notifyComplete() {\n        this.clearThrottle();\n    }\n}\n//# sourceMappingURL=audit.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/auditTime.js\n\n\n\nfunction auditTime(duration, scheduler = async_async) {\n    return audit(() => timer(duration, scheduler));\n}\n//# sourceMappingURL=auditTime.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/pairwise.js\n\nfunction pairwise() {\n    return (source) => source.lift(new PairwiseOperator());\n}\nclass PairwiseOperator {\n    call(subscriber, source) {\n        return source.subscribe(new pairwise_PairwiseSubscriber(subscriber));\n    }\n}\nclass pairwise_PairwiseSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination) {\n        super(destination);\n        this.hasPrev = false;\n    }\n    _next(value) {\n        let pair;\n        if (this.hasPrev) {\n            pair = [this.prev, value];\n        }\n        else {\n            this.hasPrev = true;\n        }\n        this.prev = value;\n        if (pair) {\n            this.destination.next(pair);\n        }\n    }\n}\n//# sourceMappingURL=pairwise.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/operators/switchMap.js\nvar switchMap = __webpack_require__(\"eIep\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/QueueAction.js\n\nclass QueueAction_QueueAction extends AsyncAction_AsyncAction {\n    constructor(scheduler, work) {\n        super(scheduler, work);\n        this.scheduler = scheduler;\n        this.work = work;\n    }\n    schedule(state, delay = 0) {\n        if (delay > 0) {\n            return super.schedule(state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    }\n    execute(state, delay) {\n        return (delay > 0 || this.closed) ?\n            super.execute(state, delay) :\n            this._execute(state, delay);\n    }\n    requestAsyncId(scheduler, id, delay = 0) {\n        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {\n            return super.requestAsyncId(scheduler, id, delay);\n        }\n        return scheduler.flush(this);\n    }\n}\n//# sourceMappingURL=QueueAction.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/QueueScheduler.js\n\nclass QueueScheduler_QueueScheduler extends AsyncScheduler_AsyncScheduler {\n}\n//# sourceMappingURL=QueueScheduler.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/scheduler/queue.js\n\n\nconst queueScheduler = /*@__PURE__*/ new QueueScheduler_QueueScheduler(QueueAction_QueueAction);\nconst queue = queueScheduler;\n//# sourceMappingURL=queue.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/empty.js\nvar empty = __webpack_require__(\"EY2u\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/observable/throwError.js\n\nfunction throwError(error, scheduler) {\n    if (!scheduler) {\n        return new Observable[\"a\" /* Observable */](subscriber => subscriber.error(error));\n    }\n    else {\n        return new Observable[\"a\" /* Observable */](subscriber => scheduler.schedule(throwError_dispatch, 0, { error, subscriber }));\n    }\n}\nfunction throwError_dispatch({ error, subscriber }) {\n    subscriber.error(error);\n}\n//# sourceMappingURL=throwError.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/Notification.js\n\n\n\nvar NotificationKind = /*@__PURE__*/ (function (NotificationKind) {\n    NotificationKind[\"NEXT\"] = \"N\";\n    NotificationKind[\"ERROR\"] = \"E\";\n    NotificationKind[\"COMPLETE\"] = \"C\";\n    return NotificationKind;\n})({});\nlet Notification_Notification = /*@__PURE__*/ (() => {\n    class Notification {\n        constructor(kind, value, error) {\n            this.kind = kind;\n            this.value = value;\n            this.error = error;\n            this.hasValue = kind === 'N';\n        }\n        observe(observer) {\n            switch (this.kind) {\n                case 'N':\n                    return observer.next && observer.next(this.value);\n                case 'E':\n                    return observer.error && observer.error(this.error);\n                case 'C':\n                    return observer.complete && observer.complete();\n            }\n        }\n        do(next, error, complete) {\n            const kind = this.kind;\n            switch (kind) {\n                case 'N':\n                    return next && next(this.value);\n                case 'E':\n                    return error && error(this.error);\n                case 'C':\n                    return complete && complete();\n            }\n        }\n        accept(nextOrObserver, error, complete) {\n            if (nextOrObserver && typeof nextOrObserver.next === 'function') {\n                return this.observe(nextOrObserver);\n            }\n            else {\n                return this.do(nextOrObserver, error, complete);\n            }\n        }\n        toObservable() {\n            const kind = this.kind;\n            switch (kind) {\n                case 'N':\n                    return Object(of[\"a\" /* of */])(this.value);\n                case 'E':\n                    return throwError(this.error);\n                case 'C':\n                    return Object(empty[\"b\" /* empty */])();\n            }\n            throw new Error('unexpected notification kind value');\n        }\n        static createNext(value) {\n            if (typeof value !== 'undefined') {\n                return new Notification('N', value);\n            }\n            return Notification.undefinedValueNotification;\n        }\n        static createError(err) {\n            return new Notification('E', undefined, err);\n        }\n        static createComplete() {\n            return Notification.completeNotification;\n        }\n    }\n    Notification.completeNotification = /*@__PURE__*/ new Notification('C');\n    Notification.undefinedValueNotification = /*@__PURE__*/ new Notification('N', undefined);\n    return Notification;\n})();\n//# sourceMappingURL=Notification.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/observeOn.js\n\n\nfunction observeOn(scheduler, delay = 0) {\n    return function observeOnOperatorFunction(source) {\n        return source.lift(new ObserveOnOperator(scheduler, delay));\n    };\n}\nclass ObserveOnOperator {\n    constructor(scheduler, delay = 0) {\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new observeOn_ObserveOnSubscriber(subscriber, this.scheduler, this.delay));\n    }\n}\nclass observeOn_ObserveOnSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination, scheduler, delay = 0) {\n        super(destination);\n        this.scheduler = scheduler;\n        this.delay = delay;\n    }\n    static dispatch(arg) {\n        const { notification, destination } = arg;\n        notification.observe(destination);\n        this.unsubscribe();\n    }\n    scheduleMessage(notification) {\n        const destination = this.destination;\n        destination.add(this.scheduler.schedule(observeOn_ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));\n    }\n    _next(value) {\n        this.scheduleMessage(Notification_Notification.createNext(value));\n    }\n    _error(err) {\n        this.scheduleMessage(Notification_Notification.createError(err));\n        this.unsubscribe();\n    }\n    _complete() {\n        this.scheduleMessage(Notification_Notification.createComplete());\n        this.unsubscribe();\n    }\n}\nclass ObserveOnMessage {\n    constructor(notification, destination) {\n        this.notification = notification;\n        this.destination = destination;\n    }\n}\n//# sourceMappingURL=observeOn.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/util/ObjectUnsubscribedError.js\nvar ObjectUnsubscribedError = __webpack_require__(\"9ppp\");\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/SubjectSubscription.js\nvar SubjectSubscription = __webpack_require__(\"Ylt2\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/ReplaySubject.js\n\n\n\n\n\n\nclass ReplaySubject_ReplaySubject extends Subject[\"a\" /* Subject */] {\n    constructor(bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, scheduler) {\n        super();\n        this.scheduler = scheduler;\n        this._events = [];\n        this._infiniteTimeWindow = false;\n        this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            this._infiniteTimeWindow = true;\n            this.next = this.nextInfiniteTimeWindow;\n        }\n        else {\n            this.next = this.nextTimeWindow;\n        }\n    }\n    nextInfiniteTimeWindow(value) {\n        if (!this.isStopped) {\n            const _events = this._events;\n            _events.push(value);\n            if (_events.length > this._bufferSize) {\n                _events.shift();\n            }\n        }\n        super.next(value);\n    }\n    nextTimeWindow(value) {\n        if (!this.isStopped) {\n            this._events.push(new ReplayEvent(this._getNow(), value));\n            this._trimBufferThenGetEvents();\n        }\n        super.next(value);\n    }\n    _subscribe(subscriber) {\n        const _infiniteTimeWindow = this._infiniteTimeWindow;\n        const _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        const scheduler = this.scheduler;\n        const len = _events.length;\n        let subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError[\"a\" /* ObjectUnsubscribedError */]();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription[\"a\" /* SubjectSubscription */](this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new observeOn_ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (let i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    }\n    _getNow() {\n        return (this.scheduler || queue).now();\n    }\n    _trimBufferThenGetEvents() {\n        const now = this._getNow();\n        const _bufferSize = this._bufferSize;\n        const _windowTime = this._windowTime;\n        const _events = this._events;\n        const eventsCount = _events.length;\n        let spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    }\n}\nclass ReplayEvent {\n    constructor(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n}\n//# sourceMappingURL=ReplaySubject.js.map\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/shareReplay.js\n\nfunction shareReplay(configOrBufferSize, windowTime, scheduler) {\n    let config;\n    if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n        config = configOrBufferSize;\n    }\n    else {\n        config = {\n            bufferSize: configOrBufferSize,\n            windowTime,\n            refCount: false,\n            scheduler,\n        };\n    }\n    return (source) => source.lift(shareReplayOperator(config));\n}\nfunction shareReplayOperator({ bufferSize = Number.POSITIVE_INFINITY, windowTime = Number.POSITIVE_INFINITY, refCount: useRefCount, scheduler, }) {\n    let subject;\n    let refCount = 0;\n    let subscription;\n    let hasError = false;\n    let isComplete = false;\n    return function shareReplayOperation(source) {\n        refCount++;\n        let innerSub;\n        if (!subject || hasError) {\n            hasError = false;\n            subject = new ReplaySubject_ReplaySubject(bufferSize, windowTime, scheduler);\n            innerSub = subject.subscribe(this);\n            subscription = source.subscribe({\n                next(value) {\n                    subject.next(value);\n                },\n                error(err) {\n                    hasError = true;\n                    subject.error(err);\n                },\n                complete() {\n                    isComplete = true;\n                    subscription = undefined;\n                    subject.complete();\n                },\n            });\n            if (isComplete) {\n                subscription = undefined;\n            }\n        }\n        else {\n            innerSub = subject.subscribe(this);\n        }\n        this.add(() => {\n            refCount--;\n            innerSub.unsubscribe();\n            innerSub = undefined;\n            if (subscription && !isComplete && useRefCount && refCount === 0) {\n                subscription.unsubscribe();\n                subscription = undefined;\n                subject = undefined;\n            }\n        });\n    };\n}\n//# sourceMappingURL=shareReplay.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/collections.js\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nclass DataSource {\n}\n/** Checks whether an object is a data source. */\nfunction isDataSource(value) {\n    // Check if the value is a DataSource by observing if it has a connect function. Cannot\n    // be checked as an `instanceof DataSource` since people could create their own sources\n    // that match the interface, but don't extend DataSource.\n    return value && typeof value.connect === 'function';\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** DataSource wrapper for a native array. */\nclass collections_ArrayDataSource extends DataSource {\n    constructor(_data) {\n        super();\n        this._data = _data;\n    }\n    connect() {\n        return isObservable(this._data) ? this._data : Object(of[\"a\" /* of */])(this._data);\n    }\n    disconnect() { }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A repeater that destroys views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will always construct a new embedded view for each item.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _DisposeViewRepeaterStrategy {\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) {\n                const insertContext = itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = viewContainerRef.createEmbeddedView(insertContext.templateRef, insertContext.context, insertContext.index);\n                operation = 1 /* INSERTED */;\n            }\n            else if (currentIndex == null) {\n                viewContainerRef.remove(adjustedPreviousIndex);\n                operation = 3 /* REMOVED */;\n            }\n            else {\n                view = viewContainerRef.get(adjustedPreviousIndex);\n                viewContainerRef.move(view, currentIndex);\n                operation = 2 /* MOVED */;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view === null || view === void 0 ? void 0 : view.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() {\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A repeater that caches views when they are removed from a\n * {@link ViewContainerRef}. When new items are inserted into the container,\n * the repeater will reuse one of the cached views instead of creating a new\n * embedded view. Recycling cached views reduces the quantity of expensive DOM\n * inserts.\n *\n * @template T The type for the embedded view's $implicit property.\n * @template R The type for the item in each IterableDiffer change record.\n * @template C The type for the context passed to each embedded view.\n */\nclass _RecycleViewRepeaterStrategy {\n    constructor() {\n        /**\n         * The size of the cache used to store unused views.\n         * Setting the cache size to `0` will disable caching. Defaults to 20 views.\n         */\n        this.viewCacheSize = 20;\n        /**\n         * View cache that stores embedded view instances that have been previously stamped out,\n         * but don't are not currently rendered. The view repeater will reuse these views rather than\n         * creating brand new ones.\n         *\n         * TODO(michaeljamesparsons) Investigate whether using a linked list would improve performance.\n         */\n        this._viewCache = [];\n    }\n    /** Apply changes to the DOM. */\n    applyChanges(changes, viewContainerRef, itemContextFactory, itemValueResolver, itemViewChanged) {\n        // Rearrange the views to put them in the right location.\n        changes.forEachOperation((record, adjustedPreviousIndex, currentIndex) => {\n            let view;\n            let operation;\n            if (record.previousIndex == null) { // Item added.\n                const viewArgsFactory = () => itemContextFactory(record, adjustedPreviousIndex, currentIndex);\n                view = this._insertView(viewArgsFactory, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = view ? 1 /* INSERTED */ : 0 /* REPLACED */;\n            }\n            else if (currentIndex == null) { // Item removed.\n                this._detachAndCacheView(adjustedPreviousIndex, viewContainerRef);\n                operation = 3 /* REMOVED */;\n            }\n            else { // Item moved.\n                view = this._moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, itemValueResolver(record));\n                operation = 2 /* MOVED */;\n            }\n            if (itemViewChanged) {\n                itemViewChanged({\n                    context: view === null || view === void 0 ? void 0 : view.context,\n                    operation,\n                    record,\n                });\n            }\n        });\n    }\n    detach() {\n        for (const view of this._viewCache) {\n            view.destroy();\n        }\n        this._viewCache = [];\n    }\n    /**\n     * Inserts a view for a new item, either from the cache or by creating a new\n     * one. Returns `undefined` if the item was inserted into a cached view.\n     */\n    _insertView(viewArgsFactory, currentIndex, viewContainerRef, value) {\n        const cachedView = this._insertViewFromCache(currentIndex, viewContainerRef);\n        if (cachedView) {\n            cachedView.context.$implicit = value;\n            return undefined;\n        }\n        const viewArgs = viewArgsFactory();\n        return viewContainerRef.createEmbeddedView(viewArgs.templateRef, viewArgs.context, viewArgs.index);\n    }\n    /** Detaches the view at the given index and inserts into the view cache. */\n    _detachAndCacheView(index, viewContainerRef) {\n        const detachedView = viewContainerRef.detach(index);\n        this._maybeCacheView(detachedView, viewContainerRef);\n    }\n    /** Moves view at the previous index to the current index. */\n    _moveView(adjustedPreviousIndex, currentIndex, viewContainerRef, value) {\n        const view = viewContainerRef.get(adjustedPreviousIndex);\n        viewContainerRef.move(view, currentIndex);\n        view.context.$implicit = value;\n        return view;\n    }\n    /**\n     * Cache the given detached view. If the cache is full, the view will be\n     * destroyed.\n     */\n    _maybeCacheView(view, viewContainerRef) {\n        if (this._viewCache.length < this.viewCacheSize) {\n            this._viewCache.push(view);\n        }\n        else {\n            const index = viewContainerRef.indexOf(view);\n            // The host component could remove views from the container outside of\n            // the view repeater. It's unlikely this will occur, but just in case,\n            // destroy the view on its own, otherwise destroy it through the\n            // container to ensure that all the references are removed.\n            if (index === -1) {\n                view.destroy();\n            }\n            else {\n                viewContainerRef.remove(index);\n            }\n        }\n    }\n    /** Inserts a recycled view from the cache at the given index. */\n    _insertViewFromCache(index, viewContainerRef) {\n        const cachedView = this._viewCache.pop();\n        if (cachedView) {\n            viewContainerRef.insert(cachedView, index);\n        }\n        return cachedView || null;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Class to be used to power selecting one or more options from a list.\n */\nclass collections_SelectionModel {\n    constructor(_multiple = false, initiallySelectedValues, _emitChanges = true) {\n        this._multiple = _multiple;\n        this._emitChanges = _emitChanges;\n        /** Currently-selected values. */\n        this._selection = new Set();\n        /** Keeps track of the deselected options that haven't been emitted by the change event. */\n        this._deselectedToEmit = [];\n        /** Keeps track of the selected options that haven't been emitted by the change event. */\n        this._selectedToEmit = [];\n        /** Event emitted when the value has changed. */\n        this.changed = new Subject[\"a\" /* Subject */]();\n        if (initiallySelectedValues && initiallySelectedValues.length) {\n            if (_multiple) {\n                initiallySelectedValues.forEach(value => this._markSelected(value));\n            }\n            else {\n                this._markSelected(initiallySelectedValues[0]);\n            }\n            // Clear the array in order to avoid firing the change event for preselected values.\n            this._selectedToEmit.length = 0;\n        }\n    }\n    /** Selected values. */\n    get selected() {\n        if (!this._selected) {\n            this._selected = Array.from(this._selection.values());\n        }\n        return this._selected;\n    }\n    /**\n     * Selects a value or an array of values.\n     */\n    select(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._markSelected(value));\n        this._emitChangeEvent();\n    }\n    /**\n     * Deselects a value or an array of values.\n     */\n    deselect(...values) {\n        this._verifyValueAssignment(values);\n        values.forEach(value => this._unmarkSelected(value));\n        this._emitChangeEvent();\n    }\n    /**\n     * Toggles a value between selected and deselected.\n     */\n    toggle(value) {\n        this.isSelected(value) ? this.deselect(value) : this.select(value);\n    }\n    /**\n     * Clears all of the selected values.\n     */\n    clear() {\n        this._unmarkAll();\n        this._emitChangeEvent();\n    }\n    /**\n     * Determines whether a value is selected.\n     */\n    isSelected(value) {\n        return this._selection.has(value);\n    }\n    /**\n     * Determines whether the model does not have a value.\n     */\n    isEmpty() {\n        return this._selection.size === 0;\n    }\n    /**\n     * Determines whether the model has a value.\n     */\n    hasValue() {\n        return !this.isEmpty();\n    }\n    /**\n     * Sorts the selected values based on a predicate function.\n     */\n    sort(predicate) {\n        if (this._multiple && this.selected) {\n            this._selected.sort(predicate);\n        }\n    }\n    /**\n     * Gets whether multiple values can be selected.\n     */\n    isMultipleSelection() {\n        return this._multiple;\n    }\n    /** Emits a change event and clears the records of selected and deselected values. */\n    _emitChangeEvent() {\n        // Clear the selected values so they can be re-cached.\n        this._selected = null;\n        if (this._selectedToEmit.length || this._deselectedToEmit.length) {\n            this.changed.next({\n                source: this,\n                added: this._selectedToEmit,\n                removed: this._deselectedToEmit\n            });\n            this._deselectedToEmit = [];\n            this._selectedToEmit = [];\n        }\n    }\n    /** Selects a value. */\n    _markSelected(value) {\n        if (!this.isSelected(value)) {\n            if (!this._multiple) {\n                this._unmarkAll();\n            }\n            this._selection.add(value);\n            if (this._emitChanges) {\n                this._selectedToEmit.push(value);\n            }\n        }\n    }\n    /** Deselects a value. */\n    _unmarkSelected(value) {\n        if (this.isSelected(value)) {\n            this._selection.delete(value);\n            if (this._emitChanges) {\n                this._deselectedToEmit.push(value);\n            }\n        }\n    }\n    /** Clears out the selected values. */\n    _unmarkAll() {\n        if (!this.isEmpty()) {\n            this._selection.forEach(value => this._unmarkSelected(value));\n        }\n    }\n    /**\n     * Verifies the value assignment and throws an error if the specified value array is\n     * including multiple values while the selection model is not supporting multiple values.\n     */\n    _verifyValueAssignment(values) {\n        if (values.length > 1 && !this._multiple && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMultipleValuesInSingleSelectionError();\n        }\n    }\n}\n/**\n * Returns an error that reports that multiple values are passed into a selection model\n * with a single value.\n * @docs-private\n */\nfunction getMultipleValuesInSingleSelectionError() {\n    return Error('Cannot pass multiple values into SelectionModel with single-value mode.');\n}\nlet collections_UniqueSelectionDispatcher = /*@__PURE__*/ (() => {\n    class UniqueSelectionDispatcher {\n        constructor() {\n            this._listeners = [];\n        }\n        /**\n         * Notify other items that selection for the given name has been set.\n         * @param id ID of the item.\n         * @param name Name of the item.\n         */\n        notify(id, name) {\n            for (let listener of this._listeners) {\n                listener(id, name);\n            }\n        }\n        /**\n         * Listen for future changes to item selection.\n         * @return Function used to deregister listener\n         */\n        listen(listener) {\n            this._listeners.push(listener);\n            return () => {\n                this._listeners = this._listeners.filter((registered) => {\n                    return listener !== registered;\n                });\n            };\n        }\n        ngOnDestroy() {\n            this._listeners = [];\n        }\n    }\n    UniqueSelectionDispatcher.fac = function UniqueSelectionDispatcher_Factory(t) { return new (t || UniqueSelectionDispatcher)(); };\n    UniqueSelectionDispatcher.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function UniqueSelectionDispatcher_Factory() { return new UniqueSelectionDispatcher(); }, token: UniqueSelectionDispatcher, providedIn: \"root\" });\n    return UniqueSelectionDispatcher;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token for {@link _ViewRepeater}. This token is for use by Angular Material only.\n * @docs-private\n */\nconst _VIEW_REPEATER_STRATEGY = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('_ViewRepeater');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=collections.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/scrolling.js\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The injection token used to specify the virtual scrolling strategy. */\n\n\n\n\nconst scrolling_c0 = [\"contentWrapper\"];\nconst scrolling_c1 = [\"*\"];\nconst VIRTUAL_SCROLL_STRATEGY = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('VIRTUAL_SCROLL_STRATEGY');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Virtual scrolling strategy for lists with items of known fixed size. */\nclass scrolling_FixedSizeVirtualScrollStrategy {\n    /**\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    constructor(itemSize, minBufferPx, maxBufferPx) {\n        this._scrolledIndexChange = new Subject[\"a\" /* Subject */]();\n        /** @docs-private Implemented as part of VirtualScrollStrategy. */\n        this.scrolledIndexChange = this._scrolledIndexChange.pipe(distinctUntilChanged());\n        /** The attached viewport. */\n        this._viewport = null;\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n    }\n    /**\n     * Attaches this scroll strategy to a viewport.\n     * @param viewport The viewport to attach this strategy to.\n     */\n    attach(viewport) {\n        this._viewport = viewport;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** Detaches this scroll strategy from the currently attached viewport. */\n    detach() {\n        this._scrolledIndexChange.complete();\n        this._viewport = null;\n    }\n    /**\n     * Update the item size and buffer size.\n     * @param itemSize The size of the items in the virtually scrolling list.\n     * @param minBufferPx The minimum amount of buffer (in pixels) before needing to render more\n     * @param maxBufferPx The amount of buffer (in pixels) to render when rendering more.\n     */\n    updateItemAndBufferSize(itemSize, minBufferPx, maxBufferPx) {\n        if (maxBufferPx < minBufferPx && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('CDK virtual scroll: maxBufferPx must be greater than or equal to minBufferPx');\n        }\n        this._itemSize = itemSize;\n        this._minBufferPx = minBufferPx;\n        this._maxBufferPx = maxBufferPx;\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentScrolled() {\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onDataLengthChanged() {\n        this._updateTotalContentSize();\n        this._updateRenderedRange();\n    }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onContentRendered() { }\n    /** @docs-private Implemented as part of VirtualScrollStrategy. */\n    onRenderedOffsetChanged() { }\n    /**\n     * Scroll to the offset for the given index.\n     * @param index The index of the element to scroll to.\n     * @param behavior The ScrollBehavior to use when scrolling.\n     */\n    scrollToIndex(index, behavior) {\n        if (this._viewport) {\n            this._viewport.scrollToOffset(index * this._itemSize, behavior);\n        }\n    }\n    /** Update the viewport's total content size. */\n    _updateTotalContentSize() {\n        if (!this._viewport) {\n            return;\n        }\n        this._viewport.setTotalContentSize(this._viewport.getDataLength() * this._itemSize);\n    }\n    /** Update the viewport's rendered range. */\n    _updateRenderedRange() {\n        if (!this._viewport) {\n            return;\n        }\n        const renderedRange = this._viewport.getRenderedRange();\n        const newRange = { start: renderedRange.start, end: renderedRange.end };\n        const viewportSize = this._viewport.getViewportSize();\n        const dataLength = this._viewport.getDataLength();\n        let scrollOffset = this._viewport.measureScrollOffset();\n        // Prevent NaN as result when dividing by zero.\n        let firstVisibleIndex = (this._itemSize > 0) ? scrollOffset / this._itemSize : 0;\n        // If user scrolls to the bottom of the list and data changes to a smaller list\n        if (newRange.end > dataLength) {\n            // We have to recalculate the first visible index based on new data length and viewport size.\n            const maxVisibleItems = Math.ceil(viewportSize / this._itemSize);\n            const newVisibleIndex = Math.max(0, Math.min(firstVisibleIndex, dataLength - maxVisibleItems));\n            // If first visible index changed we must update scroll offset to handle start/end buffers\n            // Current range must also be adjusted to cover the new position (bottom of new list).\n            if (firstVisibleIndex != newVisibleIndex) {\n                firstVisibleIndex = newVisibleIndex;\n                scrollOffset = newVisibleIndex * this._itemSize;\n                newRange.start = Math.floor(firstVisibleIndex);\n            }\n            newRange.end = Math.max(0, Math.min(dataLength, newRange.start + maxVisibleItems));\n        }\n        const startBuffer = scrollOffset - newRange.start * this._itemSize;\n        if (startBuffer < this._minBufferPx && newRange.start != 0) {\n            const expandStart = Math.ceil((this._maxBufferPx - startBuffer) / this._itemSize);\n            newRange.start = Math.max(0, newRange.start - expandStart);\n            newRange.end = Math.min(dataLength, Math.ceil(firstVisibleIndex + (viewportSize + this._minBufferPx) / this._itemSize));\n        }\n        else {\n            const endBuffer = newRange.end * this._itemSize - (scrollOffset + viewportSize);\n            if (endBuffer < this._minBufferPx && newRange.end != dataLength) {\n                const expandEnd = Math.ceil((this._maxBufferPx - endBuffer) / this._itemSize);\n                if (expandEnd > 0) {\n                    newRange.end = Math.min(dataLength, newRange.end + expandEnd);\n                    newRange.start = Math.max(0, Math.floor(firstVisibleIndex - this._minBufferPx / this._itemSize));\n                }\n            }\n        }\n        this._viewport.setRenderedRange(newRange);\n        this._viewport.setRenderedContentOffset(this._itemSize * newRange.start);\n        this._scrolledIndexChange.next(Math.floor(firstVisibleIndex));\n    }\n}\n/**\n * Provider factory for `FixedSizeVirtualScrollStrategy` that simply extracts the already created\n * `FixedSizeVirtualScrollStrategy` from the given directive.\n * @param fixedSizeDir The instance of `CdkFixedSizeVirtualScroll` to extract the\n *     `FixedSizeVirtualScrollStrategy` from.\n */\nfunction _fixedSizeVirtualScrollStrategyFactory(fixedSizeDir) {\n    return fixedSizeDir._scrollStrategy;\n}\nlet scrolling_CdkFixedSizeVirtualScroll = /*@__PURE__*/ (() => {\n    class CdkFixedSizeVirtualScroll {\n        constructor() {\n            this._itemSize = 20;\n            this._minBufferPx = 100;\n            this._maxBufferPx = 200;\n            /** The scroll strategy used by this directive. */\n            this._scrollStrategy = new scrolling_FixedSizeVirtualScrollStrategy(this.itemSize, this.minBufferPx, this.maxBufferPx);\n        }\n        /** The size of the items in the list (in pixels). */\n        get itemSize() { return this._itemSize; }\n        set itemSize(value) { this._itemSize = coerceNumberProperty(value); }\n        /**\n         * The minimum amount of buffer rendered beyond the viewport (in pixels).\n         * If the amount of buffer dips below this number, more items will be rendered. Defaults to 100px.\n         */\n        get minBufferPx() { return this._minBufferPx; }\n        set minBufferPx(value) { this._minBufferPx = coerceNumberProperty(value); }\n        /**\n         * The number of pixels worth of buffer to render for when rendering new items. Defaults to 200px.\n         */\n        get maxBufferPx() { return this._maxBufferPx; }\n        set maxBufferPx(value) { this._maxBufferPx = coerceNumberProperty(value); }\n        ngOnChanges() {\n            this._scrollStrategy.updateItemAndBufferSize(this.itemSize, this.minBufferPx, this.maxBufferPx);\n        }\n    }\n    CdkFixedSizeVirtualScroll.fac = function CdkFixedSizeVirtualScroll_Factory(t) { return new (t || CdkFixedSizeVirtualScroll)(); };\n    CdkFixedSizeVirtualScroll.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: CdkFixedSizeVirtualScroll, selectors: [[\"cdk-virtual-scroll-viewport\", \"itemSize\", \"\"]], inputs: { itemSize: \"itemSize\", minBufferPx: \"minBufferPx\", maxBufferPx: \"maxBufferPx\" }, features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{\n                    provide: VIRTUAL_SCROLL_STRATEGY,\n                    useFactory: _fixedSizeVirtualScrollStrategyFactory,\n                    deps: [/*@__PURE__*/ Object(core[\"U\" /* forwardRef */])(() => CdkFixedSizeVirtualScroll)]\n                }]), core[\"yb\" /* NgOnChangesFeature */]] });\n    return CdkFixedSizeVirtualScroll;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Time in ms to throttle the scrolling events by default. */\nconst DEFAULT_SCROLL_TIME = 20;\nlet scrolling_ScrollDispatcher = /*@__PURE__*/ (() => {\n    class ScrollDispatcher {\n        constructor(_ngZone, _platform, document) {\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            /** Subject for notifying that a registered scrollable reference element has been scrolled. */\n            this._scrolled = new Subject[\"a\" /* Subject */]();\n            /** Keeps track of the global `scroll` and `resize` subscriptions. */\n            this._globalSubscription = null;\n            /** Keeps track of the amount of subscriptions to `scrolled`. Used for cleaning up afterwards. */\n            this._scrolledCount = 0;\n            /**\n             * Map of all the scrollable references that are registered with the service and their\n             * scroll event subscriptions.\n             */\n            this.scrollContainers = new Map();\n            this._document = document;\n        }\n        /**\n         * Registers a scrollable instance with the service and listens for its scrolled events. When the\n         * scrollable is scrolled, the service emits the event to its scrolled observable.\n         * @param scrollable Scrollable instance to be registered.\n         */\n        register(scrollable) {\n            if (!this.scrollContainers.has(scrollable)) {\n                this.scrollContainers.set(scrollable, scrollable.elementScrolled()\n                    .subscribe(() => this._scrolled.next(scrollable)));\n            }\n        }\n        /**\n         * Deregisters a Scrollable reference and unsubscribes from its scroll event observable.\n         * @param scrollable Scrollable instance to be deregistered.\n         */\n        deregister(scrollable) {\n            const scrollableReference = this.scrollContainers.get(scrollable);\n            if (scrollableReference) {\n                scrollableReference.unsubscribe();\n                this.scrollContainers.delete(scrollable);\n            }\n        }\n        /**\n         * Returns an observable that emits an event whenever any of the registered Scrollable\n         * references (or window, document, or body) fire a scrolled event. Can provide a time in ms\n         * to override the default \"throttle\" time.\n         *\n         * **Note:** in order to avoid hitting change detection for every scroll event,\n         * all of the events emitted from this stream will be run outside the Angular zone.\n         * If you need to update any data bindings as a result of a scroll event, you have\n         * to run the callback using `NgZone.run`.\n         */\n        scrolled(auditTimeInMs = DEFAULT_SCROLL_TIME) {\n            if (!this._platform.isBrowser) {\n                return Object(of[\"a\" /* of */])();\n            }\n            return new Observable[\"a\" /* Observable */]((observer) => {\n                if (!this._globalSubscription) {\n                    this._addGlobalListener();\n                }\n                // In the case of a 0ms delay, use an observable without auditTime\n                // since it does add a perceptible delay in processing overhead.\n                const subscription = auditTimeInMs > 0 ?\n                    this._scrolled.pipe(auditTime(auditTimeInMs)).subscribe(observer) :\n                    this._scrolled.subscribe(observer);\n                this._scrolledCount++;\n                return () => {\n                    subscription.unsubscribe();\n                    this._scrolledCount--;\n                    if (!this._scrolledCount) {\n                        this._removeGlobalListener();\n                    }\n                };\n            });\n        }\n        ngOnDestroy() {\n            this._removeGlobalListener();\n            this.scrollContainers.forEach((_, container) => this.deregister(container));\n            this._scrolled.complete();\n        }\n        /**\n         * Returns an observable that emits whenever any of the\n         * scrollable ancestors of an element are scrolled.\n         * @param elementOrElementRef Element whose ancestors to listen for.\n         * @param auditTimeInMs Time to throttle the scroll events.\n         */\n        ancestorScrolled(elementOrElementRef, auditTimeInMs) {\n            const ancestors = this.getAncestorScrollContainers(elementOrElementRef);\n            return this.scrolled(auditTimeInMs).pipe(Object(filter[\"a\" /* filter */])(target => {\n                return !target || ancestors.indexOf(target) > -1;\n            }));\n        }\n        /** Returns all registered Scrollables that contain the provided element. */\n        getAncestorScrollContainers(elementOrElementRef) {\n            const scrollingContainers = [];\n            this.scrollContainers.forEach((_subscription, scrollable) => {\n                if (this._scrollableContainsElement(scrollable, elementOrElementRef)) {\n                    scrollingContainers.push(scrollable);\n                }\n            });\n            return scrollingContainers;\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            return this._document.defaultView || window;\n        }\n        /** Returns true if the element is contained within the provided Scrollable. */\n        _scrollableContainsElement(scrollable, elementOrElementRef) {\n            let element = coerceElement(elementOrElementRef);\n            let scrollableElement = scrollable.getElementRef().nativeElement;\n            // Traverse through the element parents until we reach null, checking if any of the elements\n            // are the scrollable's element.\n            do {\n                if (element == scrollableElement) {\n                    return true;\n                }\n            } while (element = element.parentElement);\n            return false;\n        }\n        /** Sets up the global scroll listeners. */\n        _addGlobalListener() {\n            this._globalSubscription = this._ngZone.runOutsideAngular(() => {\n                const window = this._getWindow();\n                return fromEvent(window.document, 'scroll').subscribe(() => this._scrolled.next());\n            });\n        }\n        /** Cleans up the global scroll listener. */\n        _removeGlobalListener() {\n            if (this._globalSubscription) {\n                this._globalSubscription.unsubscribe();\n                this._globalSubscription = null;\n            }\n        }\n    }\n    ScrollDispatcher.fac = function ScrollDispatcher_Factory(t) { return new (t || ScrollDispatcher)(core[\"Wb\" /* inject */](core[\"A\" /* NgZone */]), core[\"Wb\" /* inject */](platform_Platform), core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */], 8)); };\n    ScrollDispatcher.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function ScrollDispatcher_Factory() { return new ScrollDispatcher(Object(core[\"Wb\" /* inject */])(core[\"A\" /* NgZone */]), Object(core[\"Wb\" /* inject */])(platform_Platform), Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */], 8)); }, token: ScrollDispatcher, providedIn: \"root\" });\n    return ScrollDispatcher;\n})();\nlet scrolling_CdkScrollable = /*@__PURE__*/ (() => {\n    class CdkScrollable {\n        constructor(elementRef, scrollDispatcher, ngZone, dir) {\n            this.elementRef = elementRef;\n            this.scrollDispatcher = scrollDispatcher;\n            this.ngZone = ngZone;\n            this.dir = dir;\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            this._elementScrolled = new Observable[\"a\" /* Observable */]((observer) => this.ngZone.runOutsideAngular(() => fromEvent(this.elementRef.nativeElement, 'scroll').pipe(takeUntil(this._destroyed))\n                .subscribe(observer)));\n        }\n        ngOnInit() {\n            this.scrollDispatcher.register(this);\n        }\n        ngOnDestroy() {\n            this.scrollDispatcher.deregister(this);\n            this._destroyed.next();\n            this._destroyed.complete();\n        }\n        /** Returns observable that emits when a scroll event is fired on the host element. */\n        elementScrolled() {\n            return this._elementScrolled;\n        }\n        /** Gets the ElementRef for the viewport. */\n        getElementRef() {\n            return this.elementRef;\n        }\n        /**\n         * Scrolls to the specified offsets. This is a normalized version of the browser's native scrollTo\n         * method, since browsers are not consistent about what scrollLeft means in RTL. For this method\n         * left and right always refer to the left and right side of the scrolling container irrespective\n         * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n         * in an RTL context.\n         * @param options specified the offsets to scroll to.\n         */\n        scrollTo(options) {\n            const el = this.elementRef.nativeElement;\n            const isRtl = this.dir && this.dir.value == 'rtl';\n            // Rewrite start & end offsets as right or left offsets.\n            if (options.left == null) {\n                options.left = isRtl ? options.end : options.start;\n            }\n            if (options.right == null) {\n                options.right = isRtl ? options.start : options.end;\n            }\n            // Rewrite the bottom offset as a top offset.\n            if (options.bottom != null) {\n                options.top =\n                    el.scrollHeight - el.clientHeight - options.bottom;\n            }\n            // Rewrite the right offset as a left offset.\n            if (isRtl && getRtlScrollAxisType() != 0 /* NORMAL */) {\n                if (options.left != null) {\n                    options.right =\n                        el.scrollWidth - el.clientWidth - options.left;\n                }\n                if (getRtlScrollAxisType() == 2 /* INVERTED */) {\n                    options.left = options.right;\n                }\n                else if (getRtlScrollAxisType() == 1 /* NEGATED */) {\n                    options.left = options.right ? -options.right : options.right;\n                }\n            }\n            else {\n                if (options.right != null) {\n                    options.left =\n                        el.scrollWidth - el.clientWidth - options.right;\n                }\n            }\n            this._applyScrollToOptions(options);\n        }\n        _applyScrollToOptions(options) {\n            const el = this.elementRef.nativeElement;\n            if (supportsScrollBehavior()) {\n                el.scrollTo(options);\n            }\n            else {\n                if (options.top != null) {\n                    el.scrollTop = options.top;\n                }\n                if (options.left != null) {\n                    el.scrollLeft = options.left;\n                }\n            }\n        }\n        /**\n         * Measures the scroll offset relative to the specified edge of the viewport. This method can be\n         * used instead of directly checking scrollLeft or scrollTop, since browsers are not consistent\n         * about what scrollLeft means in RTL. The values returned by this method are normalized such that\n         * left and right always refer to the left and right side of the scrolling container irrespective\n         * of the layout direction. start and end refer to left and right in an LTR context and vice-versa\n         * in an RTL context.\n         * @param from The edge to measure from.\n         */\n        measureScrollOffset(from) {\n            const LEFT = 'left';\n            const RIGHT = 'right';\n            const el = this.elementRef.nativeElement;\n            if (from == 'top') {\n                return el.scrollTop;\n            }\n            if (from == 'bottom') {\n                return el.scrollHeight - el.clientHeight - el.scrollTop;\n            }\n            // Rewrite start & end as left or right offsets.\n            const isRtl = this.dir && this.dir.value == 'rtl';\n            if (from == 'start') {\n                from = isRtl ? RIGHT : LEFT;\n            }\n            else if (from == 'end') {\n                from = isRtl ? LEFT : RIGHT;\n            }\n            if (isRtl && getRtlScrollAxisType() == 2 /* INVERTED */) {\n                // For INVERTED, scrollLeft is (scrollWidth - clientWidth) when scrolled all the way left and\n                // 0 when scrolled all the way right.\n                if (from == LEFT) {\n                    return el.scrollWidth - el.clientWidth - el.scrollLeft;\n                }\n                else {\n                    return el.scrollLeft;\n                }\n            }\n            else if (isRtl && getRtlScrollAxisType() == 1 /* NEGATED */) {\n                // For NEGATED, scrollLeft is -(scrollWidth - clientWidth) when scrolled all the way left and\n                // 0 when scrolled all the way right.\n                if (from == LEFT) {\n                    return el.scrollLeft + el.scrollWidth - el.clientWidth;\n                }\n                else {\n                    return -el.scrollLeft;\n                }\n            }\n            else {\n                // For NORMAL, as well as non-RTL contexts, scrollLeft is 0 when scrolled all the way left and\n                // (scrollWidth - clientWidth) when scrolled all the way right.\n                if (from == LEFT) {\n                    return el.scrollLeft;\n                }\n                else {\n                    return el.scrollWidth - el.clientWidth - el.scrollLeft;\n                }\n            }\n        }\n    }\n    CdkScrollable.fac = function CdkScrollable_Factory(t) { return new (t || CdkScrollable)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](scrolling_ScrollDispatcher), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8)); };\n    CdkScrollable.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: CdkScrollable, selectors: [[\"\", \"cdk-scrollable\", \"\"], [\"\", \"cdkScrollable\", \"\"]] });\n    return CdkScrollable;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Time in ms to throttle the resize events by default. */\nconst DEFAULT_RESIZE_TIME = 20;\nlet scrolling_ViewportRuler = /*@__PURE__*/ (() => {\n    class ViewportRuler {\n        constructor(_platform, ngZone, document) {\n            this._platform = _platform;\n            /** Stream of viewport change events. */\n            this._change = new Subject[\"a\" /* Subject */]();\n            /** Event listener that will be used to handle the viewport change events. */\n            this._changeListener = (event) => {\n                this._change.next(event);\n            };\n            this._document = document;\n            ngZone.runOutsideAngular(() => {\n                if (_platform.isBrowser) {\n                    const window = this._getWindow();\n                    // Note that bind the events ourselves, rather than going through something like RxJS's\n                    // `fromEvent` so that we can ensure that they're bound outside of the NgZone.\n                    window.addEventListener('resize', this._changeListener);\n                    window.addEventListener('orientationchange', this._changeListener);\n                }\n                // We don't need to keep track of the subscription,\n                // because we complete the `change` stream on destroy.\n                this.change().subscribe(() => this._updateViewportSize());\n            });\n        }\n        ngOnDestroy() {\n            if (this._platform.isBrowser) {\n                const window = this._getWindow();\n                window.removeEventListener('resize', this._changeListener);\n                window.removeEventListener('orientationchange', this._changeListener);\n            }\n            this._change.complete();\n        }\n        /** Returns the viewport's width and height. */\n        getViewportSize() {\n            if (!this._viewportSize) {\n                this._updateViewportSize();\n            }\n            const output = { width: this._viewportSize.width, height: this._viewportSize.height };\n            // If we're not on a browser, don't cache the size since it'll be mocked out anyway.\n            if (!this._platform.isBrowser) {\n                this._viewportSize = null;\n            }\n            return output;\n        }\n        /** Gets a ClientRect for the viewport's bounds. */\n        getViewportRect() {\n            // Use the document element's bounding rect rather than the window scroll properties\n            // (e.g. pageYOffset, scrollY) due to in issue in Chrome and IE where window scroll\n            // properties and client coordinates (boundingClientRect, clientX/Y, etc.) are in different\n            // conceptual viewports. Under most circumstances these viewports are equivalent, but they\n            // can disagree when the page is pinch-zoomed (on devices that support touch).\n            // See https://bugs.chromium.org/p/chromium/issues/detail?id=489206#c4\n            // We use the documentElement instead of the body because, by default (without a css reset)\n            // browsers typically give the document body an 8px margin, which is not included in\n            // getBoundingClientRect().\n            const scrollPosition = this.getViewportScrollPosition();\n            const { width, height } = this.getViewportSize();\n            return {\n                top: scrollPosition.top,\n                left: scrollPosition.left,\n                bottom: scrollPosition.top + height,\n                right: scrollPosition.left + width,\n                height,\n                width,\n            };\n        }\n        /** Gets the (top, left) scroll position of the viewport. */\n        getViewportScrollPosition() {\n            // While we can get a reference to the fake document\n            // during SSR, it doesn't have getBoundingClientRect.\n            if (!this._platform.isBrowser) {\n                return { top: 0, left: 0 };\n            }\n            // The top-left-corner of the viewport is determined by the scroll position of the document\n            // body, normally just (scrollLeft, scrollTop). However, Chrome and Firefox disagree about\n            // whether `document.body` or `document.documentElement` is the scrolled element, so reading\n            // `scrollTop` and `scrollLeft` is inconsistent. However, using the bounding rect of\n            // `document.documentElement` works consistently, where the `top` and `left` values will\n            // equal negative the scroll position.\n            const document = this._document;\n            const window = this._getWindow();\n            const documentElement = document.documentElement;\n            const documentRect = documentElement.getBoundingClientRect();\n            const top = -documentRect.top || document.body.scrollTop || window.scrollY ||\n                documentElement.scrollTop || 0;\n            const left = -documentRect.left || document.body.scrollLeft || window.scrollX ||\n                documentElement.scrollLeft || 0;\n            return { top, left };\n        }\n        /**\n         * Returns a stream that emits whenever the size of the viewport changes.\n         * @param throttleTime Time in milliseconds to throttle the stream.\n         */\n        change(throttleTime = DEFAULT_RESIZE_TIME) {\n            return throttleTime > 0 ? this._change.pipe(auditTime(throttleTime)) : this._change;\n        }\n        /** Use defaultView of injected document if available or fallback to global window reference */\n        _getWindow() {\n            return this._document.defaultView || window;\n        }\n        /** Updates the cached viewport size. */\n        _updateViewportSize() {\n            const window = this._getWindow();\n            this._viewportSize = this._platform.isBrowser ?\n                { width: window.innerWidth, height: window.innerHeight } :\n                { width: 0, height: 0 };\n        }\n    }\n    ViewportRuler.fac = function ViewportRuler_Factory(t) { return new (t || ViewportRuler)(core[\"Wb\" /* inject */](platform_Platform), core[\"Wb\" /* inject */](core[\"A\" /* NgZone */]), core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */], 8)); };\n    ViewportRuler.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function ViewportRuler_Factory() { return new ViewportRuler(Object(core[\"Wb\" /* inject */])(platform_Platform), Object(core[\"Wb\" /* inject */])(core[\"A\" /* NgZone */]), Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */], 8)); }, token: ViewportRuler, providedIn: \"root\" });\n    return ViewportRuler;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Checks if the given ranges are equal. */\nfunction rangesEqual(r1, r2) {\n    return r1.start == r2.start && r1.end == r2.end;\n}\n/**\n * Scheduler to be used for scroll events. Needs to fall back to\n * something that doesn't rely on requestAnimationFrame on environments\n * that don't support it (e.g. server-side rendering).\n */\nconst SCROLL_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\nlet scrolling_CdkVirtualScrollViewport = /*@__PURE__*/ (() => {\n    class CdkVirtualScrollViewport extends scrolling_CdkScrollable {\n        constructor(elementRef, _changeDetectorRef, ngZone, _scrollStrategy, dir, scrollDispatcher, viewportRuler) {\n            super(elementRef, scrollDispatcher, ngZone, dir);\n            this.elementRef = elementRef;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._scrollStrategy = _scrollStrategy;\n            /** Emits when the viewport is detached from a CdkVirtualForOf. */\n            this._detachedSubject = new Subject[\"a\" /* Subject */]();\n            /** Emits when the rendered range changes. */\n            this._renderedRangeSubject = new Subject[\"a\" /* Subject */]();\n            this._orientation = 'vertical';\n            // Note: we don't use the typical EventEmitter here because we need to subscribe to the scroll\n            // strategy lazily (i.e. only if the user is actually listening to the events). We do this because\n            // depending on how the strategy calculates the scrolled index, it may come at a cost to\n            // performance.\n            /** Emits when the index of the first element visible in the viewport changes. */\n            this.scrolledIndexChange = new Observable[\"a\" /* Observable */]((observer) => this._scrollStrategy.scrolledIndexChange.subscribe(index => Promise.resolve().then(() => this.ngZone.run(() => observer.next(index)))));\n            /** A stream that emits whenever the rendered range changes. */\n            this.renderedRangeStream = this._renderedRangeSubject;\n            /**\n             * The total size of all content (in pixels), including content that is not currently rendered.\n             */\n            this._totalContentSize = 0;\n            /** A string representing the `style.width` property value to be used for the spacer element. */\n            this._totalContentWidth = '';\n            /** A string representing the `style.height` property value to be used for the spacer element. */\n            this._totalContentHeight = '';\n            /** The currently rendered range of indices. */\n            this._renderedRange = { start: 0, end: 0 };\n            /** The length of the data bound to this viewport (in number of items). */\n            this._dataLength = 0;\n            /** The size of the viewport (in pixels). */\n            this._viewportSize = 0;\n            /** The last rendered content offset that was set. */\n            this._renderedContentOffset = 0;\n            /**\n             * Whether the last rendered content offset was to the end of the content (and therefore needs to\n             * be rewritten as an offset to the start of the content).\n             */\n            this._renderedContentOffsetNeedsRewrite = false;\n            /** Whether there is a pending change detection cycle. */\n            this._isChangeDetectionPending = false;\n            /** A list of functions to run after the next change detection cycle. */\n            this._runAfterChangeDetection = [];\n            /** Subscription to changes in the viewport size. */\n            this._viewportChanges = Subscription[\"a\" /* Subscription */].EMPTY;\n            if (!_scrollStrategy && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('Error: cdk-virtual-scroll-viewport requires the \"itemSize\" property to be set.');\n            }\n            this._viewportChanges = viewportRuler.change().subscribe(() => {\n                this.checkViewportSize();\n            });\n        }\n        /** The direction the viewport scrolls. */\n        get orientation() {\n            return this._orientation;\n        }\n        set orientation(orientation) {\n            if (this._orientation !== orientation) {\n                this._orientation = orientation;\n                this._calculateSpacerSize();\n            }\n        }\n        ngOnInit() {\n            super.ngOnInit();\n            // It's still too early to measure the viewport at this point. Deferring with a promise allows\n            // the Viewport to be rendered with the correct size before we measure. We run this outside the\n            // zone to avoid causing more change detection cycles. We handle the change detection loop\n            // ourselves instead.\n            this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n                this._measureViewportSize();\n                this._scrollStrategy.attach(this);\n                this.elementScrolled()\n                    .pipe(\n                // Start off with a fake scroll event so we properly detect our initial position.\n                Object(startWith[\"a\" /* startWith */])(null), \n                // Collect multiple events into one until the next animation frame. This way if\n                // there are multiple scroll events in the same frame we only need to recheck\n                // our layout once.\n                auditTime(0, SCROLL_SCHEDULER))\n                    .subscribe(() => this._scrollStrategy.onContentScrolled());\n                this._markChangeDetectionNeeded();\n            }));\n        }\n        ngOnDestroy() {\n            this.detach();\n            this._scrollStrategy.detach();\n            // Complete all subjects\n            this._renderedRangeSubject.complete();\n            this._detachedSubject.complete();\n            this._viewportChanges.unsubscribe();\n            super.ngOnDestroy();\n        }\n        /** Attaches a `CdkVirtualScrollRepeater` to this viewport. */\n        attach(forOf) {\n            if (this._forOf && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error('CdkVirtualScrollViewport is already attached.');\n            }\n            // Subscribe to the data stream of the CdkVirtualForOf to keep track of when the data length\n            // changes. Run outside the zone to avoid triggering change detection, since we're managing the\n            // change detection loop ourselves.\n            this.ngZone.runOutsideAngular(() => {\n                this._forOf = forOf;\n                this._forOf.dataStream.pipe(takeUntil(this._detachedSubject)).subscribe(data => {\n                    const newLength = data.length;\n                    if (newLength !== this._dataLength) {\n                        this._dataLength = newLength;\n                        this._scrollStrategy.onDataLengthChanged();\n                    }\n                    this._doChangeDetection();\n                });\n            });\n        }\n        /** Detaches the current `CdkVirtualForOf`. */\n        detach() {\n            this._forOf = null;\n            this._detachedSubject.next();\n        }\n        /** Gets the length of the data bound to this viewport (in number of items). */\n        getDataLength() {\n            return this._dataLength;\n        }\n        /** Gets the size of the viewport (in pixels). */\n        getViewportSize() {\n            return this._viewportSize;\n        }\n        // TODO(mmalerba): This is technically out of sync with what's really rendered until a render\n        // cycle happens. I'm being careful to only call it after the render cycle is complete and before\n        // setting it to something else, but its error prone and should probably be split into\n        // `pendingRange` and `renderedRange`, the latter reflecting whats actually in the DOM.\n        /** Get the current rendered range of items. */\n        getRenderedRange() {\n            return this._renderedRange;\n        }\n        /**\n         * Sets the total size of all content (in pixels), including content that is not currently\n         * rendered.\n         */\n        setTotalContentSize(size) {\n            if (this._totalContentSize !== size) {\n                this._totalContentSize = size;\n                this._calculateSpacerSize();\n                this._markChangeDetectionNeeded();\n            }\n        }\n        /** Sets the currently rendered range of indices. */\n        setRenderedRange(range) {\n            if (!rangesEqual(this._renderedRange, range)) {\n                this._renderedRangeSubject.next(this._renderedRange = range);\n                this._markChangeDetectionNeeded(() => this._scrollStrategy.onContentRendered());\n            }\n        }\n        /**\n         * Gets the offset from the start of the viewport to the start of the rendered data (in pixels).\n         */\n        getOffsetToRenderedContentStart() {\n            return this._renderedContentOffsetNeedsRewrite ? null : this._renderedContentOffset;\n        }\n        /**\n         * Sets the offset from the start of the viewport to either the start or end of the rendered data\n         * (in pixels).\n         */\n        setRenderedContentOffset(offset, to = 'to-start') {\n            // For a horizontal viewport in a right-to-left language we need to translate along the x-axis\n            // in the negative direction.\n            const isRtl = this.dir && this.dir.value == 'rtl';\n            const isHorizontal = this.orientation == 'horizontal';\n            const axis = isHorizontal ? 'X' : 'Y';\n            const axisDirection = isHorizontal && isRtl ? -1 : 1;\n            let transform = `translate${axis}(${Number(axisDirection * offset)}px)`;\n            this._renderedContentOffset = offset;\n            if (to === 'to-end') {\n                transform += ` translate${axis}(-100%)`;\n                // The viewport should rewrite this as a `to-start` offset on the next render cycle. Otherwise\n                // elements will appear to expand in the wrong direction (e.g. `mat-expansion-panel` would\n                // expand upward).\n                this._renderedContentOffsetNeedsRewrite = true;\n            }\n            if (this._renderedContentTransform != transform) {\n                // We know this value is safe because we parse `offset` with `Number()` before passing it\n                // into the string.\n                this._renderedContentTransform = transform;\n                this._markChangeDetectionNeeded(() => {\n                    if (this._renderedContentOffsetNeedsRewrite) {\n                        this._renderedContentOffset -= this.measureRenderedContentSize();\n                        this._renderedContentOffsetNeedsRewrite = false;\n                        this.setRenderedContentOffset(this._renderedContentOffset);\n                    }\n                    else {\n                        this._scrollStrategy.onRenderedOffsetChanged();\n                    }\n                });\n            }\n        }\n        /**\n         * Scrolls to the given offset from the start of the viewport. Please note that this is not always\n         * the same as setting `scrollTop` or `scrollLeft`. In a horizontal viewport with right-to-left\n         * direction, this would be the equivalent of setting a fictional `scrollRight` property.\n         * @param offset The offset to scroll to.\n         * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n         */\n        scrollToOffset(offset, behavior = 'auto') {\n            const options = { behavior };\n            if (this.orientation === 'horizontal') {\n                options.start = offset;\n            }\n            else {\n                options.top = offset;\n            }\n            this.scrollTo(options);\n        }\n        /**\n         * Scrolls to the offset for the given index.\n         * @param index The index of the element to scroll to.\n         * @param behavior The ScrollBehavior to use when scrolling. Default is behavior is `auto`.\n         */\n        scrollToIndex(index, behavior = 'auto') {\n            this._scrollStrategy.scrollToIndex(index, behavior);\n        }\n        /**\n         * Gets the current scroll offset from the start of the viewport (in pixels).\n         * @param from The edge to measure the offset from. Defaults to 'top' in vertical mode and 'start'\n         *     in horizontal mode.\n         */\n        measureScrollOffset(from) {\n            return from ?\n                super.measureScrollOffset(from) :\n                super.measureScrollOffset(this.orientation === 'horizontal' ? 'start' : 'top');\n        }\n        /** Measure the combined size of all of the rendered items. */\n        measureRenderedContentSize() {\n            const contentEl = this._contentWrapper.nativeElement;\n            return this.orientation === 'horizontal' ? contentEl.offsetWidth : contentEl.offsetHeight;\n        }\n        /**\n         * Measure the total combined size of the given range. Throws if the range includes items that are\n         * not rendered.\n         */\n        measureRangeSize(range) {\n            if (!this._forOf) {\n                return 0;\n            }\n            return this._forOf.measureRangeSize(range, this.orientation);\n        }\n        /** Update the viewport dimensions and re-render. */\n        checkViewportSize() {\n            // TODO: Cleanup later when add logic for handling content resize\n            this._measureViewportSize();\n            this._scrollStrategy.onDataLengthChanged();\n        }\n        /** Measure the viewport size. */\n        _measureViewportSize() {\n            const viewportEl = this.elementRef.nativeElement;\n            this._viewportSize = this.orientation === 'horizontal' ?\n                viewportEl.clientWidth : viewportEl.clientHeight;\n        }\n        /** Queue up change detection to run. */\n        _markChangeDetectionNeeded(runAfter) {\n            if (runAfter) {\n                this._runAfterChangeDetection.push(runAfter);\n            }\n            // Use a Promise to batch together calls to `_doChangeDetection`. This way if we set a bunch of\n            // properties sequentially we only have to run `_doChangeDetection` once at the end.\n            if (!this._isChangeDetectionPending) {\n                this._isChangeDetectionPending = true;\n                this.ngZone.runOutsideAngular(() => Promise.resolve().then(() => {\n                    this._doChangeDetection();\n                }));\n            }\n        }\n        /** Run change detection. */\n        _doChangeDetection() {\n            this._isChangeDetectionPending = false;\n            // Apply the content transform. The transform can't be set via an Angular binding because\n            // bypassSecurityTrustStyle is banned in Google. However the value is safe, it's composed of\n            // string literals, a variable that can only be 'X' or 'Y', and user input that is run through\n            // the `Number` function first to coerce it to a numeric value.\n            this._contentWrapper.nativeElement.style.transform = this._renderedContentTransform;\n            // Apply changes to Angular bindings. Note: We must call `markForCheck` to run change detection\n            // from the root, since the repeated items are content projected in. Calling `detectChanges`\n            // instead does not properly check the projected content.\n            this.ngZone.run(() => this._changeDetectorRef.markForCheck());\n            const runAfterChangeDetection = this._runAfterChangeDetection;\n            this._runAfterChangeDetection = [];\n            for (const fn of runAfterChangeDetection) {\n                fn();\n            }\n        }\n        /** Calculates the `style.width` and `style.height` for the spacer element. */\n        _calculateSpacerSize() {\n            this._totalContentHeight =\n                this.orientation === 'horizontal' ? '' : `${this._totalContentSize}px`;\n            this._totalContentWidth =\n                this.orientation === 'horizontal' ? `${this._totalContentSize}px` : '';\n        }\n    }\n    CdkVirtualScrollViewport.fac = function CdkVirtualScrollViewport_Factory(t) { return new (t || CdkVirtualScrollViewport)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](VIRTUAL_SCROLL_STRATEGY, 8), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8), core[\"Mb\" /* directiveInject */](scrolling_ScrollDispatcher), core[\"Mb\" /* directiveInject */](scrolling_ViewportRuler)); };\n    CdkVirtualScrollViewport.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: CdkVirtualScrollViewport, selectors: [[\"cdk-virtual-scroll-viewport\"]], viewQuery: function CdkVirtualScrollViewport_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"qc\" /* staticViewQuery */](scrolling_c0, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._contentWrapper = _t.first);\n            }\n        }, hostAttrs: [1, \"cdk-virtual-scroll-viewport\"], hostVars: 4, hostBindings: function CdkVirtualScrollViewport_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* classProp */](\"cdk-virtual-scroll-orientation-horizontal\", ctx.orientation === \"horizontal\")(\"cdk-virtual-scroll-orientation-vertical\", ctx.orientation !== \"horizontal\");\n            }\n        }, inputs: { orientation: \"orientation\" }, outputs: { scrolledIndexChange: \"scrolledIndexChange\" }, features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{\n                    provide: scrolling_CdkScrollable,\n                    useExisting: CdkVirtualScrollViewport\n                }]), core[\"xb\" /* InheritDefinitionFeature */]], ngContentSelectors: scrolling_c1, decls: 4, vars: 4, consts: [[1, \"cdk-virtual-scroll-content-wrapper\"], [\"contentWrapper\", \"\"], [1, \"cdk-virtual-scroll-spacer\"]], template: function CdkVirtualScrollViewport_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"dc\" /* projectionDef */]();\n                core[\"Sb\" /* elementStart */](0, \"div\", 0, 1);\n                core[\"cc\" /* projection */](2);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Nb\" /* element */](3, \"div\", 2);\n            }\n            if (rf & 2) {\n                core[\"Ab\" /* advance */](3);\n                core[\"rc\" /* styleProp */](\"width\", ctx._totalContentWidth)(\"height\", ctx._totalContentHeight);\n            }\n        }, styles: [\"cdk-virtual-scroll-viewport{display:block;position:relative;overflow:auto;contain:strict;transform:translateZ(0);will-change:scroll-position;-webkit-overflow-scrolling:touch}.cdk-virtual-scroll-content-wrapper{position:absolute;top:0;left:0;contain:content}[dir=rtl] .cdk-virtual-scroll-content-wrapper{right:0;left:auto}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper{min-height:100%}.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-horizontal .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-left:0;padding-right:0;margin-left:0;margin-right:0;border-left-width:0;border-right-width:0;outline:none}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper{min-width:100%}.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>dl:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ol:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>table:not([cdkVirtualFor]),.cdk-virtual-scroll-orientation-vertical .cdk-virtual-scroll-content-wrapper>ul:not([cdkVirtualFor]){padding-top:0;padding-bottom:0;margin-top:0;margin-bottom:0;border-top-width:0;border-bottom-width:0;outline:none}.cdk-virtual-scroll-spacer{position:absolute;top:0;left:0;height:1px;width:1px;transform-origin:0 0}[dir=rtl] .cdk-virtual-scroll-spacer{right:0;left:auto;transform-origin:100% 0}\\n\"], encapsulation: 2, changeDetection: 0 });\n    return CdkVirtualScrollViewport;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Helper to extract the offset of a DOM Node in a certain direction. */\nfunction getOffset(orientation, direction, node) {\n    const el = node;\n    if (!el.getBoundingClientRect) {\n        return 0;\n    }\n    const rect = el.getBoundingClientRect();\n    if (orientation === 'horizontal') {\n        return direction === 'start' ? rect.left : rect.right;\n    }\n    return direction === 'start' ? rect.top : rect.bottom;\n}\nlet scrolling_CdkVirtualForOf = /*@__PURE__*/ (() => {\n    class CdkVirtualForOf {\n        constructor(\n        /** The view container to add items to. */\n        _viewContainerRef, \n        /** The template to use when stamping out new items. */\n        _template, \n        /** The set of available differs. */\n        _differs, \n        /** The strategy used to render items in the virtual scroll viewport. */\n        _viewRepeater, \n        /** The virtual scrolling viewport that these items are being rendered in. */\n        _viewport, ngZone) {\n            this._viewContainerRef = _viewContainerRef;\n            this._template = _template;\n            this._differs = _differs;\n            this._viewRepeater = _viewRepeater;\n            this._viewport = _viewport;\n            /** Emits when the rendered view of the data changes. */\n            this.viewChange = new Subject[\"a\" /* Subject */]();\n            /** Subject that emits when a new DataSource instance is given. */\n            this._dataSourceChanges = new Subject[\"a\" /* Subject */]();\n            /** Emits whenever the data in the current DataSource changes. */\n            this.dataStream = this._dataSourceChanges\n                .pipe(\n            // Start off with null `DataSource`.\n            Object(startWith[\"a\" /* startWith */])(null), \n            // Bundle up the previous and current data sources so we can work with both.\n            pairwise(), \n            // Use `_changeDataSource` to disconnect from the previous data source and connect to the\n            // new one, passing back a stream of data changes which we run through `switchMap` to give\n            // us a data stream that emits the latest data from whatever the current `DataSource` is.\n            Object(switchMap[\"a\" /* switchMap */])(([prev, cur]) => this._changeDataSource(prev, cur)), \n            // Replay the last emitted data when someone subscribes.\n            shareReplay(1));\n            /** The differ used to calculate changes to the data. */\n            this._differ = null;\n            /** Whether the rendered data should be updated during the next ngDoCheck cycle. */\n            this._needsUpdate = false;\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            this.dataStream.subscribe(data => {\n                this._data = data;\n                this._onRenderedDataChange();\n            });\n            this._viewport.renderedRangeStream.pipe(takeUntil(this._destroyed)).subscribe(range => {\n                this._renderedRange = range;\n                ngZone.run(() => this.viewChange.next(this._renderedRange));\n                this._onRenderedDataChange();\n            });\n            this._viewport.attach(this);\n        }\n        /** The DataSource to display. */\n        get cdkVirtualForOf() {\n            return this._cdkVirtualForOf;\n        }\n        set cdkVirtualForOf(value) {\n            this._cdkVirtualForOf = value;\n            if (isDataSource(value)) {\n                this._dataSourceChanges.next(value);\n            }\n            else {\n                // If value is an an NgIterable, convert it to an array.\n                this._dataSourceChanges.next(new collections_ArrayDataSource(isObservable(value) ? value : Array.from(value || [])));\n            }\n        }\n        /**\n         * The `TrackByFunction` to use for tracking changes. The `TrackByFunction` takes the index and\n         * the item and produces a value to be used as the item's identity when tracking changes.\n         */\n        get cdkVirtualForTrackBy() {\n            return this._cdkVirtualForTrackBy;\n        }\n        set cdkVirtualForTrackBy(fn) {\n            this._needsUpdate = true;\n            this._cdkVirtualForTrackBy = fn ?\n                (index, item) => fn(index + (this._renderedRange ? this._renderedRange.start : 0), item) :\n                undefined;\n        }\n        /** The template used to stamp out new elements. */\n        set cdkVirtualForTemplate(value) {\n            if (value) {\n                this._needsUpdate = true;\n                this._template = value;\n            }\n        }\n        /**\n         * The size of the cache used to store templates that are not being used for re-use later.\n         * Setting the cache size to `0` will disable caching. Defaults to 20 templates.\n         */\n        get cdkVirtualForTemplateCacheSize() {\n            return this._viewRepeater.viewCacheSize;\n        }\n        set cdkVirtualForTemplateCacheSize(size) {\n            this._viewRepeater.viewCacheSize = coerceNumberProperty(size);\n        }\n        /**\n         * Measures the combined size (width for horizontal orientation, height for vertical) of all items\n         * in the specified range. Throws an error if the range includes items that are not currently\n         * rendered.\n         */\n        measureRangeSize(range, orientation) {\n            if (range.start >= range.end) {\n                return 0;\n            }\n            if ((range.start < this._renderedRange.start || range.end > this._renderedRange.end) &&\n                (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw Error(`Error: attempted to measure an item that isn't rendered.`);\n            }\n            // The index into the list of rendered views for the first item in the range.\n            const renderedStartIndex = range.start - this._renderedRange.start;\n            // The length of the range we're measuring.\n            const rangeLen = range.end - range.start;\n            // Loop over all the views, find the first and land node and compute the size by subtracting\n            // the top of the first node from the bottom of the last one.\n            let firstNode;\n            let lastNode;\n            // Find the first node by starting from the beginning and going forwards.\n            for (let i = 0; i < rangeLen; i++) {\n                const view = this._viewContainerRef.get(i + renderedStartIndex);\n                if (view && view.rootNodes.length) {\n                    firstNode = lastNode = view.rootNodes[0];\n                    break;\n                }\n            }\n            // Find the last node by starting from the end and going backwards.\n            for (let i = rangeLen - 1; i > -1; i--) {\n                const view = this._viewContainerRef.get(i + renderedStartIndex);\n                if (view && view.rootNodes.length) {\n                    lastNode = view.rootNodes[view.rootNodes.length - 1];\n                    break;\n                }\n            }\n            return firstNode && lastNode ?\n                getOffset(orientation, 'end', lastNode) - getOffset(orientation, 'start', firstNode) : 0;\n        }\n        ngDoCheck() {\n            if (this._differ && this._needsUpdate) {\n                // TODO(mmalerba): We should differentiate needs update due to scrolling and a new portion of\n                // this list being rendered (can use simpler algorithm) vs needs update due to data actually\n                // changing (need to do this diff).\n                const changes = this._differ.diff(this._renderedItems);\n                if (!changes) {\n                    this._updateContext();\n                }\n                else {\n                    this._applyChanges(changes);\n                }\n                this._needsUpdate = false;\n            }\n        }\n        ngOnDestroy() {\n            this._viewport.detach();\n            this._dataSourceChanges.next(undefined);\n            this._dataSourceChanges.complete();\n            this.viewChange.complete();\n            this._destroyed.next();\n            this._destroyed.complete();\n            this._viewRepeater.detach();\n        }\n        /** React to scroll state changes in the viewport. */\n        _onRenderedDataChange() {\n            if (!this._renderedRange) {\n                return;\n            }\n            this._renderedItems = this._data.slice(this._renderedRange.start, this._renderedRange.end);\n            if (!this._differ) {\n                // Use a wrapper function for the `trackBy` so any new values are\n                // picked up automatically without having to recreate the differ.\n                this._differ = this._differs.find(this._renderedItems).create((index, item) => {\n                    return this.cdkVirtualForTrackBy ? this.cdkVirtualForTrackBy(index, item) : item;\n                });\n            }\n            this._needsUpdate = true;\n        }\n        /** Swap out one `DataSource` for another. */\n        _changeDataSource(oldDs, newDs) {\n            if (oldDs) {\n                oldDs.disconnect(this);\n            }\n            this._needsUpdate = true;\n            return newDs ? newDs.connect(this) : Object(of[\"a\" /* of */])();\n        }\n        /** Update the `CdkVirtualForOfContext` for all views. */\n        _updateContext() {\n            const count = this._data.length;\n            let i = this._viewContainerRef.length;\n            while (i--) {\n                const view = this._viewContainerRef.get(i);\n                view.context.index = this._renderedRange.start + i;\n                view.context.count = count;\n                this._updateComputedContextProperties(view.context);\n                view.detectChanges();\n            }\n        }\n        /** Apply changes to the DOM. */\n        _applyChanges(changes) {\n            this._viewRepeater.applyChanges(changes, this._viewContainerRef, (record, _adjustedPreviousIndex, currentIndex) => this._getEmbeddedViewArgs(record, currentIndex), (record) => record.item);\n            // Update $implicit for any items that had an identity change.\n            changes.forEachIdentityChange((record) => {\n                const view = this._viewContainerRef.get(record.currentIndex);\n                view.context.$implicit = record.item;\n            });\n            // Update the context variables on all items.\n            const count = this._data.length;\n            let i = this._viewContainerRef.length;\n            while (i--) {\n                const view = this._viewContainerRef.get(i);\n                view.context.index = this._renderedRange.start + i;\n                view.context.count = count;\n                this._updateComputedContextProperties(view.context);\n            }\n        }\n        /** Update the computed properties on the `CdkVirtualForOfContext`. */\n        _updateComputedContextProperties(context) {\n            context.first = context.index === 0;\n            context.last = context.index === context.count - 1;\n            context.even = context.index % 2 === 0;\n            context.odd = !context.even;\n        }\n        _getEmbeddedViewArgs(record, index) {\n            // Note that it's important that we insert the item directly at the proper index,\n            // rather than inserting it and the moving it in place, because if there's a directive\n            // on the same node that injects the `ViewContainerRef`, Angular will insert another\n            // comment node which can throw off the move when it's being repeated for all items.\n            return {\n                templateRef: this._template,\n                context: {\n                    $implicit: record.item,\n                    // It's guaranteed that the iterable is not \"undefined\" or \"null\" because we only\n                    // generate views for elements if the \"cdkVirtualForOf\" iterable has elements.\n                    cdkVirtualForOf: this._cdkVirtualForOf,\n                    index: -1,\n                    count: -1,\n                    first: false,\n                    last: false,\n                    odd: false,\n                    even: false\n                },\n                index,\n            };\n        }\n    }\n    CdkVirtualForOf.fac = function CdkVirtualForOf_Factory(t) { return new (t || CdkVirtualForOf)(core[\"Mb\" /* directiveInject */](core[\"Q\" /* ViewContainerRef */]), core[\"Mb\" /* directiveInject */](core[\"M\" /* TemplateRef */]), core[\"Mb\" /* directiveInject */](core[\"t\" /* IterableDiffers */]), core[\"Mb\" /* directiveInject */](_VIEW_REPEATER_STRATEGY), core[\"Mb\" /* directiveInject */](scrolling_CdkVirtualScrollViewport, 4), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */])); };\n    CdkVirtualForOf.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: CdkVirtualForOf, selectors: [[\"\", \"cdkVirtualFor\", \"\", \"cdkVirtualForOf\", \"\"]], inputs: { cdkVirtualForOf: \"cdkVirtualForOf\", cdkVirtualForTrackBy: \"cdkVirtualForTrackBy\", cdkVirtualForTemplate: \"cdkVirtualForTemplate\", cdkVirtualForTemplateCacheSize: \"cdkVirtualForTemplateCacheSize\" }, features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([\n                { provide: _VIEW_REPEATER_STRATEGY, useClass: _RecycleViewRepeaterStrategy },\n            ])] });\n    return CdkVirtualForOf;\n})();\nlet scrolling_CdkScrollableModule = /*@__PURE__*/ (() => {\n    class CdkScrollableModule {\n    }\n    CdkScrollableModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: CdkScrollableModule });\n    CdkScrollableModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function CdkScrollableModule_Factory(t) { return new (t || CdkScrollableModule)(); } });\n    return CdkScrollableModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](scrolling_CdkScrollableModule, { declarations: [scrolling_CdkScrollable], exports: [scrolling_CdkScrollable] }); })();\nlet scrolling_ScrollingModule = /*@__PURE__*/ (() => {\n    class ScrollingModule {\n    }\n    ScrollingModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: ScrollingModule });\n    ScrollingModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function ScrollingModule_Factory(t) { return new (t || ScrollingModule)(); }, imports: [[\n                bidi_BidiModule,\n                platform_PlatformModule,\n                scrolling_CdkScrollableModule\n            ], bidi_BidiModule, scrolling_CdkScrollableModule] });\n    return ScrollingModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](scrolling_ScrollingModule, { declarations: function () { return [scrolling_CdkFixedSizeVirtualScroll, scrolling_CdkVirtualForOf, scrolling_CdkVirtualScrollViewport]; }, imports: function () {\n            return [bidi_BidiModule,\n                platform_PlatformModule, scrolling_CdkScrollableModule];\n        }, exports: function () { return [bidi_BidiModule, scrolling_CdkScrollableModule, scrolling_CdkFixedSizeVirtualScroll, scrolling_CdkVirtualForOf, scrolling_CdkVirtualScrollViewport]; } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=scrolling.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/tabs.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token for the MatInkBar's Positioner. */\n\n\n\n\n\n\n\n\n\nfunction MatTab_ng_template_0_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"cc\" /* projection */](0);\n    }\n}\nconst tabs_c0 = [\"*\"];\nfunction MatTabBody_ng_template_2_Template(rf, ctx) { }\nconst tabs_c1 = function (a0) { return { animationDuration: a0 }; };\nconst tabs_c2 = function (a0, a1) { return { value: a0, params: a1 }; };\nconst _c3 = [\"tabBodyWrapper\"];\nconst _c4 = [\"tabHeader\"];\nfunction MatTabGroup_div_2_ng_template_2_ng_template_0_Template(rf, ctx) { }\nfunction MatTabGroup_div_2_ng_template_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"sc\" /* template */](0, MatTabGroup_div_2_ng_template_2_ng_template_0_Template, 0, 0, \"ng-template\", 9);\n    }\n    if (rf & 2) {\n        const tab_r4 = core[\"bc\" /* nextContext */]().$implicit;\n        core[\"ec\" /* property */](\"cdkPortalOutlet\", tab_r4.templateLabel);\n    }\n}\nfunction MatTabGroup_div_2_ng_template_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"uc\" /* text */](0);\n    }\n    if (rf & 2) {\n        const tab_r4 = core[\"bc\" /* nextContext */]().$implicit;\n        core[\"vc\" /* textInterpolate */](tab_r4.textLabel);\n    }\n}\nfunction MatTabGroup_div_2_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r12 = core[\"Tb\" /* getCurrentView */]();\n        core[\"Sb\" /* elementStart */](0, \"div\", 6);\n        core[\"Zb\" /* listener */](\"click\", function MatTabGroup_div_2_Template_div_click_0_listener() { core[\"mc\" /* restoreView */](_r12); const tab_r4 = ctx.$implicit; const i_r5 = ctx.index; const ctx_r11 = core[\"bc\" /* nextContext */](); const _r0 = core[\"lc\" /* reference */](1); return ctx_r11._handleClick(tab_r4, _r0, i_r5); })(\"cdkFocusChange\", function MatTabGroup_div_2_Template_div_cdkFocusChange_0_listener($event) { core[\"mc\" /* restoreView */](_r12); const i_r5 = ctx.index; const ctx_r13 = core[\"bc\" /* nextContext */](); return ctx_r13._tabFocusChanged($event, i_r5); });\n        core[\"Sb\" /* elementStart */](1, \"div\", 7);\n        core[\"sc\" /* template */](2, MatTabGroup_div_2_ng_template_2_Template, 1, 1, \"ng-template\", 8);\n        core[\"sc\" /* template */](3, MatTabGroup_div_2_ng_template_3_Template, 1, 1, \"ng-template\", 8);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const tab_r4 = ctx.$implicit;\n        const i_r5 = ctx.index;\n        const ctx_r1 = core[\"bc\" /* nextContext */]();\n        core[\"Eb\" /* classProp */](\"mat-tab-label-active\", ctx_r1.selectedIndex == i_r5);\n        core[\"ec\" /* property */](\"id\", ctx_r1._getTabLabelId(i_r5))(\"disabled\", tab_r4.disabled)(\"matRippleDisabled\", tab_r4.disabled || ctx_r1.disableRipple);\n        core[\"Bb\" /* attribute */](\"tabIndex\", ctx_r1._getTabIndex(tab_r4, i_r5))(\"aria-posinset\", i_r5 + 1)(\"aria-setsize\", ctx_r1._tabs.length)(\"aria-controls\", ctx_r1._getTabContentId(i_r5))(\"aria-selected\", ctx_r1.selectedIndex == i_r5)(\"aria-label\", tab_r4.ariaLabel || null)(\"aria-labelledby\", !tab_r4.ariaLabel && tab_r4.ariaLabelledby ? tab_r4.ariaLabelledby : null);\n        core[\"Ab\" /* advance */](2);\n        core[\"ec\" /* property */](\"ngIf\", tab_r4.templateLabel);\n        core[\"Ab\" /* advance */](1);\n        core[\"ec\" /* property */](\"ngIf\", !tab_r4.templateLabel);\n    }\n}\nfunction MatTabGroup_mat_tab_body_5_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r17 = core[\"Tb\" /* getCurrentView */]();\n        core[\"Sb\" /* elementStart */](0, \"mat-tab-body\", 10);\n        core[\"Zb\" /* listener */](\"_onCentered\", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentered_0_listener() { core[\"mc\" /* restoreView */](_r17); const ctx_r16 = core[\"bc\" /* nextContext */](); return ctx_r16._removeTabBodyWrapperHeight(); })(\"_onCentering\", function MatTabGroup_mat_tab_body_5_Template_mat_tab_body__onCentering_0_listener($event) { core[\"mc\" /* restoreView */](_r17); const ctx_r18 = core[\"bc\" /* nextContext */](); return ctx_r18._setTabBodyWrapperHeight($event); });\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const tab_r14 = ctx.$implicit;\n        const i_r15 = ctx.index;\n        const ctx_r3 = core[\"bc\" /* nextContext */]();\n        core[\"Eb\" /* classProp */](\"mat-tab-body-active\", ctx_r3.selectedIndex == i_r15);\n        core[\"ec\" /* property */](\"id\", ctx_r3._getTabContentId(i_r15))(\"content\", tab_r14.content)(\"position\", tab_r14.position)(\"origin\", tab_r14.origin)(\"animationDuration\", ctx_r3.animationDuration);\n        core[\"Bb\" /* attribute */](\"aria-labelledby\", ctx_r3._getTabLabelId(i_r15));\n    }\n}\nconst _c5 = [\"tabListContainer\"];\nconst _c6 = [\"tabList\"];\nconst _c7 = [\"nextPaginator\"];\nconst _c8 = [\"previousPaginator\"];\nconst _c9 = [\"mat-tab-nav-bar\", \"\"];\nconst _MAT_INK_BAR_POSITIONER = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MatInkBarPositioner', {\n    providedIn: 'root',\n    factory: _MAT_INK_BAR_POSITIONER_FACTORY\n});\n/**\n * The default positioner function for the MatInkBar.\n * @docs-private\n */\nfunction _MAT_INK_BAR_POSITIONER_FACTORY() {\n    const method = (element) => ({\n        left: element ? (element.offsetLeft || 0) + 'px' : '0',\n        width: element ? (element.offsetWidth || 0) + 'px' : '0',\n    });\n    return method;\n}\nlet tabs_MatInkBar = /*@__PURE__*/ (() => {\n    class MatInkBar {\n        constructor(_elementRef, _ngZone, _inkBarPositioner, _animationMode) {\n            this._elementRef = _elementRef;\n            this._ngZone = _ngZone;\n            this._inkBarPositioner = _inkBarPositioner;\n            this._animationMode = _animationMode;\n        }\n        /**\n         * Calculates the styles from the provided element in order to align the ink-bar to that element.\n         * Shows the ink bar if previously set as hidden.\n         * @param element\n         */\n        alignToElement(element) {\n            this.show();\n            if (typeof requestAnimationFrame !== 'undefined') {\n                this._ngZone.runOutsideAngular(() => {\n                    requestAnimationFrame(() => this._setStyles(element));\n                });\n            }\n            else {\n                this._setStyles(element);\n            }\n        }\n        /** Shows the ink bar. */\n        show() {\n            this._elementRef.nativeElement.style.visibility = 'visible';\n        }\n        /** Hides the ink bar. */\n        hide() {\n            this._elementRef.nativeElement.style.visibility = 'hidden';\n        }\n        /**\n         * Sets the proper styles to the ink bar element.\n         * @param element\n         */\n        _setStyles(element) {\n            const positions = this._inkBarPositioner(element);\n            const inkBar = this._elementRef.nativeElement;\n            inkBar.style.left = positions.left;\n            inkBar.style.width = positions.width;\n        }\n    }\n    MatInkBar.fac = function MatInkBar_Factory(t) { return new (t || MatInkBar)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](_MAT_INK_BAR_POSITIONER), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatInkBar.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatInkBar, selectors: [[\"mat-ink-bar\"]], hostAttrs: [1, \"mat-ink-bar\"], hostVars: 2, hostBindings: function MatInkBar_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* classProp */](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n            }\n        } });\n    return MatInkBar;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `MatTabContent`. It serves as\n * alternative token to the actual `MatTabContent` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_TAB_CONTENT = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MatTabContent');\nlet tabs_MatTabContent = /*@__PURE__*/ (() => {\n    class MatTabContent {\n        constructor(\n        /** Content for the tab. */ template) {\n            this.template = template;\n        }\n    }\n    MatTabContent.fac = function MatTabContent_Factory(t) { return new (t || MatTabContent)(core[\"Mb\" /* directiveInject */](core[\"M\" /* TemplateRef */])); };\n    MatTabContent.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatTabContent, selectors: [[\"\", \"matTabContent\", \"\"]], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{ provide: MAT_TAB_CONTENT, useExisting: MatTabContent }])] });\n    return MatTabContent;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `MatTabLabel`. It serves as\n * alternative token to the actual `MatTabLabel` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_TAB_LABEL = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MatTabLabel');\nlet tabs_MatTabLabel = /*@__PURE__*/ (() => {\n    class MatTabLabel extends portal_CdkPortal {\n    }\n    MatTabLabel.fac = function MatTabLabel_Factory(t) { return MatTabLabel_BaseFactory(t || MatTabLabel); };\n    MatTabLabel.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatTabLabel, selectors: [[\"\", \"mat-tab-label\", \"\"], [\"\", \"matTabLabel\", \"\"]], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{ provide: MAT_TAB_LABEL, useExisting: MatTabLabel }]), core[\"xb\" /* InheritDefinitionFeature */]] });\n    return MatTabLabel;\n})();\nconst MatTabLabel_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Ub\" /* getInheritedFactory */](tabs_MatTabLabel);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Boilerplate for applying mixins to MatTab.\n/** @docs-private */\nclass MatTabBase {\n}\nconst _MatTabMixinBase = /*@__PURE__*/ mixinDisabled(MatTabBase);\n/**\n * Used to provide a tab group to a tab without causing a circular dependency.\n * @docs-private\n */\nconst MAT_TAB_GROUP = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MAT_TAB_GROUP');\nlet tabs_MatTab = /*@__PURE__*/ (() => {\n    class MatTab extends _MatTabMixinBase {\n        constructor(_viewContainerRef, _closestTabGroup) {\n            super();\n            this._viewContainerRef = _viewContainerRef;\n            this._closestTabGroup = _closestTabGroup;\n            /** Plain text label for the tab, used when there is no template label. */\n            this.textLabel = '';\n            /** Portal that will be the hosted content of the tab */\n            this._contentPortal = null;\n            /** Emits whenever the internal state of the tab changes. */\n            this._stateChanges = new Subject[\"a\" /* Subject */]();\n            /**\n             * The relatively indexed position where 0 represents the center, negative is left, and positive\n             * represents the right.\n             */\n            this.position = null;\n            /**\n             * The initial relatively index origin of the tab if it was created and selected after there\n             * was already a selected tab. Provides context of what position the tab should originate from.\n             */\n            this.origin = null;\n            /**\n             * Whether the tab is currently active.\n             */\n            this.isActive = false;\n        }\n        /** Content for the tab label given by `<ng-template mat-tab-label>`. */\n        get templateLabel() { return this._templateLabel; }\n        set templateLabel(value) { this._setTemplateLabelInput(value); }\n        /** @docs-private */\n        get content() {\n            return this._contentPortal;\n        }\n        ngOnChanges(changes) {\n            if (changes.hasOwnProperty('textLabel') || changes.hasOwnProperty('disabled')) {\n                this._stateChanges.next();\n            }\n        }\n        ngOnDestroy() {\n            this._stateChanges.complete();\n        }\n        ngOnInit() {\n            this._contentPortal = new TemplatePortal(this._explicitContent || this._implicitContent, this._viewContainerRef);\n        }\n        /**\n         * This has been extracted to a util because of TS 4 and VE.\n         * View Engine doesn't support property rename inheritance.\n         * TS 4.0 doesn't allow properties to override accessors or vice-versa.\n         * @docs-private\n         */\n        _setTemplateLabelInput(value) {\n            // Only update the templateLabel via query if there is actually\n            // a MatTabLabel found. This works around an issue where a user may have\n            // manually set `templateLabel` during creation mode, which would then get clobbered\n            // by `undefined` when this query resolves.\n            if (value) {\n                this._templateLabel = value;\n            }\n        }\n    }\n    MatTab.fac = function MatTab_Factory(t) { return new (t || MatTab)(core[\"Mb\" /* directiveInject */](core[\"Q\" /* ViewContainerRef */]), core[\"Mb\" /* directiveInject */](MAT_TAB_GROUP)); };\n    MatTab.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatTab, selectors: [[\"mat-tab\"]], contentQueries: function MatTab_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Fb\" /* contentQuery */](dirIndex, MAT_TAB_LABEL, true);\n                core[\"pc\" /* staticContentQuery */](dirIndex, MAT_TAB_CONTENT, true, core[\"M\" /* TemplateRef */]);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.templateLabel = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._explicitContent = _t.first);\n            }\n        }, viewQuery: function MatTab_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"qc\" /* staticViewQuery */](core[\"M\" /* TemplateRef */], true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._implicitContent = _t.first);\n            }\n        }, inputs: { disabled: \"disabled\", textLabel: [\"label\", \"textLabel\"], ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"] }, exportAs: [\"matTab\"], features: [core[\"xb\" /* InheritDefinitionFeature */], core[\"yb\" /* NgOnChangesFeature */]], ngContentSelectors: tabs_c0, decls: 1, vars: 0, template: function MatTab_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"dc\" /* projectionDef */]();\n                core[\"sc\" /* template */](0, MatTab_ng_template_0_Template, 1, 0, \"ng-template\");\n            }\n        }, encapsulation: 2 });\n    return MatTab;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Animations used by the Material tabs.\n * @docs-private\n */\nconst matTabsAnimations = {\n    /** Animation translates a tab along the X axis. */\n    translateTab: /*@__PURE__*/ Object(fesm2015_animations[\"l\" /* trigger */])('translateTab', [\n        // Note: transitions to `none` instead of 0, because some browsers might blur the content.\n        /*@__PURE__*/ Object(fesm2015_animations[\"i\" /* state */])('center, void, left-origin-center, right-origin-center', /*@__PURE__*/ Object(fesm2015_animations[\"j\" /* style */])({ transform: 'none' })),\n        // If the tab is either on the left or right, we additionally add a `min-height` of 1px\n        // in order to ensure that the element has a height before its state changes. This is\n        // necessary because Chrome does seem to skip the transition in RTL mode if the element does\n        // not have a static height and is not rendered. See related issue: #9465\n        /*@__PURE__*/ Object(fesm2015_animations[\"i\" /* state */])('left', /*@__PURE__*/ Object(fesm2015_animations[\"j\" /* style */])({ transform: 'translate3d(-100%, 0, 0)', minHeight: '1px' })),\n        /*@__PURE__*/ Object(fesm2015_animations[\"i\" /* state */])('right', /*@__PURE__*/ Object(fesm2015_animations[\"j\" /* style */])({ transform: 'translate3d(100%, 0, 0)', minHeight: '1px' })),\n        /*@__PURE__*/ Object(fesm2015_animations[\"k\" /* transition */])('* => left, * => right, left => center, right => center', /*@__PURE__*/ Object(fesm2015_animations[\"e\" /* animate */])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')),\n        /*@__PURE__*/ Object(fesm2015_animations[\"k\" /* transition */])('void => left-origin-center', [\n            /*@__PURE__*/ Object(fesm2015_animations[\"j\" /* style */])({ transform: 'translate3d(-100%, 0, 0)' }),\n            /*@__PURE__*/ Object(fesm2015_animations[\"e\" /* animate */])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')\n        ]),\n        /*@__PURE__*/ Object(fesm2015_animations[\"k\" /* transition */])('void => right-origin-center', [\n            /*@__PURE__*/ Object(fesm2015_animations[\"j\" /* style */])({ transform: 'translate3d(100%, 0, 0)' }),\n            /*@__PURE__*/ Object(fesm2015_animations[\"e\" /* animate */])('{{animationDuration}} cubic-bezier(0.35, 0, 0.25, 1)')\n        ])\n    ])\n};\nlet tabs_MatTabBodyPortal = /*@__PURE__*/ (() => {\n    class MatTabBodyPortal extends portal_CdkPortalOutlet {\n        constructor(componentFactoryResolver, viewContainerRef, _host, _document) {\n            super(componentFactoryResolver, viewContainerRef, _document);\n            this._host = _host;\n            /** Subscription to events for when the tab body begins centering. */\n            this._centeringSub = Subscription[\"a\" /* Subscription */].EMPTY;\n            /** Subscription to events for when the tab body finishes leaving from center position. */\n            this._leavingSub = Subscription[\"a\" /* Subscription */].EMPTY;\n        }\n        /** Set initial visibility or set up subscription for changing visibility. */\n        ngOnInit() {\n            super.ngOnInit();\n            this._centeringSub = this._host._beforeCentering\n                .pipe(Object(startWith[\"a\" /* startWith */])(this._host._isCenterPosition(this._host._position)))\n                .subscribe((isCentering) => {\n                if (isCentering && !this.hasAttached()) {\n                    this.attach(this._host._content);\n                }\n            });\n            this._leavingSub = this._host._afterLeavingCenter.subscribe(() => {\n                this.detach();\n            });\n        }\n        /** Clean up centering subscription. */\n        ngOnDestroy() {\n            super.ngOnDestroy();\n            this._centeringSub.unsubscribe();\n            this._leavingSub.unsubscribe();\n        }\n    }\n    MatTabBodyPortal.fac = function MatTabBodyPortal_Factory(t) { return new (t || MatTabBodyPortal)(core[\"Mb\" /* directiveInject */](core[\"j\" /* ComponentFactoryResolver */]), core[\"Mb\" /* directiveInject */](core[\"Q\" /* ViewContainerRef */]), core[\"Mb\" /* directiveInject */](Object(core[\"U\" /* forwardRef */])(() => tabs_MatTabBody)), core[\"Mb\" /* directiveInject */](common[\"c\" /* DOCUMENT */])); };\n    MatTabBodyPortal.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatTabBodyPortal, selectors: [[\"\", \"matTabBodyHost\", \"\"]], features: [core[\"xb\" /* InheritDefinitionFeature */]] });\n    return MatTabBodyPortal;\n})();\nlet tabs_MatTabBodyBase = /*@__PURE__*/ (() => {\n    class _MatTabBodyBase {\n        constructor(_elementRef, _dir, changeDetectorRef) {\n            this._elementRef = _elementRef;\n            this._dir = _dir;\n            /** Subscription to the directionality change observable. */\n            this._dirChangeSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n            /** Emits when an animation on the tab is complete. */\n            this._translateTabComplete = new Subject[\"a\" /* Subject */]();\n            /** Event emitted when the tab begins to animate towards the center as the active tab. */\n            this._onCentering = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted before the centering of the tab begins. */\n            this._beforeCentering = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted before the centering of the tab begins. */\n            this._afterLeavingCenter = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted when the tab completes its animation towards the center. */\n            this._onCentered = new core[\"n\" /* EventEmitter */](true);\n            // Note that the default value will always be overwritten by `MatTabBody`, but we need one\n            // anyway to prevent the animations module from throwing an error if the body is used on its own.\n            /** Duration for the tab's animation. */\n            this.animationDuration = '500ms';\n            if (_dir) {\n                this._dirChangeSubscription = _dir.change.subscribe((dir) => {\n                    this._computePositionAnimationState(dir);\n                    changeDetectorRef.markForCheck();\n                });\n            }\n            // Ensure that we get unique animation events, because the `.done` callback can get\n            // invoked twice in some browsers. See https://github.com/angular/angular/issues/24084.\n            this._translateTabComplete.pipe(distinctUntilChanged((x, y) => {\n                return x.fromState === y.fromState && x.toState === y.toState;\n            })).subscribe(event => {\n                // If the transition to the center is complete, emit an event.\n                if (this._isCenterPosition(event.toState) && this._isCenterPosition(this._position)) {\n                    this._onCentered.emit();\n                }\n                if (this._isCenterPosition(event.fromState) && !this._isCenterPosition(this._position)) {\n                    this._afterLeavingCenter.emit();\n                }\n            });\n        }\n        /** The shifted index position of the tab body, where zero represents the active center tab. */\n        set position(position) {\n            this._positionIndex = position;\n            this._computePositionAnimationState();\n        }\n        /**\n         * After initialized, check if the content is centered and has an origin. If so, set the\n         * special position states that transition the tab from the left or right before centering.\n         */\n        ngOnInit() {\n            if (this._position == 'center' && this.origin != null) {\n                this._position = this._computePositionFromOrigin(this.origin);\n            }\n        }\n        ngOnDestroy() {\n            this._dirChangeSubscription.unsubscribe();\n            this._translateTabComplete.complete();\n        }\n        _onTranslateTabStarted(event) {\n            const isCentering = this._isCenterPosition(event.toState);\n            this._beforeCentering.emit(isCentering);\n            if (isCentering) {\n                this._onCentering.emit(this._elementRef.nativeElement.clientHeight);\n            }\n        }\n        /** The text direction of the containing app. */\n        _getLayoutDirection() {\n            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n        }\n        /** Whether the provided position state is considered center, regardless of origin. */\n        _isCenterPosition(position) {\n            return position == 'center' ||\n                position == 'left-origin-center' ||\n                position == 'right-origin-center';\n        }\n        /** Computes the position state that will be used for the tab-body animation trigger. */\n        _computePositionAnimationState(dir = this._getLayoutDirection()) {\n            if (this._positionIndex < 0) {\n                this._position = dir == 'ltr' ? 'left' : 'right';\n            }\n            else if (this._positionIndex > 0) {\n                this._position = dir == 'ltr' ? 'right' : 'left';\n            }\n            else {\n                this._position = 'center';\n            }\n        }\n        /**\n         * Computes the position state based on the specified origin position. This is used if the\n         * tab is becoming visible immediately after creation.\n         */\n        _computePositionFromOrigin(origin) {\n            const dir = this._getLayoutDirection();\n            if ((dir == 'ltr' && origin <= 0) || (dir == 'rtl' && origin > 0)) {\n                return 'left-origin-center';\n            }\n            return 'right-origin-center';\n        }\n    }\n    _MatTabBodyBase.fac = function _MatTabBodyBase_Factory(t) { return new (t || _MatTabBodyBase)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */])); };\n    _MatTabBodyBase.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: _MatTabBodyBase, inputs: { animationDuration: \"animationDuration\", position: \"position\", _content: [\"content\", \"_content\"], origin: \"origin\" }, outputs: { _onCentering: \"_onCentering\", _beforeCentering: \"_beforeCentering\", _afterLeavingCenter: \"_afterLeavingCenter\", _onCentered: \"_onCentered\" } });\n    return _MatTabBodyBase;\n})();\nlet tabs_MatTabBody = /*@__PURE__*/ (() => {\n    class MatTabBody extends tabs_MatTabBodyBase {\n        constructor(elementRef, dir, changeDetectorRef) {\n            super(elementRef, dir, changeDetectorRef);\n        }\n    }\n    MatTabBody.fac = function MatTabBody_Factory(t) { return new (t || MatTabBody)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */])); };\n    MatTabBody.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatTabBody, selectors: [[\"mat-tab-body\"]], viewQuery: function MatTabBody_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"xc\" /* viewQuery */](portal_CdkPortalOutlet, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._portalHost = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-body\"], features: [core[\"xb\" /* InheritDefinitionFeature */]], decls: 3, vars: 6, consts: [[\"cdkScrollable\", \"\", 1, \"mat-tab-body-content\"], [\"content\", \"\"], [\"matTabBodyHost\", \"\"]], template: function MatTabBody_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Sb\" /* elementStart */](0, \"div\", 0, 1);\n                core[\"Zb\" /* listener */](\"@translateTab.start\", function MatTabBody_Template_div_animation_translateTab_start_0_listener($event) { return ctx._onTranslateTabStarted($event); })(\"@translateTab.done\", function MatTabBody_Template_div_animation_translateTab_done_0_listener($event) { return ctx._translateTabComplete.next($event); });\n                core[\"sc\" /* template */](2, MatTabBody_ng_template_2_Template, 0, 0, \"ng-template\", 2);\n                core[\"Rb\" /* elementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"ec\" /* property */](\"@translateTab\", core[\"gc\" /* pureFunction2 */](3, tabs_c2, ctx._position, core[\"fc\" /* pureFunction1 */](1, tabs_c1, ctx.animationDuration)));\n            }\n        }, directives: [tabs_MatTabBodyPortal], styles: [\".mat-tab-body-content{height:100%;overflow:auto}.mat-tab-group-dynamic-height .mat-tab-body-content{overflow:hidden}\\n\"], encapsulation: 2, data: { animation: [matTabsAnimations.translateTab] } });\n    return MatTabBody;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Injection token that can be used to provide the default options the tabs module. */\nconst MAT_TABS_CONFIG = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MAT_TABS_CONFIG');\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Used to generate unique ID's for each tab component */\nlet tabs_nextId = 0;\n/** A simple change event emitted on focus or selection changes. */\nclass MatTabChangeEvent {\n}\n// Boilerplate for applying mixins to MatTabGroup.\n/** @docs-private */\nclass MatTabGroupMixinBase {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\nconst _MatTabGroupMixinBase = /*@__PURE__*/ mixinColor(/*@__PURE__*/ mixinDisableRipple(MatTabGroupMixinBase), 'primary');\nlet tabs_MatTabGroupBase = /*@__PURE__*/ (() => {\n    class _MatTabGroupBase extends _MatTabGroupMixinBase {\n        constructor(elementRef, _changeDetectorRef, defaultConfig, _animationMode) {\n            super(elementRef);\n            this._changeDetectorRef = _changeDetectorRef;\n            this._animationMode = _animationMode;\n            /** All of the tabs that belong to the group. */\n            this._tabs = new core[\"E\" /* QueryList */]();\n            /** The tab index that should be selected after the content has been checked. */\n            this._indexToSelect = 0;\n            /** Snapshot of the height of the tab body wrapper before another tab is activated. */\n            this._tabBodyWrapperHeight = 0;\n            /** Subscription to tabs being added/removed. */\n            this._tabsSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n            /** Subscription to changes in the tab labels. */\n            this._tabLabelSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n            this._selectedIndex = null;\n            /** Position of the tab header. */\n            this.headerPosition = 'above';\n            /** Output to enable support for two-way binding on `[(selectedIndex)]` */\n            this.selectedIndexChange = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted when focus has changed within a tab group. */\n            this.focusChange = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted when the body animation has completed */\n            this.animationDone = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted when the tab selection has changed. */\n            this.selectedTabChange = new core[\"n\" /* EventEmitter */](true);\n            this._groupId = tabs_nextId++;\n            this.animationDuration = defaultConfig && defaultConfig.animationDuration ?\n                defaultConfig.animationDuration : '500ms';\n            this.disablePagination = defaultConfig && defaultConfig.disablePagination != null ?\n                defaultConfig.disablePagination : false;\n            this.dynamicHeight = defaultConfig && defaultConfig.dynamicHeight != null ?\n                defaultConfig.dynamicHeight : false;\n        }\n        /** Whether the tab group should grow to the size of the active tab. */\n        get dynamicHeight() { return this._dynamicHeight; }\n        set dynamicHeight(value) { this._dynamicHeight = coerceBooleanProperty(value); }\n        /** The index of the active tab. */\n        get selectedIndex() { return this._selectedIndex; }\n        set selectedIndex(value) {\n            this._indexToSelect = coerceNumberProperty(value, null);\n        }\n        /** Duration for the tab animation. Will be normalized to milliseconds if no units are set. */\n        get animationDuration() { return this._animationDuration; }\n        set animationDuration(value) {\n            this._animationDuration = /^\\d+$/.test(value) ? value + 'ms' : value;\n        }\n        /** Background color of the tab group. */\n        get backgroundColor() { return this._backgroundColor; }\n        set backgroundColor(value) {\n            const nativeElement = this._elementRef.nativeElement;\n            nativeElement.classList.remove(`mat-background-${this.backgroundColor}`);\n            if (value) {\n                nativeElement.classList.add(`mat-background-${value}`);\n            }\n            this._backgroundColor = value;\n        }\n        /**\n         * After the content is checked, this component knows what tabs have been defined\n         * and what the selected index should be. This is where we can know exactly what position\n         * each tab should be in according to the new selected index, and additionally we know how\n         * a new selected tab should transition in (from the left or right).\n         */\n        ngAfterContentChecked() {\n            // Don't clamp the `indexToSelect` immediately in the setter because it can happen that\n            // the amount of tabs changes before the actual change detection runs.\n            const indexToSelect = this._indexToSelect = this._clampTabIndex(this._indexToSelect);\n            // If there is a change in selected index, emit a change event. Should not trigger if\n            // the selected index has not yet been initialized.\n            if (this._selectedIndex != indexToSelect) {\n                const isFirstRun = this._selectedIndex == null;\n                if (!isFirstRun) {\n                    this.selectedTabChange.emit(this._createChangeEvent(indexToSelect));\n                    // Preserve the height so page doesn't scroll up during tab change.\n                    // Fixes https://stackblitz.com/edit/mat-tabs-scroll-page-top-on-tab-change\n                    const wrapper = this._tabBodyWrapper.nativeElement;\n                    wrapper.style.minHeight = wrapper.clientHeight + 'px';\n                }\n                // Changing these values after change detection has run\n                // since the checked content may contain references to them.\n                Promise.resolve().then(() => {\n                    this._tabs.forEach((tab, index) => tab.isActive = index === indexToSelect);\n                    if (!isFirstRun) {\n                        this.selectedIndexChange.emit(indexToSelect);\n                        // Clear the min-height, this was needed during tab change to avoid\n                        // unnecessary scrolling.\n                        this._tabBodyWrapper.nativeElement.style.minHeight = '';\n                    }\n                });\n            }\n            // Setup the position for each tab and optionally setup an origin on the next selected tab.\n            this._tabs.forEach((tab, index) => {\n                tab.position = index - indexToSelect;\n                // If there is already a selected tab, then set up an origin for the next selected tab\n                // if it doesn't have one already.\n                if (this._selectedIndex != null && tab.position == 0 && !tab.origin) {\n                    tab.origin = indexToSelect - this._selectedIndex;\n                }\n            });\n            if (this._selectedIndex !== indexToSelect) {\n                this._selectedIndex = indexToSelect;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        ngAfterContentInit() {\n            this._subscribeToAllTabChanges();\n            this._subscribeToTabLabels();\n            // Subscribe to changes in the amount of tabs, in order to be\n            // able to re-render the content as new tabs are added or removed.\n            this._tabsSubscription = this._tabs.changes.subscribe(() => {\n                const indexToSelect = this._clampTabIndex(this._indexToSelect);\n                // Maintain the previously-selected tab if a new tab is added or removed and there is no\n                // explicit change that selects a different tab.\n                if (indexToSelect === this._selectedIndex) {\n                    const tabs = this._tabs.toArray();\n                    for (let i = 0; i < tabs.length; i++) {\n                        if (tabs[i].isActive) {\n                            // Assign both to the `_indexToSelect` and `_selectedIndex` so we don't fire a changed\n                            // event, otherwise the consumer may end up in an infinite loop in some edge cases like\n                            // adding a tab within the `selectedIndexChange` event.\n                            this._indexToSelect = this._selectedIndex = i;\n                            break;\n                        }\n                    }\n                }\n                this._changeDetectorRef.markForCheck();\n            });\n        }\n        /** Listens to changes in all of the tabs. */\n        _subscribeToAllTabChanges() {\n            // Since we use a query with `descendants: true` to pick up the tabs, we may end up catching\n            // some that are inside of nested tab groups. We filter them out manually by checking that\n            // the closest group to the tab is the current one.\n            this._allTabs.changes\n                .pipe(Object(startWith[\"a\" /* startWith */])(this._allTabs))\n                .subscribe((tabs) => {\n                this._tabs.reset(tabs.filter(tab => tab._closestTabGroup === this));\n                this._tabs.notifyOnChanges();\n            });\n        }\n        ngOnDestroy() {\n            this._tabs.destroy();\n            this._tabsSubscription.unsubscribe();\n            this._tabLabelSubscription.unsubscribe();\n        }\n        /** Re-aligns the ink bar to the selected tab element. */\n        realignInkBar() {\n            if (this._tabHeader) {\n                this._tabHeader._alignInkBarToSelectedTab();\n            }\n        }\n        _focusChanged(index) {\n            this.focusChange.emit(this._createChangeEvent(index));\n        }\n        _createChangeEvent(index) {\n            const event = new MatTabChangeEvent;\n            event.index = index;\n            if (this._tabs && this._tabs.length) {\n                event.tab = this._tabs.toArray()[index];\n            }\n            return event;\n        }\n        /**\n         * Subscribes to changes in the tab labels. This is needed, because the @Input for the label is\n         * on the MatTab component, whereas the data binding is inside the MatTabGroup. In order for the\n         * binding to be updated, we need to subscribe to changes in it and trigger change detection\n         * manually.\n         */\n        _subscribeToTabLabels() {\n            if (this._tabLabelSubscription) {\n                this._tabLabelSubscription.unsubscribe();\n            }\n            this._tabLabelSubscription = Object(merge[\"a\" /* merge */])(...this._tabs.map(tab => tab._stateChanges))\n                .subscribe(() => this._changeDetectorRef.markForCheck());\n        }\n        /** Clamps the given index to the bounds of 0 and the tabs length. */\n        _clampTabIndex(index) {\n            // Note the `|| 0`, which ensures that values like NaN can't get through\n            // and which would otherwise throw the component into an infinite loop\n            // (since Math.max(NaN, 0) === NaN).\n            return Math.min(this._tabs.length - 1, Math.max(index || 0, 0));\n        }\n        /** Returns a unique id for each tab label element */\n        _getTabLabelId(i) {\n            return `mat-tab-label-${this._groupId}-${i}`;\n        }\n        /** Returns a unique id for each tab content element */\n        _getTabContentId(i) {\n            return `mat-tab-content-${this._groupId}-${i}`;\n        }\n        /**\n         * Sets the height of the body wrapper to the height of the activating tab if dynamic\n         * height property is true.\n         */\n        _setTabBodyWrapperHeight(tabHeight) {\n            if (!this._dynamicHeight || !this._tabBodyWrapperHeight) {\n                return;\n            }\n            const wrapper = this._tabBodyWrapper.nativeElement;\n            wrapper.style.height = this._tabBodyWrapperHeight + 'px';\n            // This conditional forces the browser to paint the height so that\n            // the animation to the new height can have an origin.\n            if (this._tabBodyWrapper.nativeElement.offsetHeight) {\n                wrapper.style.height = tabHeight + 'px';\n            }\n        }\n        /** Removes the height of the tab body wrapper. */\n        _removeTabBodyWrapperHeight() {\n            const wrapper = this._tabBodyWrapper.nativeElement;\n            this._tabBodyWrapperHeight = wrapper.clientHeight;\n            wrapper.style.height = '';\n            this.animationDone.emit();\n        }\n        /** Handle click events, setting new selected index if appropriate. */\n        _handleClick(tab, tabHeader, index) {\n            if (!tab.disabled) {\n                this.selectedIndex = tabHeader.focusIndex = index;\n            }\n        }\n        /** Retrieves the tabindex for the tab. */\n        _getTabIndex(tab, idx) {\n            if (tab.disabled) {\n                return null;\n            }\n            return this.selectedIndex === idx ? 0 : -1;\n        }\n        /** Callback for when the focused state of a tab has changed. */\n        _tabFocusChanged(focusOrigin, index) {\n            if (focusOrigin) {\n                this._tabHeader.focusIndex = index;\n            }\n        }\n    }\n    _MatTabGroupBase.fac = function _MatTabGroupBase_Factory(t) { return new (t || _MatTabGroupBase)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](MAT_TABS_CONFIG, 8), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    _MatTabGroupBase.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: _MatTabGroupBase, inputs: { headerPosition: \"headerPosition\", animationDuration: \"animationDuration\", disablePagination: \"disablePagination\", dynamicHeight: \"dynamicHeight\", selectedIndex: \"selectedIndex\", backgroundColor: \"backgroundColor\" }, outputs: { selectedIndexChange: \"selectedIndexChange\", focusChange: \"focusChange\", animationDone: \"animationDone\", selectedTabChange: \"selectedTabChange\" }, features: [core[\"xb\" /* InheritDefinitionFeature */]] });\n    return _MatTabGroupBase;\n})();\nlet tabs_MatTabGroup = /*@__PURE__*/ (() => {\n    class MatTabGroup extends tabs_MatTabGroupBase {\n        constructor(elementRef, changeDetectorRef, defaultConfig, animationMode) {\n            super(elementRef, changeDetectorRef, defaultConfig, animationMode);\n        }\n    }\n    MatTabGroup.fac = function MatTabGroup_Factory(t) { return new (t || MatTabGroup)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](MAT_TABS_CONFIG, 8), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatTabGroup.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatTabGroup, selectors: [[\"mat-tab-group\"]], contentQueries: function MatTabGroup_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Fb\" /* contentQuery */](dirIndex, tabs_MatTab, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._allTabs = _t);\n            }\n        }, viewQuery: function MatTabGroup_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"xc\" /* viewQuery */](_c3, true);\n                core[\"xc\" /* viewQuery */](_c4, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._tabBodyWrapper = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._tabHeader = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-group\"], hostVars: 4, hostBindings: function MatTabGroup_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* classProp */](\"mat-tab-group-dynamic-height\", ctx.dynamicHeight)(\"mat-tab-group-inverted-header\", ctx.headerPosition === \"below\");\n            }\n        }, inputs: { color: \"color\", disableRipple: \"disableRipple\" }, exportAs: [\"matTabGroup\"], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{\n                    provide: MAT_TAB_GROUP,\n                    useExisting: MatTabGroup\n                }]), core[\"xb\" /* InheritDefinitionFeature */]], decls: 6, vars: 7, consts: [[3, \"selectedIndex\", \"disableRipple\", \"disablePagination\", \"indexFocused\", \"selectFocusedIndex\"], [\"tabHeader\", \"\"], [\"class\", \"mat-tab-label mat-focus-indicator\", \"role\", \"tab\", \"matTabLabelWrapper\", \"\", \"mat-ripple\", \"\", \"cdkMonitorElementFocus\", \"\", 3, \"id\", \"mat-tab-label-active\", \"disabled\", \"matRippleDisabled\", \"click\", \"cdkFocusChange\", 4, \"ngFor\", \"ngForOf\"], [1, \"mat-tab-body-wrapper\"], [\"tabBodyWrapper\", \"\"], [\"role\", \"tabpanel\", 3, \"id\", \"mat-tab-body-active\", \"content\", \"position\", \"origin\", \"animationDuration\", \"_onCentered\", \"_onCentering\", 4, \"ngFor\", \"ngForOf\"], [\"role\", \"tab\", \"matTabLabelWrapper\", \"\", \"mat-ripple\", \"\", \"cdkMonitorElementFocus\", \"\", 1, \"mat-tab-label\", \"mat-focus-indicator\", 3, \"id\", \"disabled\", \"matRippleDisabled\", \"click\", \"cdkFocusChange\"], [1, \"mat-tab-label-content\"], [3, \"ngIf\"], [3, \"cdkPortalOutlet\"], [\"role\", \"tabpanel\", 3, \"id\", \"content\", \"position\", \"origin\", \"animationDuration\", \"_onCentered\", \"_onCentering\"]], template: function MatTabGroup_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"Sb\" /* elementStart */](0, \"mat-tab-header\", 0, 1);\n                core[\"Zb\" /* listener */](\"indexFocused\", function MatTabGroup_Template_mat_tab_header_indexFocused_0_listener($event) { return ctx._focusChanged($event); })(\"selectFocusedIndex\", function MatTabGroup_Template_mat_tab_header_selectFocusedIndex_0_listener($event) { return ctx.selectedIndex = $event; });\n                core[\"sc\" /* template */](2, MatTabGroup_div_2_Template, 4, 14, \"div\", 2);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](3, \"div\", 3, 4);\n                core[\"sc\" /* template */](5, MatTabGroup_mat_tab_body_5_Template, 1, 8, \"mat-tab-body\", 5);\n                core[\"Rb\" /* elementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"ec\" /* property */](\"selectedIndex\", ctx.selectedIndex || 0)(\"disableRipple\", ctx.disableRipple)(\"disablePagination\", ctx.disablePagination);\n                core[\"Ab\" /* advance */](2);\n                core[\"ec\" /* property */](\"ngForOf\", ctx._tabs);\n                core[\"Ab\" /* advance */](1);\n                core[\"Eb\" /* classProp */](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n                core[\"Ab\" /* advance */](2);\n                core[\"ec\" /* property */](\"ngForOf\", ctx._tabs);\n            }\n        }, directives: function () { return [tabs_MatTabHeader, common[\"i\" /* NgForOf */], tabs_MatTabLabelWrapper, core_MatRipple, a11y_CdkMonitorFocus, common[\"j\" /* NgIf */], portal_CdkPortalOutlet, tabs_MatTabBody]; }, styles: [\".mat-tab-group{display:flex;flex-direction:column}.mat-tab-group.mat-tab-group-inverted-header{flex-direction:column-reverse}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{padding:0 12px}}@media(max-width: 959px){.mat-tab-label{padding:0 12px}}.mat-tab-group[mat-stretch-tabs]>.mat-tab-header .mat-tab-label{flex-basis:0;flex-grow:1}.mat-tab-body-wrapper{position:relative;overflow:hidden;display:flex;transition:height 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-tab-body-wrapper{transition:none;animation:none}.mat-tab-body{top:0;left:0;right:0;bottom:0;position:absolute;display:block;overflow:hidden;flex-basis:100%}.mat-tab-body.mat-tab-body-active{position:relative;overflow-x:hidden;overflow-y:auto;z-index:1;flex-grow:1}.mat-tab-group.mat-tab-group-dynamic-height .mat-tab-body.mat-tab-body-active{overflow-y:hidden}\\n\"], encapsulation: 2 });\n    return MatTabGroup;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// Boilerplate for applying mixins to MatTabLabelWrapper.\n/** @docs-private */\nclass MatTabLabelWrapperBase {\n}\nconst _MatTabLabelWrapperMixinBase = /*@__PURE__*/ mixinDisabled(MatTabLabelWrapperBase);\nlet tabs_MatTabLabelWrapper = /*@__PURE__*/ (() => {\n    class MatTabLabelWrapper extends _MatTabLabelWrapperMixinBase {\n        constructor(elementRef) {\n            super();\n            this.elementRef = elementRef;\n        }\n        /** Sets focus on the wrapper element */\n        focus() {\n            this.elementRef.nativeElement.focus();\n        }\n        getOffsetLeft() {\n            return this.elementRef.nativeElement.offsetLeft;\n        }\n        getOffsetWidth() {\n            return this.elementRef.nativeElement.offsetWidth;\n        }\n    }\n    MatTabLabelWrapper.fac = function MatTabLabelWrapper_Factory(t) { return new (t || MatTabLabelWrapper)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */])); };\n    MatTabLabelWrapper.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatTabLabelWrapper, selectors: [[\"\", \"matTabLabelWrapper\", \"\"]], hostVars: 3, hostBindings: function MatTabLabelWrapper_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Bb\" /* attribute */](\"aria-disabled\", !!ctx.disabled);\n                core[\"Eb\" /* classProp */](\"mat-tab-disabled\", ctx.disabled);\n            }\n        }, inputs: { disabled: \"disabled\" }, features: [core[\"xb\" /* InheritDefinitionFeature */]] });\n    return MatTabLabelWrapper;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Config used to bind passive event listeners */\nconst passiveEventListenerOptions = /*@__PURE__*/ normalizePassiveListenerOptions({ passive: true });\n/**\n * The distance in pixels that will be overshot when scrolling a tab label into view. This helps\n * provide a small affordance to the label next to it.\n */\nconst EXAGGERATED_OVERSCROLL = 60;\n/**\n * Amount of milliseconds to wait before starting to scroll the header automatically.\n * Set a little conservatively in order to handle fake events dispatched on touch devices.\n */\nconst HEADER_SCROLL_DELAY = 650;\n/**\n * Interval in milliseconds at which to scroll the header\n * while the user is holding their pointer.\n */\nconst HEADER_SCROLL_INTERVAL = 100;\nlet tabs_MatPaginatedTabHeader = /*@__PURE__*/ (() => {\n    class MatPaginatedTabHeader {\n        constructor(_elementRef, _changeDetectorRef, _viewportRuler, _dir, _ngZone, _platform, _animationMode) {\n            this._elementRef = _elementRef;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._viewportRuler = _viewportRuler;\n            this._dir = _dir;\n            this._ngZone = _ngZone;\n            this._platform = _platform;\n            this._animationMode = _animationMode;\n            /** The distance in pixels that the tab labels should be translated to the left. */\n            this._scrollDistance = 0;\n            /** Whether the header should scroll to the selected index after the view has been checked. */\n            this._selectedIndexChanged = false;\n            /** Emits when the component is destroyed. */\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            /** Whether the controls for pagination should be displayed */\n            this._showPaginationControls = false;\n            /** Whether the tab list can be scrolled more towards the end of the tab label list. */\n            this._disableScrollAfter = true;\n            /** Whether the tab list can be scrolled more towards the beginning of the tab label list. */\n            this._disableScrollBefore = true;\n            /** Stream that will stop the automated scrolling. */\n            this._stopScrolling = new Subject[\"a\" /* Subject */]();\n            /**\n             * Whether pagination should be disabled. This can be used to avoid unnecessary\n             * layout recalculations if it's known that pagination won't be required.\n             */\n            this.disablePagination = false;\n            this._selectedIndex = 0;\n            /** Event emitted when the option is selected. */\n            this.selectFocusedIndex = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted when a label is focused. */\n            this.indexFocused = new core[\"n\" /* EventEmitter */]();\n            // Bind the `mouseleave` event on the outside since it doesn't change anything in the view.\n            _ngZone.runOutsideAngular(() => {\n                fromEvent(_elementRef.nativeElement, 'mouseleave')\n                    .pipe(takeUntil(this._destroyed))\n                    .subscribe(() => {\n                    this._stopInterval();\n                });\n            });\n        }\n        /** The index of the active tab. */\n        get selectedIndex() { return this._selectedIndex; }\n        set selectedIndex(value) {\n            value = coerceNumberProperty(value);\n            if (this._selectedIndex != value) {\n                this._selectedIndexChanged = true;\n                this._selectedIndex = value;\n                if (this._keyManager) {\n                    this._keyManager.updateActiveItem(value);\n                }\n            }\n        }\n        ngAfterViewInit() {\n            // We need to handle these events manually, because we want to bind passive event listeners.\n            fromEvent(this._previousPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n                .pipe(takeUntil(this._destroyed))\n                .subscribe(() => {\n                this._handlePaginatorPress('before');\n            });\n            fromEvent(this._nextPaginator.nativeElement, 'touchstart', passiveEventListenerOptions)\n                .pipe(takeUntil(this._destroyed))\n                .subscribe(() => {\n                this._handlePaginatorPress('after');\n            });\n        }\n        ngAfterContentInit() {\n            const dirChange = this._dir ? this._dir.change : Object(of[\"a\" /* of */])(null);\n            const resize = this._viewportRuler.change(150);\n            const realign = () => {\n                this.updatePagination();\n                this._alignInkBarToSelectedTab();\n            };\n            this._keyManager = new FocusKeyManager(this._items)\n                .withHorizontalOrientation(this._getLayoutDirection())\n                .withHomeAndEnd()\n                .withWrap();\n            this._keyManager.updateActiveItem(this._selectedIndex);\n            // Defer the first call in order to allow for slower browsers to lay out the elements.\n            // This helps in cases where the user lands directly on a page with paginated tabs.\n            typeof requestAnimationFrame !== 'undefined' ? requestAnimationFrame(realign) : realign();\n            // On dir change or window resize, realign the ink bar and update the orientation of\n            // the key manager if the direction has changed.\n            Object(merge[\"a\" /* merge */])(dirChange, resize, this._items.changes).pipe(takeUntil(this._destroyed)).subscribe(() => {\n                // We need to defer this to give the browser some time to recalculate\n                // the element dimensions. The call has to be wrapped in `NgZone.run`,\n                // because the viewport change handler runs outside of Angular.\n                this._ngZone.run(() => Promise.resolve().then(realign));\n                this._keyManager.withHorizontalOrientation(this._getLayoutDirection());\n            });\n            // If there is a change in the focus key manager we need to emit the `indexFocused`\n            // event in order to provide a public event that notifies about focus changes. Also we realign\n            // the tabs container by scrolling the new focused tab into the visible section.\n            this._keyManager.change.pipe(takeUntil(this._destroyed)).subscribe(newFocusIndex => {\n                this.indexFocused.emit(newFocusIndex);\n                this._setTabFocus(newFocusIndex);\n            });\n        }\n        ngAfterContentChecked() {\n            // If the number of tab labels have changed, check if scrolling should be enabled\n            if (this._tabLabelCount != this._items.length) {\n                this.updatePagination();\n                this._tabLabelCount = this._items.length;\n                this._changeDetectorRef.markForCheck();\n            }\n            // If the selected index has changed, scroll to the label and check if the scrolling controls\n            // should be disabled.\n            if (this._selectedIndexChanged) {\n                this._scrollToLabel(this._selectedIndex);\n                this._checkScrollingControls();\n                this._alignInkBarToSelectedTab();\n                this._selectedIndexChanged = false;\n                this._changeDetectorRef.markForCheck();\n            }\n            // If the scroll distance has been changed (tab selected, focused, scroll controls activated),\n            // then translate the header to reflect this.\n            if (this._scrollDistanceChanged) {\n                this._updateTabScrollPosition();\n                this._scrollDistanceChanged = false;\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        ngOnDestroy() {\n            this._destroyed.next();\n            this._destroyed.complete();\n            this._stopScrolling.complete();\n        }\n        /** Handles keyboard events on the header. */\n        _handleKeydown(event) {\n            // We don't handle any key bindings with a modifier key.\n            if (hasModifierKey(event)) {\n                return;\n            }\n            switch (event.keyCode) {\n                case ENTER:\n                case SPACE:\n                    if (this.focusIndex !== this.selectedIndex) {\n                        this.selectFocusedIndex.emit(this.focusIndex);\n                        this._itemSelected(event);\n                    }\n                    break;\n                default:\n                    this._keyManager.onKeydown(event);\n            }\n        }\n        /**\n         * Callback for when the MutationObserver detects that the content has changed.\n         */\n        _onContentChanges() {\n            const textContent = this._elementRef.nativeElement.textContent;\n            // We need to diff the text content of the header, because the MutationObserver callback\n            // will fire even if the text content didn't change which is inefficient and is prone\n            // to infinite loops if a poorly constructed expression is passed in (see #14249).\n            if (textContent !== this._currentTextContent) {\n                this._currentTextContent = textContent || '';\n                // The content observer runs outside the `NgZone` by default, which\n                // means that we need to bring the callback back in ourselves.\n                this._ngZone.run(() => {\n                    this.updatePagination();\n                    this._alignInkBarToSelectedTab();\n                    this._changeDetectorRef.markForCheck();\n                });\n            }\n        }\n        /**\n         * Updates the view whether pagination should be enabled or not.\n         *\n         * WARNING: Calling this method can be very costly in terms of performance. It should be called\n         * as infrequently as possible from outside of the Tabs component as it causes a reflow of the\n         * page.\n         */\n        updatePagination() {\n            this._checkPaginationEnabled();\n            this._checkScrollingControls();\n            this._updateTabScrollPosition();\n        }\n        /** Tracks which element has focus; used for keyboard navigation */\n        get focusIndex() {\n            return this._keyManager ? this._keyManager.activeItemIndex : 0;\n        }\n        /** When the focus index is set, we must manually send focus to the correct label */\n        set focusIndex(value) {\n            if (!this._isValidIndex(value) || this.focusIndex === value || !this._keyManager) {\n                return;\n            }\n            this._keyManager.setActiveItem(value);\n        }\n        /**\n         * Determines if an index is valid.  If the tabs are not ready yet, we assume that the user is\n         * providing a valid index and return true.\n         */\n        _isValidIndex(index) {\n            if (!this._items) {\n                return true;\n            }\n            const tab = this._items ? this._items.toArray()[index] : null;\n            return !!tab && !tab.disabled;\n        }\n        /**\n         * Sets focus on the HTML element for the label wrapper and scrolls it into the view if\n         * scrolling is enabled.\n         */\n        _setTabFocus(tabIndex) {\n            if (this._showPaginationControls) {\n                this._scrollToLabel(tabIndex);\n            }\n            if (this._items && this._items.length) {\n                this._items.toArray()[tabIndex].focus();\n                // Do not let the browser manage scrolling to focus the element, this will be handled\n                // by using translation. In LTR, the scroll left should be 0. In RTL, the scroll width\n                // should be the full width minus the offset width.\n                const containerEl = this._tabListContainer.nativeElement;\n                const dir = this._getLayoutDirection();\n                if (dir == 'ltr') {\n                    containerEl.scrollLeft = 0;\n                }\n                else {\n                    containerEl.scrollLeft = containerEl.scrollWidth - containerEl.offsetWidth;\n                }\n            }\n        }\n        /** The layout direction of the containing app. */\n        _getLayoutDirection() {\n            return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\n        }\n        /** Performs the CSS transformation on the tab list that will cause the list to scroll. */\n        _updateTabScrollPosition() {\n            if (this.disablePagination) {\n                return;\n            }\n            const scrollDistance = this.scrollDistance;\n            const translateX = this._getLayoutDirection() === 'ltr' ? -scrollDistance : scrollDistance;\n            // Don't use `translate3d` here because we don't want to create a new layer. A new layer\n            // seems to cause flickering and overflow in Internet Explorer. For example, the ink bar\n            // and ripples will exceed the boundaries of the visible tab bar.\n            // See: https://github.com/angular/components/issues/10276\n            // We round the `transform` here, because transforms with sub-pixel precision cause some\n            // browsers to blur the content of the element.\n            this._tabList.nativeElement.style.transform = `translateX(${Math.round(translateX)}px)`;\n            // Setting the `transform` on IE will change the scroll offset of the parent, causing the\n            // position to be thrown off in some cases. We have to reset it ourselves to ensure that\n            // it doesn't get thrown off. Note that we scope it only to IE and Edge, because messing\n            // with the scroll position throws off Chrome 71+ in RTL mode (see #14689).\n            if (this._platform.TRIDENT || this._platform.EDGE) {\n                this._tabListContainer.nativeElement.scrollLeft = 0;\n            }\n        }\n        /** Sets the distance in pixels that the tab header should be transformed in the X-axis. */\n        get scrollDistance() { return this._scrollDistance; }\n        set scrollDistance(value) {\n            this._scrollTo(value);\n        }\n        /**\n         * Moves the tab list in the 'before' or 'after' direction (towards the beginning of the list or\n         * the end of the list, respectively). The distance to scroll is computed to be a third of the\n         * length of the tab list view window.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _scrollHeader(direction) {\n            const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            // Move the scroll distance one-third the length of the tab list's viewport.\n            const scrollAmount = (direction == 'before' ? -1 : 1) * viewLength / 3;\n            return this._scrollTo(this._scrollDistance + scrollAmount);\n        }\n        /** Handles click events on the pagination arrows. */\n        _handlePaginatorClick(direction) {\n            this._stopInterval();\n            this._scrollHeader(direction);\n        }\n        /**\n         * Moves the tab list such that the desired tab label (marked by index) is moved into view.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _scrollToLabel(labelIndex) {\n            if (this.disablePagination) {\n                return;\n            }\n            const selectedLabel = this._items ? this._items.toArray()[labelIndex] : null;\n            if (!selectedLabel) {\n                return;\n            }\n            // The view length is the visible width of the tab labels.\n            const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            const { offsetLeft, offsetWidth } = selectedLabel.elementRef.nativeElement;\n            let labelBeforePos, labelAfterPos;\n            if (this._getLayoutDirection() == 'ltr') {\n                labelBeforePos = offsetLeft;\n                labelAfterPos = labelBeforePos + offsetWidth;\n            }\n            else {\n                labelAfterPos = this._tabList.nativeElement.offsetWidth - offsetLeft;\n                labelBeforePos = labelAfterPos - offsetWidth;\n            }\n            const beforeVisiblePos = this.scrollDistance;\n            const afterVisiblePos = this.scrollDistance + viewLength;\n            if (labelBeforePos < beforeVisiblePos) {\n                // Scroll header to move label to the before direction\n                this.scrollDistance -= beforeVisiblePos - labelBeforePos + EXAGGERATED_OVERSCROLL;\n            }\n            else if (labelAfterPos > afterVisiblePos) {\n                // Scroll header to move label to the after direction\n                this.scrollDistance += labelAfterPos - afterVisiblePos + EXAGGERATED_OVERSCROLL;\n            }\n        }\n        /**\n         * Evaluate whether the pagination controls should be displayed. If the scroll width of the\n         * tab list is wider than the size of the header container, then the pagination controls should\n         * be shown.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _checkPaginationEnabled() {\n            if (this.disablePagination) {\n                this._showPaginationControls = false;\n            }\n            else {\n                const isEnabled = this._tabList.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth;\n                if (!isEnabled) {\n                    this.scrollDistance = 0;\n                }\n                if (isEnabled !== this._showPaginationControls) {\n                    this._changeDetectorRef.markForCheck();\n                }\n                this._showPaginationControls = isEnabled;\n            }\n        }\n        /**\n         * Evaluate whether the before and after controls should be enabled or disabled.\n         * If the header is at the beginning of the list (scroll distance is equal to 0) then disable the\n         * before button. If the header is at the end of the list (scroll distance is equal to the\n         * maximum distance we can scroll), then disable the after button.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _checkScrollingControls() {\n            if (this.disablePagination) {\n                this._disableScrollAfter = this._disableScrollBefore = true;\n            }\n            else {\n                // Check if the pagination arrows should be activated.\n                this._disableScrollBefore = this.scrollDistance == 0;\n                this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance();\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        /**\n         * Determines what is the maximum length in pixels that can be set for the scroll distance. This\n         * is equal to the difference in width between the tab list container and tab header container.\n         *\n         * This is an expensive call that forces a layout reflow to compute box and scroll metrics and\n         * should be called sparingly.\n         */\n        _getMaxScrollDistance() {\n            const lengthOfTabList = this._tabList.nativeElement.scrollWidth;\n            const viewLength = this._tabListContainer.nativeElement.offsetWidth;\n            return (lengthOfTabList - viewLength) || 0;\n        }\n        /** Tells the ink-bar to align itself to the current label wrapper */\n        _alignInkBarToSelectedTab() {\n            const selectedItem = this._items && this._items.length ?\n                this._items.toArray()[this.selectedIndex] : null;\n            const selectedLabelWrapper = selectedItem ? selectedItem.elementRef.nativeElement : null;\n            if (selectedLabelWrapper) {\n                this._inkBar.alignToElement(selectedLabelWrapper);\n            }\n            else {\n                this._inkBar.hide();\n            }\n        }\n        /** Stops the currently-running paginator interval.  */\n        _stopInterval() {\n            this._stopScrolling.next();\n        }\n        /**\n         * Handles the user pressing down on one of the paginators.\n         * Starts scrolling the header after a certain amount of time.\n         * @param direction In which direction the paginator should be scrolled.\n         */\n        _handlePaginatorPress(direction, mouseEvent) {\n            // Don't start auto scrolling for right mouse button clicks. Note that we shouldn't have to\n            // null check the `button`, but we do it so we don't break tests that use fake events.\n            if (mouseEvent && mouseEvent.button != null && mouseEvent.button !== 0) {\n                return;\n            }\n            // Avoid overlapping timers.\n            this._stopInterval();\n            // Start a timer after the delay and keep firing based on the interval.\n            timer(HEADER_SCROLL_DELAY, HEADER_SCROLL_INTERVAL)\n                // Keep the timer going until something tells it to stop or the component is destroyed.\n                .pipe(takeUntil(Object(merge[\"a\" /* merge */])(this._stopScrolling, this._destroyed)))\n                .subscribe(() => {\n                const { maxScrollDistance, distance } = this._scrollHeader(direction);\n                // Stop the timer if we've reached the start or the end.\n                if (distance === 0 || distance >= maxScrollDistance) {\n                    this._stopInterval();\n                }\n            });\n        }\n        /**\n         * Scrolls the header to a given position.\n         * @param position Position to which to scroll.\n         * @returns Information on the current scroll distance and the maximum.\n         */\n        _scrollTo(position) {\n            if (this.disablePagination) {\n                return { maxScrollDistance: 0, distance: 0 };\n            }\n            const maxScrollDistance = this._getMaxScrollDistance();\n            this._scrollDistance = Math.max(0, Math.min(maxScrollDistance, position));\n            // Mark that the scroll distance has changed so that after the view is checked, the CSS\n            // transformation can move the header.\n            this._scrollDistanceChanged = true;\n            this._checkScrollingControls();\n            return { maxScrollDistance, distance: this._scrollDistance };\n        }\n    }\n    MatPaginatedTabHeader.fac = function MatPaginatedTabHeader_Factory(t) { return new (t || MatPaginatedTabHeader)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](scrolling_ViewportRuler), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](platform_Platform), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatPaginatedTabHeader.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatPaginatedTabHeader, inputs: { disablePagination: \"disablePagination\" } });\n    return MatPaginatedTabHeader;\n})();\nlet tabs_MatTabHeaderBase = /*@__PURE__*/ (() => {\n    class _MatTabHeaderBase extends tabs_MatPaginatedTabHeader {\n        constructor(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) {\n            super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);\n            this._disableRipple = false;\n        }\n        /** Whether the ripple effect is disabled or not. */\n        get disableRipple() { return this._disableRipple; }\n        set disableRipple(value) { this._disableRipple = coerceBooleanProperty(value); }\n        _itemSelected(event) {\n            event.preventDefault();\n        }\n    }\n    _MatTabHeaderBase.fac = function _MatTabHeaderBase_Factory(t) { return new (t || _MatTabHeaderBase)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](scrolling_ViewportRuler), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](platform_Platform), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    _MatTabHeaderBase.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: _MatTabHeaderBase, inputs: { disableRipple: \"disableRipple\" }, features: [core[\"xb\" /* InheritDefinitionFeature */]] });\n    return _MatTabHeaderBase;\n})();\nlet tabs_MatTabHeader = /*@__PURE__*/ (() => {\n    class MatTabHeader extends tabs_MatTabHeaderBase {\n        constructor(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode) {\n            super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);\n        }\n    }\n    MatTabHeader.fac = function MatTabHeader_Factory(t) { return new (t || MatTabHeader)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](scrolling_ViewportRuler), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](platform_Platform), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatTabHeader.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatTabHeader, selectors: [[\"mat-tab-header\"]], contentQueries: function MatTabHeader_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Fb\" /* contentQuery */](dirIndex, tabs_MatTabLabelWrapper, false);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._items = _t);\n            }\n        }, viewQuery: function MatTabHeader_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"qc\" /* staticViewQuery */](tabs_MatInkBar, true);\n                core[\"qc\" /* staticViewQuery */](_c5, true);\n                core[\"qc\" /* staticViewQuery */](_c6, true);\n                core[\"xc\" /* viewQuery */](_c7, true);\n                core[\"xc\" /* viewQuery */](_c8, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._inkBar = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._tabListContainer = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._tabList = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._nextPaginator = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._previousPaginator = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-header\"], hostVars: 4, hostBindings: function MatTabHeader_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* classProp */](\"mat-tab-header-pagination-controls-enabled\", ctx._showPaginationControls)(\"mat-tab-header-rtl\", ctx._getLayoutDirection() == \"rtl\");\n            }\n        }, inputs: { selectedIndex: \"selectedIndex\" }, outputs: { selectFocusedIndex: \"selectFocusedIndex\", indexFocused: \"indexFocused\" }, features: [core[\"xb\" /* InheritDefinitionFeature */]], ngContentSelectors: tabs_c0, decls: 13, vars: 8, consts: [[\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-before\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"click\", \"mousedown\", \"touchend\"], [\"previousPaginator\", \"\"], [1, \"mat-tab-header-pagination-chevron\"], [1, \"mat-tab-label-container\", 3, \"keydown\"], [\"tabListContainer\", \"\"], [\"role\", \"tablist\", 1, \"mat-tab-list\", 3, \"cdkObserveContent\"], [\"tabList\", \"\"], [1, \"mat-tab-labels\"], [\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-after\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"mousedown\", \"click\", \"touchend\"], [\"nextPaginator\", \"\"]], template: function MatTabHeader_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"dc\" /* projectionDef */]();\n                core[\"Sb\" /* elementStart */](0, \"div\", 0, 1);\n                core[\"Zb\" /* listener */](\"click\", function MatTabHeader_Template_div_click_0_listener() { return ctx._handlePaginatorClick(\"before\"); })(\"mousedown\", function MatTabHeader_Template_div_mousedown_0_listener($event) { return ctx._handlePaginatorPress(\"before\", $event); })(\"touchend\", function MatTabHeader_Template_div_touchend_0_listener() { return ctx._stopInterval(); });\n                core[\"Nb\" /* element */](2, \"div\", 2);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](3, \"div\", 3, 4);\n                core[\"Zb\" /* listener */](\"keydown\", function MatTabHeader_Template_div_keydown_3_listener($event) { return ctx._handleKeydown($event); });\n                core[\"Sb\" /* elementStart */](5, \"div\", 5, 6);\n                core[\"Zb\" /* listener */](\"cdkObserveContent\", function MatTabHeader_Template_div_cdkObserveContent_5_listener() { return ctx._onContentChanges(); });\n                core[\"Sb\" /* elementStart */](7, \"div\", 7);\n                core[\"cc\" /* projection */](8);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Nb\" /* element */](9, \"mat-ink-bar\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](10, \"div\", 8, 9);\n                core[\"Zb\" /* listener */](\"mousedown\", function MatTabHeader_Template_div_mousedown_10_listener($event) { return ctx._handlePaginatorPress(\"after\", $event); })(\"click\", function MatTabHeader_Template_div_click_10_listener() { return ctx._handlePaginatorClick(\"after\"); })(\"touchend\", function MatTabHeader_Template_div_touchend_10_listener() { return ctx._stopInterval(); });\n                core[\"Nb\" /* element */](12, \"div\", 2);\n                core[\"Rb\" /* elementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"Eb\" /* classProp */](\"mat-tab-header-pagination-disabled\", ctx._disableScrollBefore);\n                core[\"ec\" /* property */](\"matRippleDisabled\", ctx._disableScrollBefore || ctx.disableRipple);\n                core[\"Ab\" /* advance */](5);\n                core[\"Eb\" /* classProp */](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n                core[\"Ab\" /* advance */](5);\n                core[\"Eb\" /* classProp */](\"mat-tab-header-pagination-disabled\", ctx._disableScrollAfter);\n                core[\"ec\" /* property */](\"matRippleDisabled\", ctx._disableScrollAfter || ctx.disableRipple);\n            }\n        }, directives: [core_MatRipple, observers_CdkObserveContent, tabs_MatInkBar], styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\\\"\\\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-labels{display:flex}[mat-align-tabs=center]>.mat-tab-header .mat-tab-labels{justify-content:center}[mat-align-tabs=end]>.mat-tab-header .mat-tab-labels{justify-content:flex-end}.mat-tab-label-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}._mat-animation-noopable.mat-tab-list{transition:none;animation:none}.mat-tab-label{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;position:relative}.mat-tab-label:focus{outline:none}.mat-tab-label:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-label:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-label.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-label.mat-tab-disabled{opacity:.5}.mat-tab-label .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-label{opacity:1}@media(max-width: 599px){.mat-tab-label{min-width:72px}}\\n\"], encapsulation: 2 });\n    return MatTabHeader;\n})();\nlet tabs_MatTabNavBase = /*@__PURE__*/ (() => {\n    class _MatTabNavBase extends tabs_MatPaginatedTabHeader {\n        constructor(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode) {\n            super(elementRef, changeDetectorRef, viewportRuler, dir, ngZone, platform, animationMode);\n            this._disableRipple = false;\n            /** Theme color of the nav bar. */\n            this.color = 'primary';\n        }\n        /** Background color of the tab nav. */\n        get backgroundColor() { return this._backgroundColor; }\n        set backgroundColor(value) {\n            const classList = this._elementRef.nativeElement.classList;\n            classList.remove(`mat-background-${this.backgroundColor}`);\n            if (value) {\n                classList.add(`mat-background-${value}`);\n            }\n            this._backgroundColor = value;\n        }\n        /** Whether the ripple effect is disabled or not. */\n        get disableRipple() { return this._disableRipple; }\n        set disableRipple(value) { this._disableRipple = coerceBooleanProperty(value); }\n        _itemSelected() {\n            // noop\n        }\n        ngAfterContentInit() {\n            // We need this to run before the `changes` subscription in parent to ensure that the\n            // selectedIndex is up-to-date by the time the super class starts looking for it.\n            this._items.changes.pipe(Object(startWith[\"a\" /* startWith */])(null), takeUntil(this._destroyed)).subscribe(() => {\n                this.updateActiveLink();\n            });\n            super.ngAfterContentInit();\n        }\n        /** Notifies the component that the active link has been changed. */\n        updateActiveLink() {\n            if (!this._items) {\n                return;\n            }\n            const items = this._items.toArray();\n            for (let i = 0; i < items.length; i++) {\n                if (items[i].active) {\n                    this.selectedIndex = i;\n                    this._changeDetectorRef.markForCheck();\n                    return;\n                }\n            }\n            // The ink bar should hide itself if no items are active.\n            this.selectedIndex = -1;\n            this._inkBar.hide();\n        }\n    }\n    _MatTabNavBase.fac = function _MatTabNavBase_Factory(t) { return new (t || _MatTabNavBase)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](scrolling_ViewportRuler), core[\"Mb\" /* directiveInject */](platform_Platform), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    _MatTabNavBase.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: _MatTabNavBase, inputs: { color: \"color\", backgroundColor: \"backgroundColor\", disableRipple: \"disableRipple\" }, features: [core[\"xb\" /* InheritDefinitionFeature */]] });\n    return _MatTabNavBase;\n})();\nlet tabs_MatTabNav = /*@__PURE__*/ (() => {\n    class MatTabNav extends tabs_MatTabNavBase {\n        constructor(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode) {\n            super(elementRef, dir, ngZone, changeDetectorRef, viewportRuler, platform, animationMode);\n        }\n    }\n    MatTabNav.fac = function MatTabNav_Factory(t) { return new (t || MatTabNav)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](scrolling_ViewportRuler), core[\"Mb\" /* directiveInject */](platform_Platform), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatTabNav.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatTabNav, selectors: [[\"\", \"mat-tab-nav-bar\", \"\"]], contentQueries: function MatTabNav_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Fb\" /* contentQuery */](dirIndex, tabs_MatTabLink, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._items = _t);\n            }\n        }, viewQuery: function MatTabNav_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"qc\" /* staticViewQuery */](tabs_MatInkBar, true);\n                core[\"qc\" /* staticViewQuery */](_c5, true);\n                core[\"qc\" /* staticViewQuery */](_c6, true);\n                core[\"xc\" /* viewQuery */](_c7, true);\n                core[\"xc\" /* viewQuery */](_c8, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._inkBar = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._tabListContainer = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._tabList = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._nextPaginator = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._previousPaginator = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-tab-nav-bar\", \"mat-tab-header\"], hostVars: 10, hostBindings: function MatTabNav_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* classProp */](\"mat-tab-header-pagination-controls-enabled\", ctx._showPaginationControls)(\"mat-tab-header-rtl\", ctx._getLayoutDirection() == \"rtl\")(\"mat-primary\", ctx.color !== \"warn\" && ctx.color !== \"accent\")(\"mat-accent\", ctx.color === \"accent\")(\"mat-warn\", ctx.color === \"warn\");\n            }\n        }, inputs: { color: \"color\" }, exportAs: [\"matTabNavBar\", \"matTabNav\"], features: [core[\"xb\" /* InheritDefinitionFeature */]], attrs: _c9, ngContentSelectors: tabs_c0, decls: 13, vars: 8, consts: [[\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-before\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"click\", \"mousedown\", \"touchend\"], [\"previousPaginator\", \"\"], [1, \"mat-tab-header-pagination-chevron\"], [1, \"mat-tab-link-container\", 3, \"keydown\"], [\"tabListContainer\", \"\"], [1, \"mat-tab-list\", 3, \"cdkObserveContent\"], [\"tabList\", \"\"], [1, \"mat-tab-links\"], [\"aria-hidden\", \"true\", \"mat-ripple\", \"\", 1, \"mat-tab-header-pagination\", \"mat-tab-header-pagination-after\", \"mat-elevation-z4\", 3, \"matRippleDisabled\", \"mousedown\", \"click\", \"touchend\"], [\"nextPaginator\", \"\"]], template: function MatTabNav_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"dc\" /* projectionDef */]();\n                core[\"Sb\" /* elementStart */](0, \"div\", 0, 1);\n                core[\"Zb\" /* listener */](\"click\", function MatTabNav_Template_div_click_0_listener() { return ctx._handlePaginatorClick(\"before\"); })(\"mousedown\", function MatTabNav_Template_div_mousedown_0_listener($event) { return ctx._handlePaginatorPress(\"before\", $event); })(\"touchend\", function MatTabNav_Template_div_touchend_0_listener() { return ctx._stopInterval(); });\n                core[\"Nb\" /* element */](2, \"div\", 2);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](3, \"div\", 3, 4);\n                core[\"Zb\" /* listener */](\"keydown\", function MatTabNav_Template_div_keydown_3_listener($event) { return ctx._handleKeydown($event); });\n                core[\"Sb\" /* elementStart */](5, \"div\", 5, 6);\n                core[\"Zb\" /* listener */](\"cdkObserveContent\", function MatTabNav_Template_div_cdkObserveContent_5_listener() { return ctx._onContentChanges(); });\n                core[\"Sb\" /* elementStart */](7, \"div\", 7);\n                core[\"cc\" /* projection */](8);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Nb\" /* element */](9, \"mat-ink-bar\");\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](10, \"div\", 8, 9);\n                core[\"Zb\" /* listener */](\"mousedown\", function MatTabNav_Template_div_mousedown_10_listener($event) { return ctx._handlePaginatorPress(\"after\", $event); })(\"click\", function MatTabNav_Template_div_click_10_listener() { return ctx._handlePaginatorClick(\"after\"); })(\"touchend\", function MatTabNav_Template_div_touchend_10_listener() { return ctx._stopInterval(); });\n                core[\"Nb\" /* element */](12, \"div\", 2);\n                core[\"Rb\" /* elementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"Eb\" /* classProp */](\"mat-tab-header-pagination-disabled\", ctx._disableScrollBefore);\n                core[\"ec\" /* property */](\"matRippleDisabled\", ctx._disableScrollBefore || ctx.disableRipple);\n                core[\"Ab\" /* advance */](5);\n                core[\"Eb\" /* classProp */](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\n                core[\"Ab\" /* advance */](5);\n                core[\"Eb\" /* classProp */](\"mat-tab-header-pagination-disabled\", ctx._disableScrollAfter);\n                core[\"ec\" /* property */](\"matRippleDisabled\", ctx._disableScrollAfter || ctx.disableRipple);\n            }\n        }, directives: [core_MatRipple, observers_CdkObserveContent, tabs_MatInkBar], styles: [\".mat-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0}.mat-tab-header-pagination{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:transparent;touch-action:none}.mat-tab-header-pagination-controls-enabled .mat-tab-header-pagination{display:flex}.mat-tab-header-pagination-before,.mat-tab-header-rtl .mat-tab-header-pagination-after{padding-left:4px}.mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-rtl .mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-tab-header-rtl .mat-tab-header-pagination-before,.mat-tab-header-pagination-after{padding-right:4px}.mat-tab-header-rtl .mat-tab-header-pagination-before .mat-tab-header-pagination-chevron,.mat-tab-header-pagination-after .mat-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;content:\\\"\\\";height:8px;width:8px}.mat-tab-header-pagination-disabled{box-shadow:none;cursor:default}.mat-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}.mat-tab-links{display:flex}[mat-align-tabs=center]>.mat-tab-link-container .mat-tab-links{justify-content:center}[mat-align-tabs=end]>.mat-tab-link-container .mat-tab-links{justify-content:flex-end}.mat-ink-bar{position:absolute;bottom:0;height:2px;transition:500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable.mat-ink-bar{transition:none;animation:none}.mat-tab-group-inverted-header .mat-ink-bar{bottom:auto;top:0}.cdk-high-contrast-active .mat-ink-bar{outline:solid 2px;height:0}.mat-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-tab-link{height:48px;padding:0 24px;cursor:pointer;box-sizing:border-box;opacity:.6;min-width:160px;text-align:center;display:inline-flex;justify-content:center;align-items:center;white-space:nowrap;vertical-align:top;text-decoration:none;position:relative;overflow:hidden;-webkit-tap-highlight-color:transparent}.mat-tab-link:focus{outline:none}.mat-tab-link:focus:not(.mat-tab-disabled){opacity:1}.cdk-high-contrast-active .mat-tab-link:focus{outline:dotted 2px;outline-offset:-2px}.mat-tab-link.mat-tab-disabled{cursor:default}.cdk-high-contrast-active .mat-tab-link.mat-tab-disabled{opacity:.5}.mat-tab-link .mat-tab-label-content{display:inline-flex;justify-content:center;align-items:center;white-space:nowrap}.cdk-high-contrast-active .mat-tab-link{opacity:1}[mat-stretch-tabs] .mat-tab-link{flex-basis:0;flex-grow:1}.mat-tab-link.mat-tab-disabled{pointer-events:none}@media(max-width: 599px){.mat-tab-link{min-width:72px}}\\n\"], encapsulation: 2 });\n    return MatTabNav;\n})();\n// Boilerplate for applying mixins to MatTabLink.\nclass MatTabLinkMixinBase {\n}\nconst _MatTabLinkMixinBase = /*@__PURE__*/ mixinTabIndex(/*@__PURE__*/ mixinDisableRipple(/*@__PURE__*/ mixinDisabled(MatTabLinkMixinBase)));\nlet tabs_MatTabLinkBase = /*@__PURE__*/ (() => {\n    class _MatTabLinkBase extends _MatTabLinkMixinBase {\n        constructor(_tabNavBar, \n        /** @docs-private */ elementRef, globalRippleOptions, tabIndex, _focusMonitor, animationMode) {\n            super();\n            this._tabNavBar = _tabNavBar;\n            this.elementRef = elementRef;\n            this._focusMonitor = _focusMonitor;\n            /** Whether the tab link is active or not. */\n            this._isActive = false;\n            this.rippleConfig = globalRippleOptions || {};\n            this.tabIndex = parseInt(tabIndex) || 0;\n            if (animationMode === 'NoopAnimations') {\n                this.rippleConfig.animation = { enterDuration: 0, exitDuration: 0 };\n            }\n        }\n        /** Whether the link is active. */\n        get active() { return this._isActive; }\n        set active(value) {\n            const newValue = coerceBooleanProperty(value);\n            if (newValue !== this._isActive) {\n                this._isActive = value;\n                this._tabNavBar.updateActiveLink();\n            }\n        }\n        /**\n         * Whether ripples are disabled on interaction.\n         * @docs-private\n         */\n        get rippleDisabled() {\n            return this.disabled || this.disableRipple || this._tabNavBar.disableRipple ||\n                !!this.rippleConfig.disabled;\n        }\n        /** Focuses the tab link. */\n        focus() {\n            this.elementRef.nativeElement.focus();\n        }\n        ngAfterViewInit() {\n            this._focusMonitor.monitor(this.elementRef);\n        }\n        ngOnDestroy() {\n            this._focusMonitor.stopMonitoring(this.elementRef);\n        }\n    }\n    _MatTabLinkBase.fac = function _MatTabLinkBase_Factory(t) { return new (t || _MatTabLinkBase)(core[\"Mb\" /* directiveInject */](tabs_MatTabNavBase), core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](MAT_RIPPLE_GLOBAL_OPTIONS, 8), core[\"Xb\" /* injectAttribute */]('tabindex'), core[\"Mb\" /* directiveInject */](a11y_FocusMonitor), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    _MatTabLinkBase.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: _MatTabLinkBase, inputs: { active: \"active\" }, features: [core[\"xb\" /* InheritDefinitionFeature */]] });\n    return _MatTabLinkBase;\n})();\nlet tabs_MatTabLink = /*@__PURE__*/ (() => {\n    class MatTabLink extends tabs_MatTabLinkBase {\n        constructor(tabNavBar, elementRef, ngZone, platform, globalRippleOptions, tabIndex, focusMonitor, animationMode) {\n            super(tabNavBar, elementRef, globalRippleOptions, tabIndex, focusMonitor, animationMode);\n            this._tabLinkRipple = new core_RippleRenderer(this, ngZone, elementRef, platform);\n            this._tabLinkRipple.setupTriggerEvents(elementRef.nativeElement);\n        }\n        ngOnDestroy() {\n            super.ngOnDestroy();\n            this._tabLinkRipple._removeTriggerEvents();\n        }\n    }\n    MatTabLink.fac = function MatTabLink_Factory(t) { return new (t || MatTabLink)(core[\"Mb\" /* directiveInject */](tabs_MatTabNav), core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](platform_Platform), core[\"Mb\" /* directiveInject */](MAT_RIPPLE_GLOBAL_OPTIONS, 8), core[\"Xb\" /* injectAttribute */]('tabindex'), core[\"Mb\" /* directiveInject */](a11y_FocusMonitor), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatTabLink.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatTabLink, selectors: [[\"\", \"mat-tab-link\", \"\"], [\"\", \"matTabLink\", \"\"]], hostAttrs: [1, \"mat-tab-link\", \"mat-focus-indicator\"], hostVars: 7, hostBindings: function MatTabLink_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Bb\" /* attribute */](\"aria-current\", ctx.active ? \"page\" : null)(\"aria-disabled\", ctx.disabled)(\"tabIndex\", ctx.tabIndex);\n                core[\"Eb\" /* classProp */](\"mat-tab-disabled\", ctx.disabled)(\"mat-tab-label-active\", ctx.active);\n            }\n        }, inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", tabIndex: \"tabIndex\" }, exportAs: [\"matTabLink\"], features: [core[\"xb\" /* InheritDefinitionFeature */]] });\n    return MatTabLink;\n})();\nlet tabs_MatTabsModule = /*@__PURE__*/ (() => {\n    class MatTabsModule {\n    }\n    MatTabsModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: MatTabsModule });\n    MatTabsModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function MatTabsModule_Factory(t) { return new (t || MatTabsModule)(); }, imports: [[\n                common[\"b\" /* CommonModule */],\n                core_MatCommonModule,\n                portal_PortalModule,\n                core_MatRippleModule,\n                observers_ObserversModule,\n                a11y_A11yModule,\n            ], core_MatCommonModule] });\n    return MatTabsModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](tabs_MatTabsModule, { declarations: function () { return [tabs_MatTabGroup, tabs_MatTabLabel, tabs_MatTab, tabs_MatInkBar, tabs_MatTabLabelWrapper, tabs_MatTabNav, tabs_MatTabLink, tabs_MatTabBody, tabs_MatTabBodyPortal, tabs_MatTabHeader, tabs_MatTabContent]; }, imports: function () {\n            return [common[\"b\" /* CommonModule */],\n                core_MatCommonModule,\n                portal_PortalModule,\n                core_MatRippleModule,\n                observers_ObserversModule,\n                a11y_A11yModule];\n        }, exports: function () { return [core_MatCommonModule, tabs_MatTabGroup, tabs_MatTabLabel, tabs_MatTab, tabs_MatTabNav, tabs_MatTabLink, tabs_MatTabContent]; } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=tabs.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/button.js\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Default color palette for round buttons (mat-fab and mat-mini-fab) */\n\n\n\nconst button_c0 = [\"mat-button\", \"\"];\nconst button_c1 = [\"*\"];\nconst button_c2 = \".mat-button .mat-button-focus-overlay,.mat-icon-button .mat-button-focus-overlay{opacity:0}.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:.04}@media(hover: none){.mat-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay,.mat-stroked-button:hover:not(.mat-button-disabled) .mat-button-focus-overlay{opacity:0}}.mat-button,.mat-icon-button,.mat-stroked-button,.mat-flat-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-button.mat-button-disabled,.mat-icon-button.mat-button-disabled,.mat-stroked-button.mat-button-disabled,.mat-flat-button.mat-button-disabled{cursor:default}.mat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-button.cdk-program-focused .mat-button-focus-overlay,.mat-icon-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-icon-button.cdk-program-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-stroked-button.cdk-program-focused .mat-button-focus-overlay,.mat-flat-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-flat-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-button::-moz-focus-inner,.mat-icon-button::-moz-focus-inner,.mat-stroked-button::-moz-focus-inner,.mat-flat-button::-moz-focus-inner{border:0}.mat-raised-button{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-raised-button::-moz-focus-inner{border:0}.mat-raised-button.mat-button-disabled{cursor:default}.mat-raised-button.cdk-keyboard-focused .mat-button-focus-overlay,.mat-raised-button.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-raised-button::-moz-focus-inner{border:0}._mat-animation-noopable.mat-raised-button{transition:none;animation:none}.mat-stroked-button{border:1px solid currentColor;padding:0 15px;line-height:34px}.mat-stroked-button .mat-button-ripple.mat-ripple,.mat-stroked-button .mat-button-focus-overlay{top:-1px;left:-1px;right:-1px;bottom:-1px}.mat-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:56px;height:56px;padding:0;flex-shrink:0}.mat-fab::-moz-focus-inner{border:0}.mat-fab.mat-button-disabled{cursor:default}.mat-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-fab{transition:none;animation:none}.mat-fab .mat-button-wrapper{padding:16px 0;display:inline-block;line-height:24px}.mat-mini-fab{box-sizing:border-box;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;display:inline-block;white-space:nowrap;text-decoration:none;vertical-align:baseline;text-align:center;margin:0;min-width:64px;line-height:36px;padding:0 16px;border-radius:4px;overflow:visible;transform:translate3d(0, 0, 0);transition:background 400ms cubic-bezier(0.25, 0.8, 0.25, 1),box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);min-width:0;border-radius:50%;width:40px;height:40px;padding:0;flex-shrink:0}.mat-mini-fab::-moz-focus-inner{border:0}.mat-mini-fab.mat-button-disabled{cursor:default}.mat-mini-fab.cdk-keyboard-focused .mat-button-focus-overlay,.mat-mini-fab.cdk-program-focused .mat-button-focus-overlay{opacity:.12}.mat-mini-fab::-moz-focus-inner{border:0}._mat-animation-noopable.mat-mini-fab{transition:none;animation:none}.mat-mini-fab .mat-button-wrapper{padding:8px 0;display:inline-block;line-height:24px}.mat-icon-button{padding:0;min-width:0;width:40px;height:40px;flex-shrink:0;line-height:40px;border-radius:50%}.mat-icon-button i,.mat-icon-button .mat-icon{line-height:24px}.mat-button-ripple.mat-ripple,.mat-button-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-button-ripple.mat-ripple:not(:empty){transform:translateZ(0)}.mat-button-focus-overlay{opacity:0;transition:opacity 200ms cubic-bezier(0.35, 0, 0.25, 1),background-color 200ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-button-focus-overlay{transition:none}.mat-button-ripple-round{border-radius:50%;z-index:1}.mat-button .mat-button-wrapper>*,.mat-flat-button .mat-button-wrapper>*,.mat-stroked-button .mat-button-wrapper>*,.mat-raised-button .mat-button-wrapper>*,.mat-icon-button .mat-button-wrapper>*,.mat-fab .mat-button-wrapper>*,.mat-mini-fab .mat-button-wrapper>*{vertical-align:middle}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button{display:inline-flex;justify-content:center;align-items:center;font-size:inherit;width:2.5em;height:2.5em}.cdk-high-contrast-active .mat-button,.cdk-high-contrast-active .mat-flat-button,.cdk-high-contrast-active .mat-raised-button,.cdk-high-contrast-active .mat-icon-button,.cdk-high-contrast-active .mat-fab,.cdk-high-contrast-active .mat-mini-fab{outline:solid 1px}.cdk-high-contrast-active .mat-button-base.cdk-keyboard-focused,.cdk-high-contrast-active .mat-button-base.cdk-program-focused{outline:solid 3px}\\n\";\nconst DEFAULT_ROUND_BUTTON_COLOR = 'accent';\n/**\n * List of classes to add to MatButton instances based on host attributes to\n * style as different variants.\n */\nconst BUTTON_HOST_ATTRIBUTES = [\n    'mat-button',\n    'mat-flat-button',\n    'mat-icon-button',\n    'mat-raised-button',\n    'mat-stroked-button',\n    'mat-mini-fab',\n    'mat-fab',\n];\n// Boilerplate for applying mixins to MatButton.\n/** @docs-private */\nclass MatButtonBase {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\nconst _MatButtonMixinBase = /*@__PURE__*/ mixinColor(/*@__PURE__*/ mixinDisabled(/*@__PURE__*/ mixinDisableRipple(MatButtonBase)));\nlet button_MatButton = /*@__PURE__*/ (() => {\n    class MatButton extends _MatButtonMixinBase {\n        constructor(elementRef, _focusMonitor, _animationMode) {\n            super(elementRef);\n            this._focusMonitor = _focusMonitor;\n            this._animationMode = _animationMode;\n            /** Whether the button is round. */\n            this.isRoundButton = this._hasHostAttributes('mat-fab', 'mat-mini-fab');\n            /** Whether the button is icon button. */\n            this.isIconButton = this._hasHostAttributes('mat-icon-button');\n            // For each of the variant selectors that is present in the button's host\n            // attributes, add the correct corresponding class.\n            for (const attr of BUTTON_HOST_ATTRIBUTES) {\n                if (this._hasHostAttributes(attr)) {\n                    this._getHostElement().classList.add(attr);\n                }\n            }\n            // Add a class that applies to all buttons. This makes it easier to target if somebody\n            // wants to target all Material buttons. We do it here rather than `host` to ensure that\n            // the class is applied to derived classes.\n            elementRef.nativeElement.classList.add('mat-button-base');\n            if (this.isRoundButton) {\n                this.color = DEFAULT_ROUND_BUTTON_COLOR;\n            }\n        }\n        ngAfterViewInit() {\n            this._focusMonitor.monitor(this._elementRef, true);\n        }\n        ngOnDestroy() {\n            this._focusMonitor.stopMonitoring(this._elementRef);\n        }\n        /** Focuses the button. */\n        focus(origin, options) {\n            if (origin) {\n                this._focusMonitor.focusVia(this._getHostElement(), origin, options);\n            }\n            else {\n                this._getHostElement().focus(options);\n            }\n        }\n        _getHostElement() {\n            return this._elementRef.nativeElement;\n        }\n        _isRippleDisabled() {\n            return this.disableRipple || this.disabled;\n        }\n        /** Gets whether the button has one of the given attributes. */\n        _hasHostAttributes(...attributes) {\n            return attributes.some(attribute => this._getHostElement().hasAttribute(attribute));\n        }\n    }\n    MatButton.fac = function MatButton_Factory(t) { return new (t || MatButton)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](a11y_FocusMonitor), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatButton.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatButton, selectors: [[\"button\", \"mat-button\", \"\"], [\"button\", \"mat-raised-button\", \"\"], [\"button\", \"mat-icon-button\", \"\"], [\"button\", \"mat-fab\", \"\"], [\"button\", \"mat-mini-fab\", \"\"], [\"button\", \"mat-stroked-button\", \"\"], [\"button\", \"mat-flat-button\", \"\"]], viewQuery: function MatButton_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"xc\" /* viewQuery */](core_MatRipple, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.ripple = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-focus-indicator\"], hostVars: 5, hostBindings: function MatButton_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Bb\" /* attribute */](\"disabled\", ctx.disabled || null);\n                core[\"Eb\" /* classProp */](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\")(\"mat-button-disabled\", ctx.disabled);\n            }\n        }, inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", color: \"color\" }, exportAs: [\"matButton\"], features: [core[\"xb\" /* InheritDefinitionFeature */]], attrs: button_c0, ngContentSelectors: button_c1, decls: 4, vars: 5, consts: [[1, \"mat-button-wrapper\"], [\"matRipple\", \"\", 1, \"mat-button-ripple\", 3, \"matRippleDisabled\", \"matRippleCentered\", \"matRippleTrigger\"], [1, \"mat-button-focus-overlay\"]], template: function MatButton_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"dc\" /* projectionDef */]();\n                core[\"Sb\" /* elementStart */](0, \"span\", 0);\n                core[\"cc\" /* projection */](1);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Nb\" /* element */](2, \"span\", 1);\n                core[\"Nb\" /* element */](3, \"span\", 2);\n            }\n            if (rf & 2) {\n                core[\"Ab\" /* advance */](2);\n                core[\"Eb\" /* classProp */](\"mat-button-ripple-round\", ctx.isRoundButton || ctx.isIconButton);\n                core[\"ec\" /* property */](\"matRippleDisabled\", ctx._isRippleDisabled())(\"matRippleCentered\", ctx.isIconButton)(\"matRippleTrigger\", ctx._getHostElement());\n            }\n        }, directives: [core_MatRipple], styles: [button_c2], encapsulation: 2, changeDetection: 0 });\n    return MatButton;\n})();\nlet button_MatAnchor = /*@__PURE__*/ (() => {\n    class MatAnchor extends button_MatButton {\n        constructor(focusMonitor, elementRef, animationMode) {\n            super(elementRef, focusMonitor, animationMode);\n        }\n        _haltDisabledEvents(event) {\n            // A disabled button shouldn't apply any actions\n            if (this.disabled) {\n                event.preventDefault();\n                event.stopImmediatePropagation();\n            }\n        }\n    }\n    MatAnchor.fac = function MatAnchor_Factory(t) { return new (t || MatAnchor)(core[\"Mb\" /* directiveInject */](a11y_FocusMonitor), core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatAnchor.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatAnchor, selectors: [[\"a\", \"mat-button\", \"\"], [\"a\", \"mat-raised-button\", \"\"], [\"a\", \"mat-icon-button\", \"\"], [\"a\", \"mat-fab\", \"\"], [\"a\", \"mat-mini-fab\", \"\"], [\"a\", \"mat-stroked-button\", \"\"], [\"a\", \"mat-flat-button\", \"\"]], hostAttrs: [1, \"mat-focus-indicator\"], hostVars: 7, hostBindings: function MatAnchor_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                core[\"Zb\" /* listener */](\"click\", function MatAnchor_click_HostBindingHandler($event) { return ctx._haltDisabledEvents($event); });\n            }\n            if (rf & 2) {\n                core[\"Bb\" /* attribute */](\"tabindex\", ctx.disabled ? -1 : ctx.tabIndex || 0)(\"disabled\", ctx.disabled || null)(\"aria-disabled\", ctx.disabled.toString());\n                core[\"Eb\" /* classProp */](\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\")(\"mat-button-disabled\", ctx.disabled);\n            }\n        }, inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", color: \"color\", tabIndex: \"tabIndex\" }, exportAs: [\"matButton\", \"matAnchor\"], features: [core[\"xb\" /* InheritDefinitionFeature */]], attrs: button_c0, ngContentSelectors: button_c1, decls: 4, vars: 5, consts: [[1, \"mat-button-wrapper\"], [\"matRipple\", \"\", 1, \"mat-button-ripple\", 3, \"matRippleDisabled\", \"matRippleCentered\", \"matRippleTrigger\"], [1, \"mat-button-focus-overlay\"]], template: function MatAnchor_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"dc\" /* projectionDef */]();\n                core[\"Sb\" /* elementStart */](0, \"span\", 0);\n                core[\"cc\" /* projection */](1);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Nb\" /* element */](2, \"span\", 1);\n                core[\"Nb\" /* element */](3, \"span\", 2);\n            }\n            if (rf & 2) {\n                core[\"Ab\" /* advance */](2);\n                core[\"Eb\" /* classProp */](\"mat-button-ripple-round\", ctx.isRoundButton || ctx.isIconButton);\n                core[\"ec\" /* property */](\"matRippleDisabled\", ctx._isRippleDisabled())(\"matRippleCentered\", ctx.isIconButton)(\"matRippleTrigger\", ctx._getHostElement());\n            }\n        }, directives: [core_MatRipple], styles: [button_c2], encapsulation: 2, changeDetection: 0 });\n    return MatAnchor;\n})();\nlet button_MatButtonModule = /*@__PURE__*/ (() => {\n    class MatButtonModule {\n    }\n    MatButtonModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: MatButtonModule });\n    MatButtonModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function MatButtonModule_Factory(t) { return new (t || MatButtonModule)(); }, imports: [[\n                core_MatRippleModule,\n                core_MatCommonModule,\n            ], core_MatCommonModule] });\n    return MatButtonModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](button_MatButtonModule, { declarations: function () { return [button_MatButton, button_MatAnchor]; }, imports: function () {\n            return [core_MatRippleModule,\n                core_MatCommonModule];\n        }, exports: function () { return [button_MatButton, button_MatAnchor, core_MatCommonModule]; } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=button.js.map\n\n// CONCATENATED MODULE: ./src/app/modules/auth/login/login.component.ts\n\r\n\r\n\r\n\r\n\r\nfunction LoginComponent_div_16_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r4 = core[\"Tb\" /* getCurrentView */]();\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"Nb\" /* element */](1, \"input\", 6);\r\n        core[\"Sb\" /* elementStart */](2, \"div\", 7);\r\n        core[\"uc\" /* text */](3, \" Forgot Password? \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](4, \"div\", 15);\r\n        core[\"Sb\" /* elementStart */](5, \"button\", 16);\r\n        core[\"Zb\" /* listener */](\"click\", function LoginComponent_div_16_Template_button_click_5_listener() { core[\"mc\" /* restoreView */](_r4); const ctx_r3 = core[\"bc\" /* nextContext */](); return ctx_r3.sendOTPStatus = true; });\r\n        core[\"uc\" /* text */](6, \" Send OTP \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction LoginComponent_ng_template_17_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r6 = core[\"Tb\" /* getCurrentView */]();\r\n        core[\"Sb\" /* elementStart */](0, \"h3\", 17);\r\n        core[\"uc\" /* text */](1, \"Verify OTP\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Nb\" /* element */](2, \"input\", 18);\r\n        core[\"Sb\" /* elementStart */](3, \"div\", 15);\r\n        core[\"Sb\" /* elementStart */](4, \"button\", 16);\r\n        core[\"Zb\" /* listener */](\"click\", function LoginComponent_ng_template_17_Template_button_click_4_listener() { core[\"mc\" /* restoreView */](_r6); const ctx_r5 = core[\"bc\" /* nextContext */](); return ctx_r5.sendOTPStatus = false; });\r\n        core[\"uc\" /* text */](5, \" Verify OTP \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nlet login_component_LoginComponent = /*@__PURE__*/ (() => {\r\n    class LoginComponent {\r\n        constructor() {\r\n            this.sendOTPStatus = false;\r\n        }\r\n        ngOnInit() {\r\n        }\r\n    }\r\n    LoginComponent.fac = function LoginComponent_Factory(t) { return new (t || LoginComponent)(); };\r\n    LoginComponent.cmp = core[\"Gb\" /* defineComponent */]({ type: LoginComponent, selectors: [[\"app-login\"]], decls: 23, vars: 2, consts: [[1, \"_containerWidth\"], [1, \"_m0\", \"_fw700\"], [1, \"_m0\", \"_loginWithColor\"], [\"mat-align-tabs\", \"start\"], [\"label\", \"Email\"], [\"placeholder\", \"Email\", \"type\", \"text\", 1, \"_inputBox\", \"_mt\"], [\"placeholder\", \"Mobile Number\", \"type\", \"tel\", 1, \"_inputBox\", \"_mt\"], [\"routerLink\", \"/forgot-password\", 1, \"_textEnd\", \"_mt\", \"_cursorPointer\"], [1, \"_textCen\", \"_mt\"], [\"mat-button\", \"\", 1, \"button\", \"_width100\"], [\"label\", \"Mobile\"], [4, \"ngIf\", \"ngIfElse\"], [\"verifyTemplate\", \"\"], [1, \"_textStart\", \"_mt\"], [\"routerLink\", \"/registration\", 1, \"_cursorPointer\", \"_primaryTextColor\"], [1, \"_mt\", \"_textCen\"], [\"mat-button\", \"\", 1, \"button\", \"_width100\", 3, \"click\"], [1, \"_mt\", \"_forgotTextColor\"], [\"placeholder\", \"OTP\", 1, \"_inputBox\", \"_mt\"]], template: function LoginComponent_Template(rf, ctx) {\r\n            if (rf & 1) {\r\n                core[\"Sb\" /* elementStart */](0, \"div\");\r\n                core[\"Sb\" /* elementStart */](1, \"div\", 0);\r\n                core[\"Sb\" /* elementStart */](2, \"h1\", 1);\r\n                core[\"uc\" /* text */](3, \"ConvoBot360\");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Sb\" /* elementStart */](4, \"h3\", 2);\r\n                core[\"uc\" /* text */](5, \"Login with\");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Sb\" /* elementStart */](6, \"mat-tab-group\", 3);\r\n                core[\"Sb\" /* elementStart */](7, \"mat-tab\", 4);\r\n                core[\"Nb\" /* element */](8, \"input\", 5);\r\n                core[\"Nb\" /* element */](9, \"input\", 6);\r\n                core[\"Sb\" /* elementStart */](10, \"div\", 7);\r\n                core[\"uc\" /* text */](11, \" Forgot Password? \");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Sb\" /* elementStart */](12, \"div\", 8);\r\n                core[\"Sb\" /* elementStart */](13, \"button\", 9);\r\n                core[\"uc\" /* text */](14, \"Sign in\");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Sb\" /* elementStart */](15, \"mat-tab\", 10);\r\n                core[\"sc\" /* template */](16, LoginComponent_div_16_Template, 7, 0, \"div\", 11);\r\n                core[\"sc\" /* template */](17, LoginComponent_ng_template_17_Template, 6, 0, \"ng-template\", null, 12, core[\"tc\" /* templateRefExtractor */]);\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Sb\" /* elementStart */](19, \"div\", 13);\r\n                core[\"uc\" /* text */](20, \" Don't have an account yet?\");\r\n                core[\"Sb\" /* elementStart */](21, \"span\", 14);\r\n                core[\"uc\" /* text */](22, \"\\u00A0Sign up\");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n            }\r\n            if (rf & 2) {\r\n                const _r1 = core[\"lc\" /* reference */](18);\r\n                core[\"Ab\" /* advance */](16);\r\n                core[\"ec\" /* property */](\"ngIf\", !ctx.sendOTPStatus)(\"ngIfElse\", _r1);\r\n            }\r\n        }, directives: [tabs_MatTabGroup, tabs_MatTab, router[\"a\" /* RouterLink */], button_MatButton, common[\"j\" /* NgIf */]], styles: [\"._loginWithColor[_ngcontent-%COMP%]{color:#454545}\"] });\r\n    return LoginComponent;\r\n})();\r\n\n// EXTERNAL MODULE: ./node_modules/@angular/forms/__ivy_ngcc__/fesm2015/forms.js + 1 modules\nvar fesm2015_forms = __webpack_require__(\"3Pt+\");\n\n// CONCATENATED MODULE: ./src/app/modules/auth/confirm-password-validator/confirmPassword.ts\n// custom validator to check that two fields match\nfunction MustMatch(controlName, matchingControlName) {\n    return (formGroup) => {\n        const control = formGroup.controls[controlName];\n        const matchingControl = formGroup.controls[matchingControlName];\n        if (matchingControl.errors && !matchingControl.errors.mustMatch) {\n            // return if another validator has already found an error on the matchingControl\n            return;\n        }\n        // set error on matchingControl if validation fails\n        if (control.value !== matchingControl.value) {\n            matchingControl.setErrors({ mustMatch: true });\n        }\n        else {\n            matchingControl.setErrors(null);\n        }\n    };\n}\n\n// CONCATENATED MODULE: ./src/app/modules/auth/forgot-password/forgot-password.component.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction ForgotPasswordComponent_div_5_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r4 = core[\"Tb\" /* getCurrentView */]();\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"Sb\" /* elementStart */](1, \"h3\", 6);\r\n        core[\"uc\" /* text */](2, \"Forgot Password\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](3, \"label\", 7);\r\n        core[\"uc\" /* text */](4, \"Email\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Nb\" /* element */](5, \"input\", 8);\r\n        core[\"Sb\" /* elementStart */](6, \"span\", 9);\r\n        core[\"uc\" /* text */](7, \"Requires your primary email ID.\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](8, \"div\", 10);\r\n        core[\"Sb\" /* elementStart */](9, \"button\", 11);\r\n        core[\"Zb\" /* listener */](\"click\", function ForgotPasswordComponent_div_5_Template_button_click_9_listener() { core[\"mc\" /* restoreView */](_r4); const ctx_r3 = core[\"bc\" /* nextContext */](); return ctx_r3.forgotPasswordStageStatus = \"otpVerification\"; });\r\n        core[\"uc\" /* text */](10, \" Send OTP \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction ForgotPasswordComponent_div_6_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r6 = core[\"Tb\" /* getCurrentView */]();\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"Sb\" /* elementStart */](1, \"h3\", 6);\r\n        core[\"uc\" /* text */](2, \"Verify OTP\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Nb\" /* element */](3, \"input\", 12);\r\n        core[\"Sb\" /* elementStart */](4, \"div\", 10);\r\n        core[\"Sb\" /* elementStart */](5, \"button\", 11);\r\n        core[\"Zb\" /* listener */](\"click\", function ForgotPasswordComponent_div_6_Template_button_click_5_listener() { core[\"mc\" /* restoreView */](_r6); const ctx_r5 = core[\"bc\" /* nextContext */](); return ctx_r5.forgotPasswordStageStatus = \"setNewPassword\"; });\r\n        core[\"uc\" /* text */](6, \" Verify OTP \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction ForgotPasswordComponent_div_7_div_8_div_1_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \"Password is required\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction ForgotPasswordComponent_div_7_div_8_div_2_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Password must be at least 6 characters \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction ForgotPasswordComponent_div_7_div_8_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\", 17);\r\n        core[\"sc\" /* template */](1, ForgotPasswordComponent_div_7_div_8_div_1_Template, 2, 0, \"div\", 18);\r\n        core[\"sc\" /* template */](2, ForgotPasswordComponent_div_7_div_8_div_2_Template, 2, 0, \"div\", 18);\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r7 = core[\"bc\" /* nextContext */](2);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r7.f.password.errors.required);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r7.f.password.errors.minlength);\r\n    }\r\n}\r\nfunction ForgotPasswordComponent_div_7_div_13_div_1_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Confirm Password is required \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction ForgotPasswordComponent_div_7_div_13_div_2_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Passwords must match \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction ForgotPasswordComponent_div_7_div_13_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\", 17);\r\n        core[\"sc\" /* template */](1, ForgotPasswordComponent_div_7_div_13_div_1_Template, 2, 0, \"div\", 18);\r\n        core[\"sc\" /* template */](2, ForgotPasswordComponent_div_7_div_13_div_2_Template, 2, 0, \"div\", 18);\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r8 = core[\"bc\" /* nextContext */](2);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r8.f.confirmPassword.errors.required);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r8.f.confirmPassword.errors.mustMatch);\r\n    }\r\n}\r\nfunction ForgotPasswordComponent_div_7_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r14 = core[\"Tb\" /* getCurrentView */]();\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"Sb\" /* elementStart */](1, \"form\", 13);\r\n        core[\"Sb\" /* elementStart */](2, \"h3\", 6);\r\n        core[\"uc\" /* text */](3, \"Set New Password\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](4, \"div\");\r\n        core[\"Sb\" /* elementStart */](5, \"label\", 7);\r\n        core[\"uc\" /* text */](6, \"Password\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Nb\" /* element */](7, \"input\", 14);\r\n        core[\"sc\" /* template */](8, ForgotPasswordComponent_div_7_div_8_Template, 3, 2, \"div\", 15);\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](9, \"div\");\r\n        core[\"Sb\" /* elementStart */](10, \"label\", 7);\r\n        core[\"uc\" /* text */](11, \"Confirm Password\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Nb\" /* element */](12, \"input\", 16);\r\n        core[\"sc\" /* template */](13, ForgotPasswordComponent_div_7_div_13_Template, 3, 2, \"div\", 15);\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](14, \"div\", 10);\r\n        core[\"Sb\" /* elementStart */](15, \"button\", 11);\r\n        core[\"Zb\" /* listener */](\"click\", function ForgotPasswordComponent_div_7_Template_button_click_15_listener() { core[\"mc\" /* restoreView */](_r14); const ctx_r13 = core[\"bc\" /* nextContext */](); return ctx_r13.setNewPasswordFunction(); });\r\n        core[\"uc\" /* text */](16, \" Set New Password \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r2 = core[\"bc\" /* nextContext */]();\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"formGroup\", ctx_r2.newPasswordForm);\r\n        core[\"Ab\" /* advance */](7);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r2.passwordSubmitted && ctx_r2.f.password.errors);\r\n        core[\"Ab\" /* advance */](5);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r2.passwordSubmitted && ctx_r2.f.confirmPassword.errors);\r\n    }\r\n}\r\nlet forgot_password_component_ForgotPasswordComponent = /*@__PURE__*/ (() => {\r\n    class ForgotPasswordComponent {\r\n        constructor(formBuilder) {\r\n            this.formBuilder = formBuilder;\r\n            this.sendOTPStatus = false;\r\n            this.forgotPasswordStageStatus = 'emailVerification';\r\n            this.passwordSubmitted = false;\r\n        }\r\n        ngOnInit() {\r\n            this.newPasswordForm = this.formBuilder.group({\r\n                password: ['', [fesm2015_forms[\"k\" /* Validators */].required, fesm2015_forms[\"k\" /* Validators */].minLength(6)]],\r\n                confirmPassword: ['', fesm2015_forms[\"k\" /* Validators */].required],\r\n            }, {\r\n                validator: MustMatch('password', 'confirmPassword'),\r\n            });\r\n        }\r\n        // convenience getter for easy access to form fields\r\n        get f() {\r\n            var _a;\r\n            return (_a = this.newPasswordForm) === null || _a === void 0 ? void 0 : _a.controls;\r\n        }\r\n        setNewPasswordFunction() {\r\n            this.passwordSubmitted = true;\r\n        }\r\n    }\r\n    ForgotPasswordComponent.fac = function ForgotPasswordComponent_Factory(t) { return new (t || ForgotPasswordComponent)(core[\"Mb\" /* directiveInject */](fesm2015_forms[\"b\" /* FormBuilder */])); };\r\n    ForgotPasswordComponent.cmp = core[\"Gb\" /* defineComponent */]({ type: ForgotPasswordComponent, selectors: [[\"app-forgot-password\"]], decls: 12, vars: 4, consts: [[1, \"_containerWidth\"], [1, \"_m0\", \"_fw700\"], [3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [1, \"_textStart\", \"_mt\"], [\"routerLink\", \"/login\", 1, \"_cursorPointer\", \"_primaryTextColor\"], [1, \"_m0\", \"_forgotTextColor\"], [1, \"_mt\", \"_inputLabel\"], [\"placeholder\", \"Email\", 1, \"_inputBox\"], [1, \"_textMuted\"], [1, \"_mt\", \"_textCen\"], [\"mat-button\", \"\", 1, \"button\", \"_width100\", 3, \"click\"], [\"placeholder\", \"OTP\", 1, \"_inputBox\", \"_mt\"], [3, \"formGroup\"], [\"placeholder\", \"Password\", \"formControlName\", \"password\", \"type\", \"password\", 1, \"_inputBox\"], [\"class\", \"_alertTextColor\", 4, \"ngIf\"], [\"placeholder\", \"Confirm Password\", \"formControlName\", \"confirmPassword\", \"type\", \"password\", 1, \"_inputBox\"], [1, \"_alertTextColor\"], [4, \"ngIf\"]], template: function ForgotPasswordComponent_Template(rf, ctx) {\r\n            if (rf & 1) {\r\n                core[\"Sb\" /* elementStart */](0, \"div\");\r\n                core[\"Sb\" /* elementStart */](1, \"div\", 0);\r\n                core[\"Sb\" /* elementStart */](2, \"h1\", 1);\r\n                core[\"uc\" /* text */](3, \"ConvoBot360\");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Sb\" /* elementStart */](4, \"div\", 2);\r\n                core[\"sc\" /* template */](5, ForgotPasswordComponent_div_5_Template, 11, 0, \"div\", 3);\r\n                core[\"sc\" /* template */](6, ForgotPasswordComponent_div_6_Template, 7, 0, \"div\", 3);\r\n                core[\"sc\" /* template */](7, ForgotPasswordComponent_div_7_Template, 17, 3, \"div\", 3);\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Sb\" /* elementStart */](8, \"div\", 4);\r\n                core[\"uc\" /* text */](9, \" Already have login and password?\");\r\n                core[\"Sb\" /* elementStart */](10, \"span\", 5);\r\n                core[\"uc\" /* text */](11, \"\\u00A0Sign in\");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n            }\r\n            if (rf & 2) {\r\n                core[\"Ab\" /* advance */](4);\r\n                core[\"ec\" /* property */](\"ngSwitch\", ctx.forgotPasswordStageStatus);\r\n                core[\"Ab\" /* advance */](1);\r\n                core[\"ec\" /* property */](\"ngSwitchCase\", \"emailVerification\");\r\n                core[\"Ab\" /* advance */](1);\r\n                core[\"ec\" /* property */](\"ngSwitchCase\", \"otpVerification\");\r\n                core[\"Ab\" /* advance */](1);\r\n                core[\"ec\" /* property */](\"ngSwitchCase\", \"setNewPassword\");\r\n            }\r\n        }, directives: [common[\"l\" /* NgSwitch */], common[\"m\" /* NgSwitchCase */], router[\"a\" /* RouterLink */], button_MatButton, fesm2015_forms[\"l\" /* angular_packages_forms_forms_y */], fesm2015_forms[\"h\" /* NgControlStatusGroup */], fesm2015_forms[\"d\" /* FormGroupDirective */], fesm2015_forms[\"a\" /* DefaultValueAccessor */], fesm2015_forms[\"g\" /* NgControlStatus */], fesm2015_forms[\"c\" /* FormControlName */], common[\"j\" /* NgIf */]], styles: [\"._forgotTextColor[_ngcontent-%COMP%]{color:#454545}\"] });\r\n    return ForgotPasswordComponent;\r\n})();\r\n\n// CONCATENATED MODULE: ./src/assets/end-points/end-points.ts\nclass endPoints {\n    constructor() {\n        this.serverEndPoint = {\n            login: 'asdfasdfasd',\n        };\n    }\n}\n\n// EXTERNAL MODULE: ./src/app/app.component.ts\nvar app_component = __webpack_require__(\"Sy1n\");\n\n// CONCATENATED MODULE: ./node_modules/rxjs/_esm2015/internal/operators/takeWhile.js\n\nfunction takeWhile(predicate, inclusive = false) {\n    return (source) => source.lift(new TakeWhileOperator(predicate, inclusive));\n}\nclass TakeWhileOperator {\n    constructor(predicate, inclusive) {\n        this.predicate = predicate;\n        this.inclusive = inclusive;\n    }\n    call(subscriber, source) {\n        return source.subscribe(new takeWhile_TakeWhileSubscriber(subscriber, this.predicate, this.inclusive));\n    }\n}\nclass takeWhile_TakeWhileSubscriber extends Subscriber[\"a\" /* Subscriber */] {\n    constructor(destination, predicate, inclusive) {\n        super(destination);\n        this.predicate = predicate;\n        this.inclusive = inclusive;\n        this.index = 0;\n    }\n    _next(value) {\n        const destination = this.destination;\n        let result;\n        try {\n            result = this.predicate(value, this.index++);\n        }\n        catch (err) {\n            destination.error(err);\n            return;\n        }\n        this.nextOrComplete(value, result);\n    }\n    nextOrComplete(value, predicateResult) {\n        const destination = this.destination;\n        if (Boolean(predicateResult)) {\n            destination.next(value);\n        }\n        else {\n            if (this.inclusive) {\n                destination.next(value);\n            }\n            destination.complete();\n        }\n    }\n}\n//# sourceMappingURL=takeWhile.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/cdk/__ivy_ngcc__/fesm2015/overlay.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst overlay_scrollBehaviorSupported = /*@__PURE__*/ supportsScrollBehavior();\n/**\n * Strategy that will prevent the user from scrolling while the overlay is visible.\n */\nclass overlay_BlockScrollStrategy {\n    constructor(_viewportRuler, document) {\n        this._viewportRuler = _viewportRuler;\n        this._previousHTMLStyles = { top: '', left: '' };\n        this._isEnabled = false;\n        this._document = document;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach() { }\n    /** Blocks page-level scroll while the attached overlay is open. */\n    enable() {\n        if (this._canBeEnabled()) {\n            const root = this._document.documentElement;\n            this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition();\n            // Cache the previous inline styles in case the user had set them.\n            this._previousHTMLStyles.left = root.style.left || '';\n            this._previousHTMLStyles.top = root.style.top || '';\n            // Note: we're using the `html` node, instead of the `body`, because the `body` may\n            // have the user agent margin, whereas the `html` is guaranteed not to have one.\n            root.style.left = coerceCssPixelValue(-this._previousScrollPosition.left);\n            root.style.top = coerceCssPixelValue(-this._previousScrollPosition.top);\n            root.classList.add('cdk-global-scrollblock');\n            this._isEnabled = true;\n        }\n    }\n    /** Unblocks page-level scroll while the attached overlay is open. */\n    disable() {\n        if (this._isEnabled) {\n            const html = this._document.documentElement;\n            const body = this._document.body;\n            const htmlStyle = html.style;\n            const bodyStyle = body.style;\n            const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';\n            const previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';\n            this._isEnabled = false;\n            htmlStyle.left = this._previousHTMLStyles.left;\n            htmlStyle.top = this._previousHTMLStyles.top;\n            html.classList.remove('cdk-global-scrollblock');\n            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.\n            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior\n            // Note that we don't mutate the property if the browser doesn't support `scroll-behavior`,\n            // because it can throw off feature detections in `supportsScrollBehavior` which\n            // checks for `'scrollBehavior' in documentElement.style`.\n            if (overlay_scrollBehaviorSupported) {\n                htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';\n            }\n            window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top);\n            if (overlay_scrollBehaviorSupported) {\n                htmlStyle.scrollBehavior = previousHtmlScrollBehavior;\n                bodyStyle.scrollBehavior = previousBodyScrollBehavior;\n            }\n        }\n    }\n    _canBeEnabled() {\n        // Since the scroll strategies can't be singletons, we have to use a global CSS class\n        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global\n        // scrolling multiple times.\n        const html = this._document.documentElement;\n        if (html.classList.contains('cdk-global-scrollblock') || this._isEnabled) {\n            return false;\n        }\n        const body = this._document.body;\n        const viewport = this._viewportRuler.getViewportSize();\n        return body.scrollHeight > viewport.height || body.scrollWidth > viewport.width;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an error to be thrown when attempting to attach an already-attached scroll strategy.\n */\nfunction getMatScrollStrategyAlreadyAttachedError() {\n    return Error(`Scroll strategy has already been attached.`);\n}\n/**\n * Strategy that will close the overlay as soon as the user starts scrolling.\n */\nclass CloseScrollStrategy {\n    constructor(_scrollDispatcher, _ngZone, _viewportRuler, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._ngZone = _ngZone;\n        this._viewportRuler = _viewportRuler;\n        this._config = _config;\n        this._scrollSubscription = null;\n        /** Detaches the overlay ref and disables the scroll strategy. */\n        this._detach = () => {\n            this.disable();\n            if (this._overlayRef.hasAttached()) {\n                this._ngZone.run(() => this._overlayRef.detach());\n            }\n        };\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /** Enables the closing of the attached overlay on scroll. */\n    enable() {\n        if (this._scrollSubscription) {\n            return;\n        }\n        const stream = this._scrollDispatcher.scrolled(0);\n        if (this._config && this._config.threshold && this._config.threshold > 1) {\n            this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n            this._scrollSubscription = stream.subscribe(() => {\n                const scrollPosition = this._viewportRuler.getViewportScrollPosition().top;\n                if (Math.abs(scrollPosition - this._initialScrollPosition) > this._config.threshold) {\n                    this._detach();\n                }\n                else {\n                    this._overlayRef.updatePosition();\n                }\n            });\n        }\n        else {\n            this._scrollSubscription = stream.subscribe(this._detach);\n        }\n    }\n    /** Disables the closing the attached overlay on scroll. */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    detach() {\n        this.disable();\n        this._overlayRef = null;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Scroll strategy that doesn't do anything. */\nclass NoopScrollStrategy {\n    /** Does nothing, as this scroll strategy is a no-op. */\n    enable() { }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    disable() { }\n    /** Does nothing, as this scroll strategy is a no-op. */\n    attach() { }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO(jelbourn): move this to live with the rest of the scrolling code\n// TODO(jelbourn): someday replace this with IntersectionObservers\n/**\n * Gets whether an element is scrolled outside of view by any of its parent scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is scrolled out of view\n * @docs-private\n */\nfunction isElementScrolledOutsideView(element, scrollContainers) {\n    return scrollContainers.some(containerBounds => {\n        const outsideAbove = element.bottom < containerBounds.top;\n        const outsideBelow = element.top > containerBounds.bottom;\n        const outsideLeft = element.right < containerBounds.left;\n        const outsideRight = element.left > containerBounds.right;\n        return outsideAbove || outsideBelow || outsideLeft || outsideRight;\n    });\n}\n/**\n * Gets whether an element is clipped by any of its scrolling containers.\n * @param element Dimensions of the element (from getBoundingClientRect)\n * @param scrollContainers Dimensions of element's scrolling containers (from getBoundingClientRect)\n * @returns Whether the element is clipped\n * @docs-private\n */\nfunction isElementClippedByScrolling(element, scrollContainers) {\n    return scrollContainers.some(scrollContainerRect => {\n        const clippedAbove = element.top < scrollContainerRect.top;\n        const clippedBelow = element.bottom > scrollContainerRect.bottom;\n        const clippedLeft = element.left < scrollContainerRect.left;\n        const clippedRight = element.right > scrollContainerRect.right;\n        return clippedAbove || clippedBelow || clippedLeft || clippedRight;\n    });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Strategy that will update the element position as the user is scrolling.\n */\nclass RepositionScrollStrategy {\n    constructor(_scrollDispatcher, _viewportRuler, _ngZone, _config) {\n        this._scrollDispatcher = _scrollDispatcher;\n        this._viewportRuler = _viewportRuler;\n        this._ngZone = _ngZone;\n        this._config = _config;\n        this._scrollSubscription = null;\n    }\n    /** Attaches this scroll strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw getMatScrollStrategyAlreadyAttachedError();\n        }\n        this._overlayRef = overlayRef;\n    }\n    /** Enables repositioning of the attached overlay on scroll. */\n    enable() {\n        if (!this._scrollSubscription) {\n            const throttle = this._config ? this._config.scrollThrottle : 0;\n            this._scrollSubscription = this._scrollDispatcher.scrolled(throttle).subscribe(() => {\n                this._overlayRef.updatePosition();\n                // TODO(crisbeto): make `close` on by default once all components can handle it.\n                if (this._config && this._config.autoClose) {\n                    const overlayRect = this._overlayRef.overlayElement.getBoundingClientRect();\n                    const { width, height } = this._viewportRuler.getViewportSize();\n                    // TODO(crisbeto): include all ancestor scroll containers here once\n                    // we have a way of exposing the trigger element to the scroll strategy.\n                    const parentRects = [{ width, height, bottom: height, right: width, top: 0, left: 0 }];\n                    if (isElementScrolledOutsideView(overlayRect, parentRects)) {\n                        this.disable();\n                        this._ngZone.run(() => this._overlayRef.detach());\n                    }\n                }\n            });\n        }\n    }\n    /** Disables repositioning of the attached overlay on scroll. */\n    disable() {\n        if (this._scrollSubscription) {\n            this._scrollSubscription.unsubscribe();\n            this._scrollSubscription = null;\n        }\n    }\n    detach() {\n        this.disable();\n        this._overlayRef = null;\n    }\n}\nlet overlay_ScrollStrategyOptions = /*@__PURE__*/ (() => {\n    class ScrollStrategyOptions {\n        constructor(_scrollDispatcher, _viewportRuler, _ngZone, document) {\n            this._scrollDispatcher = _scrollDispatcher;\n            this._viewportRuler = _viewportRuler;\n            this._ngZone = _ngZone;\n            /** Do nothing on scroll. */\n            this.noop = () => new NoopScrollStrategy();\n            /**\n             * Close the overlay as soon as the user scrolls.\n             * @param config Configuration to be used inside the scroll strategy.\n             */\n            this.close = (config) => new CloseScrollStrategy(this._scrollDispatcher, this._ngZone, this._viewportRuler, config);\n            /** Block scrolling. */\n            this.block = () => new overlay_BlockScrollStrategy(this._viewportRuler, this._document);\n            /**\n             * Update the overlay's position on scroll.\n             * @param config Configuration to be used inside the scroll strategy.\n             * Allows debouncing the reposition calls.\n             */\n            this.reposition = (config) => new RepositionScrollStrategy(this._scrollDispatcher, this._viewportRuler, this._ngZone, config);\n            this._document = document;\n        }\n    }\n    ScrollStrategyOptions.fac = function ScrollStrategyOptions_Factory(t) { return new (t || ScrollStrategyOptions)(core[\"Wb\" /* inject */](scrolling_ScrollDispatcher), core[\"Wb\" /* inject */](scrolling_ViewportRuler), core[\"Wb\" /* inject */](core[\"A\" /* NgZone */]), core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */])); };\n    ScrollStrategyOptions.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function ScrollStrategyOptions_Factory() { return new ScrollStrategyOptions(Object(core[\"Wb\" /* inject */])(scrolling_ScrollDispatcher), Object(core[\"Wb\" /* inject */])(scrolling_ViewportRuler), Object(core[\"Wb\" /* inject */])(core[\"A\" /* NgZone */]), Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */])); }, token: ScrollStrategyOptions, providedIn: \"root\" });\n    return ScrollStrategyOptions;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Initial configuration used when creating an overlay. */\nclass OverlayConfig {\n    constructor(config) {\n        /** Strategy to be used when handling scroll events while the overlay is open. */\n        this.scrollStrategy = new NoopScrollStrategy();\n        /** Custom class to add to the overlay pane. */\n        this.panelClass = '';\n        /** Whether the overlay has a backdrop. */\n        this.hasBackdrop = false;\n        /** Custom class to add to the backdrop */\n        this.backdropClass = 'cdk-overlay-dark-backdrop';\n        /**\n         * Whether the overlay should be disposed of when the user goes backwards/forwards in history.\n         * Note that this usually doesn't include clicking on links (unless the user is using\n         * the `HashLocationStrategy`).\n         */\n        this.disposeOnNavigation = false;\n        if (config) {\n            // Use `Iterable` instead of `Array` because TypeScript, as of 3.6.3,\n            // loses the array generic type in the `for of`. But we *also* have to use `Array` because\n            // typescript won't iterate over an `Iterable` unless you compile with `--downlevelIteration`\n            const configKeys = Object.keys(config);\n            for (const key of configKeys) {\n                if (config[key] !== undefined) {\n                    // TypeScript, as of version 3.5, sees the left-hand-side of this expression\n                    // as \"I don't know *which* key this is, so the only valid value is the intersection\n                    // of all the posible values.\" In this case, that happens to be `undefined`. TypeScript\n                    // is not smart enough to see that the right-hand-side is actually an access of the same\n                    // exact type with the same exact key, meaning that the value type must be identical.\n                    // So we use `any` to work around this.\n                    this[key] = config[key];\n                }\n            }\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The points of the origin element and the overlay element to connect. */\nclass ConnectionPositionPair {\n    constructor(origin, overlay, \n    /** Offset along the X axis. */\n    offsetX, \n    /** Offset along the Y axis. */\n    offsetY, \n    /** Class(es) to be applied to the panel while this position is active. */\n    panelClass) {\n        this.offsetX = offsetX;\n        this.offsetY = offsetY;\n        this.panelClass = panelClass;\n        this.originX = origin.originX;\n        this.originY = origin.originY;\n        this.overlayX = overlay.overlayX;\n        this.overlayY = overlay.overlayY;\n    }\n}\n/**\n * Set of properties regarding the position of the origin and overlay relative to the viewport\n * with respect to the containing Scrollable elements.\n *\n * The overlay and origin are clipped if any part of their bounding client rectangle exceeds the\n * bounds of any one of the strategy's Scrollable's bounding client rectangle.\n *\n * The overlay and origin are outside view if there is no overlap between their bounding client\n * rectangle and any one of the strategy's Scrollable's bounding client rectangle.\n *\n *       -----------                    -----------\n *       | outside |                    | clipped |\n *       |  view   |              --------------------------\n *       |         |              |     |         |        |\n *       ----------               |     -----------        |\n *  --------------------------    |                        |\n *  |                        |    |      Scrollable        |\n *  |                        |    |                        |\n *  |                        |     --------------------------\n *  |      Scrollable        |\n *  |                        |\n *  --------------------------\n *\n *  @docs-private\n */\nclass ScrollingVisibility {\n}\n/** The change event emitted by the strategy when a fallback position is used. */\nclass ConnectedOverlayPositionChange {\n    constructor(\n    /** The position used as a result of this change. */\n    connectionPair, \n    /** @docs-private */\n    scrollableViewProperties) {\n        this.connectionPair = connectionPair;\n        this.scrollableViewProperties = scrollableViewProperties;\n    }\n}\n/**\n * Validates whether a vertical position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateVerticalPosition(property, value) {\n    if (value !== 'top' && value !== 'bottom' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"top\", \"bottom\" or \"center\".`);\n    }\n}\n/**\n * Validates whether a horizontal position property matches the expected values.\n * @param property Name of the property being validated.\n * @param value Value of the property being validated.\n * @docs-private\n */\nfunction validateHorizontalPosition(property, value) {\n    if (value !== 'start' && value !== 'end' && value !== 'center') {\n        throw Error(`ConnectedPosition: Invalid ${property} \"${value}\". ` +\n            `Expected \"start\", \"end\" or \"center\".`);\n    }\n}\nlet overlay_BaseOverlayDispatcher = /*@__PURE__*/ (() => {\n    class BaseOverlayDispatcher {\n        constructor(document) {\n            /** Currently attached overlays in the order they were attached. */\n            this._attachedOverlays = [];\n            this._document = document;\n        }\n        ngOnDestroy() {\n            this.detach();\n        }\n        /** Add a new overlay to the list of attached overlay refs. */\n        add(overlayRef) {\n            // Ensure that we don't get the same overlay multiple times.\n            this.remove(overlayRef);\n            this._attachedOverlays.push(overlayRef);\n        }\n        /** Remove an overlay from the list of attached overlay refs. */\n        remove(overlayRef) {\n            const index = this._attachedOverlays.indexOf(overlayRef);\n            if (index > -1) {\n                this._attachedOverlays.splice(index, 1);\n            }\n            // Remove the global listener once there are no more overlays.\n            if (this._attachedOverlays.length === 0) {\n                this.detach();\n            }\n        }\n    }\n    BaseOverlayDispatcher.fac = function BaseOverlayDispatcher_Factory(t) { return new (t || BaseOverlayDispatcher)(core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */])); };\n    BaseOverlayDispatcher.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function BaseOverlayDispatcher_Factory() { return new BaseOverlayDispatcher(Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */])); }, token: BaseOverlayDispatcher, providedIn: \"root\" });\n    return BaseOverlayDispatcher;\n})();\nlet overlay_OverlayKeyboardDispatcher = /*@__PURE__*/ (() => {\n    class OverlayKeyboardDispatcher extends overlay_BaseOverlayDispatcher {\n        constructor(document) {\n            super(document);\n            /** Keyboard event listener that will be attached to the body. */\n            this._keydownListener = (event) => {\n                const overlays = this._attachedOverlays;\n                for (let i = overlays.length - 1; i > -1; i--) {\n                    // Dispatch the keydown event to the top overlay which has subscribers to its keydown events.\n                    // We want to target the most recent overlay, rather than trying to match where the event came\n                    // from, because some components might open an overlay, but keep focus on a trigger element\n                    // (e.g. for select and autocomplete). We skip overlays without keydown event subscriptions,\n                    // because we don't want overlays that don't handle keyboard events to block the ones below\n                    // them that do.\n                    if (overlays[i]._keydownEvents.observers.length > 0) {\n                        overlays[i]._keydownEvents.next(event);\n                        break;\n                    }\n                }\n            };\n        }\n        /** Add a new overlay to the list of attached overlay refs. */\n        add(overlayRef) {\n            super.add(overlayRef);\n            // Lazily start dispatcher once first overlay is added\n            if (!this._isAttached) {\n                this._document.body.addEventListener('keydown', this._keydownListener);\n                this._isAttached = true;\n            }\n        }\n        /** Detaches the global keyboard event listener. */\n        detach() {\n            if (this._isAttached) {\n                this._document.body.removeEventListener('keydown', this._keydownListener);\n                this._isAttached = false;\n            }\n        }\n    }\n    OverlayKeyboardDispatcher.fac = function OverlayKeyboardDispatcher_Factory(t) { return new (t || OverlayKeyboardDispatcher)(core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */])); };\n    OverlayKeyboardDispatcher.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function OverlayKeyboardDispatcher_Factory() { return new OverlayKeyboardDispatcher(Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */])); }, token: OverlayKeyboardDispatcher, providedIn: \"root\" });\n    return OverlayKeyboardDispatcher;\n})();\nlet overlay_OverlayOutsideClickDispatcher = /*@__PURE__*/ (() => {\n    class OverlayOutsideClickDispatcher extends overlay_BaseOverlayDispatcher {\n        constructor(document, _platform) {\n            super(document);\n            this._platform = _platform;\n            this._cursorStyleIsSet = false;\n            /** Click event listener that will be attached to the body propagate phase. */\n            this._clickListener = (event) => {\n                // Get the target through the `composedPath` if possible to account for shadow DOM.\n                const target = event.composedPath ? event.composedPath()[0] : event.target;\n                // We copy the array because the original may be modified asynchronously if the\n                // outsidePointerEvents listener decides to detach overlays resulting in index errors inside\n                // the for loop.\n                const overlays = this._attachedOverlays.slice();\n                // Dispatch the mouse event to the top overlay which has subscribers to its mouse events.\n                // We want to target all overlays for which the click could be considered as outside click.\n                // As soon as we reach an overlay for which the click is not outside click we break off\n                // the loop.\n                for (let i = overlays.length - 1; i > -1; i--) {\n                    const overlayRef = overlays[i];\n                    if (overlayRef._outsidePointerEvents.observers.length < 1 || !overlayRef.hasAttached()) {\n                        continue;\n                    }\n                    // If it's a click inside the overlay, just break - we should do nothing\n                    // If it's an outside click dispatch the mouse event, and proceed with the next overlay\n                    if (overlayRef.overlayElement.contains(target)) {\n                        break;\n                    }\n                    overlayRef._outsidePointerEvents.next(event);\n                }\n            };\n        }\n        /** Add a new overlay to the list of attached overlay refs. */\n        add(overlayRef) {\n            super.add(overlayRef);\n            // Safari on iOS does not generate click events for non-interactive\n            // elements. However, we want to receive a click for any element outside\n            // the overlay. We can force a \"clickable\" state by setting\n            // `cursor: pointer` on the document body. See:\n            // https://developer.mozilla.org/en-US/docs/Web/API/Element/click_event#Safari_Mobile\n            // https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariWebContent/HandlingEvents/HandlingEvents.html\n            if (!this._isAttached) {\n                const body = this._document.body;\n                body.addEventListener('click', this._clickListener, true);\n                body.addEventListener('auxclick', this._clickListener, true);\n                body.addEventListener('contextmenu', this._clickListener, true);\n                // click event is not fired on iOS. To make element \"clickable\" we are\n                // setting the cursor to pointer\n                if (this._platform.IOS && !this._cursorStyleIsSet) {\n                    this._cursorOriginalValue = body.style.cursor;\n                    body.style.cursor = 'pointer';\n                    this._cursorStyleIsSet = true;\n                }\n                this._isAttached = true;\n            }\n        }\n        /** Detaches the global keyboard event listener. */\n        detach() {\n            if (this._isAttached) {\n                const body = this._document.body;\n                body.removeEventListener('click', this._clickListener, true);\n                body.removeEventListener('auxclick', this._clickListener, true);\n                body.removeEventListener('contextmenu', this._clickListener, true);\n                if (this._platform.IOS && this._cursorStyleIsSet) {\n                    body.style.cursor = this._cursorOriginalValue;\n                    this._cursorStyleIsSet = false;\n                }\n                this._isAttached = false;\n            }\n        }\n    }\n    OverlayOutsideClickDispatcher.fac = function OverlayOutsideClickDispatcher_Factory(t) { return new (t || OverlayOutsideClickDispatcher)(core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */]), core[\"Wb\" /* inject */](platform_Platform)); };\n    OverlayOutsideClickDispatcher.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function OverlayOutsideClickDispatcher_Factory() { return new OverlayOutsideClickDispatcher(Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */]), Object(core[\"Wb\" /* inject */])(platform_Platform)); }, token: OverlayOutsideClickDispatcher, providedIn: \"root\" });\n    return OverlayOutsideClickDispatcher;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Whether we're in a testing environment.\n * TODO(crisbeto): remove this once we have an overlay testing module.\n */\nconst isTestEnvironment = typeof window !== 'undefined' && !!window &&\n    !!(window.__karma__ || window.jasmine);\nlet overlay_OverlayContainer = /*@__PURE__*/ (() => {\n    class OverlayContainer {\n        constructor(document, _platform) {\n            this._platform = _platform;\n            this._document = document;\n        }\n        ngOnDestroy() {\n            const container = this._containerElement;\n            if (container && container.parentNode) {\n                container.parentNode.removeChild(container);\n            }\n        }\n        /**\n         * This method returns the overlay container element. It will lazily\n         * create the element the first time  it is called to facilitate using\n         * the container in non-browser environments.\n         * @returns the container element\n         */\n        getContainerElement() {\n            if (!this._containerElement) {\n                this._createContainer();\n            }\n            return this._containerElement;\n        }\n        /**\n         * Create the overlay container element, which is simply a div\n         * with the 'cdk-overlay-container' class on the document body.\n         */\n        _createContainer() {\n            const containerClass = 'cdk-overlay-container';\n            if (this._platform.isBrowser || isTestEnvironment) {\n                const oppositePlatformContainers = this._document.querySelectorAll(`.${containerClass}[platform=\"server\"], ` +\n                    `.${containerClass}[platform=\"test\"]`);\n                // Remove any old containers from the opposite platform.\n                // This can happen when transitioning from the server to the client.\n                for (let i = 0; i < oppositePlatformContainers.length; i++) {\n                    oppositePlatformContainers[i].parentNode.removeChild(oppositePlatformContainers[i]);\n                }\n            }\n            const container = this._document.createElement('div');\n            container.classList.add(containerClass);\n            // A long time ago we kept adding new overlay containers whenever a new app was instantiated,\n            // but at some point we added logic which clears the duplicate ones in order to avoid leaks.\n            // The new logic was a little too aggressive since it was breaking some legitimate use cases.\n            // To mitigate the problem we made it so that only containers from a different platform are\n            // cleared, but the side-effect was that people started depending on the overly-aggressive\n            // logic to clean up their tests for them. Until we can introduce an overlay-specific testing\n            // module which does the cleanup, we try to detect that we're in a test environment and we\n            // always clear the container. See #17006.\n            // TODO(crisbeto): remove the test environment check once we have an overlay testing module.\n            if (isTestEnvironment) {\n                container.setAttribute('platform', 'test');\n            }\n            else if (!this._platform.isBrowser) {\n                container.setAttribute('platform', 'server');\n            }\n            this._document.body.appendChild(container);\n            this._containerElement = container;\n        }\n    }\n    OverlayContainer.fac = function OverlayContainer_Factory(t) { return new (t || OverlayContainer)(core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */]), core[\"Wb\" /* inject */](platform_Platform)); };\n    OverlayContainer.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function OverlayContainer_Factory() { return new OverlayContainer(Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */]), Object(core[\"Wb\" /* inject */])(platform_Platform)); }, token: OverlayContainer, providedIn: \"root\" });\n    return OverlayContainer;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Reference to an overlay that has been created with the Overlay service.\n * Used to manipulate or dispose of said overlay.\n */\nclass overlay_OverlayRef {\n    constructor(_portalOutlet, _host, _pane, _config, _ngZone, _keyboardDispatcher, _document, _location, _outsideClickDispatcher) {\n        this._portalOutlet = _portalOutlet;\n        this._host = _host;\n        this._pane = _pane;\n        this._config = _config;\n        this._ngZone = _ngZone;\n        this._keyboardDispatcher = _keyboardDispatcher;\n        this._document = _document;\n        this._location = _location;\n        this._outsideClickDispatcher = _outsideClickDispatcher;\n        this._backdropElement = null;\n        this._backdropClick = new Subject[\"a\" /* Subject */]();\n        this._attachments = new Subject[\"a\" /* Subject */]();\n        this._detachments = new Subject[\"a\" /* Subject */]();\n        this._locationChanges = Subscription[\"a\" /* Subscription */].EMPTY;\n        this._backdropClickHandler = (event) => this._backdropClick.next(event);\n        /** Stream of keydown events dispatched to this overlay. */\n        this._keydownEvents = new Subject[\"a\" /* Subject */]();\n        /** Stream of mouse outside events dispatched to this overlay. */\n        this._outsidePointerEvents = new Subject[\"a\" /* Subject */]();\n        if (_config.scrollStrategy) {\n            this._scrollStrategy = _config.scrollStrategy;\n            this._scrollStrategy.attach(this);\n        }\n        this._positionStrategy = _config.positionStrategy;\n    }\n    /** The overlay's HTML element */\n    get overlayElement() {\n        return this._pane;\n    }\n    /** The overlay's backdrop HTML element. */\n    get backdropElement() {\n        return this._backdropElement;\n    }\n    /**\n     * Wrapper around the panel element. Can be used for advanced\n     * positioning where a wrapper with specific styling is\n     * required around the overlay pane.\n     */\n    get hostElement() {\n        return this._host;\n    }\n    /**\n     * Attaches content, given via a Portal, to the overlay.\n     * If the overlay is configured to have a backdrop, it will be created.\n     *\n     * @param portal Portal instance to which to attach the overlay.\n     * @returns The portal attachment result.\n     */\n    attach(portal) {\n        let attachResult = this._portalOutlet.attach(portal);\n        // Update the pane element with the given configuration.\n        if (!this._host.parentElement && this._previousHostParent) {\n            this._previousHostParent.appendChild(this._host);\n        }\n        if (this._positionStrategy) {\n            this._positionStrategy.attach(this);\n        }\n        this._updateStackingOrder();\n        this._updateElementSize();\n        this._updateElementDirection();\n        if (this._scrollStrategy) {\n            this._scrollStrategy.enable();\n        }\n        // Update the position once the zone is stable so that the overlay will be fully rendered\n        // before attempting to position it, as the position may depend on the size of the rendered\n        // content.\n        this._ngZone.onStable\n            .pipe(Object(take[\"a\" /* take */])(1))\n            .subscribe(() => {\n            // The overlay could've been detached before the zone has stabilized.\n            if (this.hasAttached()) {\n                this.updatePosition();\n            }\n        });\n        // Enable pointer events for the overlay pane element.\n        this._togglePointerEvents(true);\n        if (this._config.hasBackdrop) {\n            this._attachBackdrop();\n        }\n        if (this._config.panelClass) {\n            this._toggleClasses(this._pane, this._config.panelClass, true);\n        }\n        // Only emit the `attachments` event once all other setup is done.\n        this._attachments.next();\n        // Track this overlay by the keyboard dispatcher\n        this._keyboardDispatcher.add(this);\n        if (this._config.disposeOnNavigation) {\n            this._locationChanges = this._location.subscribe(() => this.dispose());\n        }\n        this._outsideClickDispatcher.add(this);\n        return attachResult;\n    }\n    /**\n     * Detaches an overlay from a portal.\n     * @returns The portal detachment result.\n     */\n    detach() {\n        if (!this.hasAttached()) {\n            return;\n        }\n        this.detachBackdrop();\n        // When the overlay is detached, the pane element should disable pointer events.\n        // This is necessary because otherwise the pane element will cover the page and disable\n        // pointer events therefore. Depends on the position strategy and the applied pane boundaries.\n        this._togglePointerEvents(false);\n        if (this._positionStrategy && this._positionStrategy.detach) {\n            this._positionStrategy.detach();\n        }\n        if (this._scrollStrategy) {\n            this._scrollStrategy.disable();\n        }\n        const detachmentResult = this._portalOutlet.detach();\n        // Only emit after everything is detached.\n        this._detachments.next();\n        // Remove this overlay from keyboard dispatcher tracking.\n        this._keyboardDispatcher.remove(this);\n        // Keeping the host element in the DOM can cause scroll jank, because it still gets\n        // rendered, even though it's transparent and unclickable which is why we remove it.\n        this._detachContentWhenStable();\n        this._locationChanges.unsubscribe();\n        this._outsideClickDispatcher.remove(this);\n        return detachmentResult;\n    }\n    /** Cleans up the overlay from the DOM. */\n    dispose() {\n        const isAttached = this.hasAttached();\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._disposeScrollStrategy();\n        this.detachBackdrop();\n        this._locationChanges.unsubscribe();\n        this._keyboardDispatcher.remove(this);\n        this._portalOutlet.dispose();\n        this._attachments.complete();\n        this._backdropClick.complete();\n        this._keydownEvents.complete();\n        this._outsidePointerEvents.complete();\n        this._outsideClickDispatcher.remove(this);\n        if (this._host && this._host.parentNode) {\n            this._host.parentNode.removeChild(this._host);\n            this._host = null;\n        }\n        this._previousHostParent = this._pane = null;\n        if (isAttached) {\n            this._detachments.next();\n        }\n        this._detachments.complete();\n    }\n    /** Whether the overlay has attached content. */\n    hasAttached() {\n        return this._portalOutlet.hasAttached();\n    }\n    /** Gets an observable that emits when the backdrop has been clicked. */\n    backdropClick() {\n        return this._backdropClick;\n    }\n    /** Gets an observable that emits when the overlay has been attached. */\n    attachments() {\n        return this._attachments;\n    }\n    /** Gets an observable that emits when the overlay has been detached. */\n    detachments() {\n        return this._detachments;\n    }\n    /** Gets an observable of keydown events targeted to this overlay. */\n    keydownEvents() {\n        return this._keydownEvents;\n    }\n    /** Gets an observable of pointer events targeted outside this overlay. */\n    outsidePointerEvents() {\n        return this._outsidePointerEvents;\n    }\n    /** Gets the current overlay configuration, which is immutable. */\n    getConfig() {\n        return this._config;\n    }\n    /** Updates the position of the overlay based on the position strategy. */\n    updatePosition() {\n        if (this._positionStrategy) {\n            this._positionStrategy.apply();\n        }\n    }\n    /** Switches to a new position strategy and updates the overlay position. */\n    updatePositionStrategy(strategy) {\n        if (strategy === this._positionStrategy) {\n            return;\n        }\n        if (this._positionStrategy) {\n            this._positionStrategy.dispose();\n        }\n        this._positionStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            this.updatePosition();\n        }\n    }\n    /** Update the size properties of the overlay. */\n    updateSize(sizeConfig) {\n        this._config = Object.assign(Object.assign({}, this._config), sizeConfig);\n        this._updateElementSize();\n    }\n    /** Sets the LTR/RTL direction for the overlay. */\n    setDirection(dir) {\n        this._config = Object.assign(Object.assign({}, this._config), { direction: dir });\n        this._updateElementDirection();\n    }\n    /** Add a CSS class or an array of classes to the overlay pane. */\n    addPanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, true);\n        }\n    }\n    /** Remove a CSS class or an array of classes from the overlay pane. */\n    removePanelClass(classes) {\n        if (this._pane) {\n            this._toggleClasses(this._pane, classes, false);\n        }\n    }\n    /**\n     * Returns the layout direction of the overlay panel.\n     */\n    getDirection() {\n        const direction = this._config.direction;\n        if (!direction) {\n            return 'ltr';\n        }\n        return typeof direction === 'string' ? direction : direction.value;\n    }\n    /** Switches to a new scroll strategy. */\n    updateScrollStrategy(strategy) {\n        if (strategy === this._scrollStrategy) {\n            return;\n        }\n        this._disposeScrollStrategy();\n        this._scrollStrategy = strategy;\n        if (this.hasAttached()) {\n            strategy.attach(this);\n            strategy.enable();\n        }\n    }\n    /** Updates the text direction of the overlay panel. */\n    _updateElementDirection() {\n        this._host.setAttribute('dir', this.getDirection());\n    }\n    /** Updates the size of the overlay element based on the overlay config. */\n    _updateElementSize() {\n        if (!this._pane) {\n            return;\n        }\n        const style = this._pane.style;\n        style.width = coerceCssPixelValue(this._config.width);\n        style.height = coerceCssPixelValue(this._config.height);\n        style.minWidth = coerceCssPixelValue(this._config.minWidth);\n        style.minHeight = coerceCssPixelValue(this._config.minHeight);\n        style.maxWidth = coerceCssPixelValue(this._config.maxWidth);\n        style.maxHeight = coerceCssPixelValue(this._config.maxHeight);\n    }\n    /** Toggles the pointer events for the overlay pane element. */\n    _togglePointerEvents(enablePointer) {\n        this._pane.style.pointerEvents = enablePointer ? '' : 'none';\n    }\n    /** Attaches a backdrop for this overlay. */\n    _attachBackdrop() {\n        const showingClass = 'cdk-overlay-backdrop-showing';\n        this._backdropElement = this._document.createElement('div');\n        this._backdropElement.classList.add('cdk-overlay-backdrop');\n        if (this._config.backdropClass) {\n            this._toggleClasses(this._backdropElement, this._config.backdropClass, true);\n        }\n        // Insert the backdrop before the pane in the DOM order,\n        // in order to handle stacked overlays properly.\n        this._host.parentElement.insertBefore(this._backdropElement, this._host);\n        // Forward backdrop clicks such that the consumer of the overlay can perform whatever\n        // action desired when such a click occurs (usually closing the overlay).\n        this._backdropElement.addEventListener('click', this._backdropClickHandler);\n        // Add class to fade-in the backdrop after one frame.\n        if (typeof requestAnimationFrame !== 'undefined') {\n            this._ngZone.runOutsideAngular(() => {\n                requestAnimationFrame(() => {\n                    if (this._backdropElement) {\n                        this._backdropElement.classList.add(showingClass);\n                    }\n                });\n            });\n        }\n        else {\n            this._backdropElement.classList.add(showingClass);\n        }\n    }\n    /**\n     * Updates the stacking order of the element, moving it to the top if necessary.\n     * This is required in cases where one overlay was detached, while another one,\n     * that should be behind it, was destroyed. The next time both of them are opened,\n     * the stacking will be wrong, because the detached element's pane will still be\n     * in its original DOM position.\n     */\n    _updateStackingOrder() {\n        if (this._host.nextSibling) {\n            this._host.parentNode.appendChild(this._host);\n        }\n    }\n    /** Detaches the backdrop (if any) associated with the overlay. */\n    detachBackdrop() {\n        let backdropToDetach = this._backdropElement;\n        if (!backdropToDetach) {\n            return;\n        }\n        let timeoutId;\n        let finishDetach = () => {\n            // It may not be attached to anything in certain cases (e.g. unit tests).\n            if (backdropToDetach) {\n                backdropToDetach.removeEventListener('click', this._backdropClickHandler);\n                backdropToDetach.removeEventListener('transitionend', finishDetach);\n                if (backdropToDetach.parentNode) {\n                    backdropToDetach.parentNode.removeChild(backdropToDetach);\n                }\n            }\n            // It is possible that a new portal has been attached to this overlay since we started\n            // removing the backdrop. If that is the case, only clear the backdrop reference if it\n            // is still the same instance that we started to remove.\n            if (this._backdropElement == backdropToDetach) {\n                this._backdropElement = null;\n            }\n            if (this._config.backdropClass) {\n                this._toggleClasses(backdropToDetach, this._config.backdropClass, false);\n            }\n            clearTimeout(timeoutId);\n        };\n        backdropToDetach.classList.remove('cdk-overlay-backdrop-showing');\n        this._ngZone.runOutsideAngular(() => {\n            backdropToDetach.addEventListener('transitionend', finishDetach);\n        });\n        // If the backdrop doesn't have a transition, the `transitionend` event won't fire.\n        // In this case we make it unclickable and we try to remove it after a delay.\n        backdropToDetach.style.pointerEvents = 'none';\n        // Run this outside the Angular zone because there's nothing that Angular cares about.\n        // If it were to run inside the Angular zone, every test that used Overlay would have to be\n        // either async or fakeAsync.\n        timeoutId = this._ngZone.runOutsideAngular(() => setTimeout(finishDetach, 500));\n    }\n    /** Toggles a single CSS class or an array of classes on an element. */\n    _toggleClasses(element, cssClasses, isAdd) {\n        const classList = element.classList;\n        coerceArray(cssClasses).forEach(cssClass => {\n            // We can't do a spread here, because IE doesn't support setting multiple classes.\n            // Also trying to add an empty string to a DOMTokenList will throw.\n            if (cssClass) {\n                isAdd ? classList.add(cssClass) : classList.remove(cssClass);\n            }\n        });\n    }\n    /** Detaches the overlay content next time the zone stabilizes. */\n    _detachContentWhenStable() {\n        // Normally we wouldn't have to explicitly run this outside the `NgZone`, however\n        // if the consumer is using `zone-patch-rxjs`, the `Subscription.unsubscribe` call will\n        // be patched to run inside the zone, which will throw us into an infinite loop.\n        this._ngZone.runOutsideAngular(() => {\n            // We can't remove the host here immediately, because the overlay pane's content\n            // might still be animating. This stream helps us avoid interrupting the animation\n            // by waiting for the pane to become empty.\n            const subscription = this._ngZone.onStable\n                .pipe(takeUntil(Object(merge[\"a\" /* merge */])(this._attachments, this._detachments)))\n                .subscribe(() => {\n                // Needs a couple of checks for the pane and host, because\n                // they may have been removed by the time the zone stabilizes.\n                if (!this._pane || !this._host || this._pane.children.length === 0) {\n                    if (this._pane && this._config.panelClass) {\n                        this._toggleClasses(this._pane, this._config.panelClass, false);\n                    }\n                    if (this._host && this._host.parentElement) {\n                        this._previousHostParent = this._host.parentElement;\n                        this._previousHostParent.removeChild(this._host);\n                    }\n                    subscription.unsubscribe();\n                }\n            });\n        });\n    }\n    /** Disposes of a scroll strategy. */\n    _disposeScrollStrategy() {\n        const scrollStrategy = this._scrollStrategy;\n        if (scrollStrategy) {\n            scrollStrategy.disable();\n            if (scrollStrategy.detach) {\n                scrollStrategy.detach();\n            }\n        }\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// TODO: refactor clipping detection into a separate thing (part of scrolling module)\n// TODO: doesn't handle both flexible width and height when it has to scroll along both axis.\n/** Class to be added to the overlay bounding box. */\nconst boundingBoxClass = 'cdk-overlay-connected-position-bounding-box';\n/** Regex used to split a string on its CSS units. */\nconst cssUnitPattern = /([A-Za-z%]+)$/;\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n */\nclass overlay_FlexibleConnectedPositionStrategy {\n    constructor(connectedTo, _viewportRuler, _document, _platform, _overlayContainer) {\n        this._viewportRuler = _viewportRuler;\n        this._document = _document;\n        this._platform = _platform;\n        this._overlayContainer = _overlayContainer;\n        /** Last size used for the bounding box. Used to avoid resizing the overlay after open. */\n        this._lastBoundingBoxSize = { width: 0, height: 0 };\n        /** Whether the overlay was pushed in a previous positioning. */\n        this._isPushed = false;\n        /** Whether the overlay can be pushed on-screen on the initial open. */\n        this._canPush = true;\n        /** Whether the overlay can grow via flexible width/height after the initial open. */\n        this._growAfterOpen = false;\n        /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n        this._hasFlexibleDimensions = true;\n        /** Whether the overlay position is locked. */\n        this._positionLocked = false;\n        /** Amount of space that must be maintained between the overlay and the edge of the viewport. */\n        this._viewportMargin = 0;\n        /** The Scrollable containers used to check scrollable view properties on position change. */\n        this._scrollables = [];\n        /** Ordered list of preferred positions, from most to least desirable. */\n        this._preferredPositions = [];\n        /** Subject that emits whenever the position changes. */\n        this._positionChanges = new Subject[\"a\" /* Subject */]();\n        /** Subscription to viewport size changes. */\n        this._resizeSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n        /** Default offset for the overlay along the x axis. */\n        this._offsetX = 0;\n        /** Default offset for the overlay along the y axis. */\n        this._offsetY = 0;\n        /** Keeps track of the CSS classes that the position strategy has applied on the overlay panel. */\n        this._appliedPanelClasses = [];\n        /** Observable sequence of position changes. */\n        this.positionChanges = this._positionChanges;\n        this.setOrigin(connectedTo);\n    }\n    /** Ordered list of preferred positions, from most to least desirable. */\n    get positions() {\n        return this._preferredPositions;\n    }\n    /** Attaches this position strategy to an overlay. */\n    attach(overlayRef) {\n        if (this._overlayRef && overlayRef !== this._overlayRef &&\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\n            throw Error('This position strategy is already attached to an overlay');\n        }\n        this._validatePositions();\n        overlayRef.hostElement.classList.add(boundingBoxClass);\n        this._overlayRef = overlayRef;\n        this._boundingBox = overlayRef.hostElement;\n        this._pane = overlayRef.overlayElement;\n        this._isDisposed = false;\n        this._isInitialRender = true;\n        this._lastPosition = null;\n        this._resizeSubscription.unsubscribe();\n        this._resizeSubscription = this._viewportRuler.change().subscribe(() => {\n            // When the window is resized, we want to trigger the next reposition as if it\n            // was an initial render, in order for the strategy to pick a new optimal position,\n            // otherwise position locking will cause it to stay at the old one.\n            this._isInitialRender = true;\n            this.apply();\n        });\n    }\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin best fits on-screen.\n     *\n     * The selection of a position goes as follows:\n     *  - If any positions fit completely within the viewport as-is,\n     *      choose the first position that does so.\n     *  - If flexible dimensions are enabled and at least one satifies the given minimum width/height,\n     *      choose the position with the greatest available size modified by the positions' weight.\n     *  - If pushing is enabled, take the position that went off-screen the least and push it\n     *      on-screen.\n     *  - If none of the previous criteria were met, use the position that goes off-screen the least.\n     * @docs-private\n     */\n    apply() {\n        // We shouldn't do anything if the strategy was disposed or we're on the server.\n        if (this._isDisposed || !this._platform.isBrowser) {\n            return;\n        }\n        // If the position has been applied already (e.g. when the overlay was opened) and the\n        // consumer opted into locking in the position, re-use the old position, in order to\n        // prevent the overlay from jumping around.\n        if (!this._isInitialRender && this._positionLocked && this._lastPosition) {\n            this.reapplyLastPosition();\n            return;\n        }\n        this._clearPanelClasses();\n        this._resetOverlayElementStyles();\n        this._resetBoundingBoxStyles();\n        // We need the bounding rects for the origin and the overlay to determine how to position\n        // the overlay relative to the origin.\n        // We use the viewport rect to determine whether a position would go off-screen.\n        this._viewportRect = this._getNarrowedViewportRect();\n        this._originRect = this._getOriginRect();\n        this._overlayRect = this._pane.getBoundingClientRect();\n        const originRect = this._originRect;\n        const overlayRect = this._overlayRect;\n        const viewportRect = this._viewportRect;\n        // Positions where the overlay will fit with flexible dimensions.\n        const flexibleFits = [];\n        // Fallback if none of the preferred positions fit within the viewport.\n        let fallback;\n        // Go through each of the preferred positions looking for a good fit.\n        // If a good fit is found, it will be applied immediately.\n        for (let pos of this._preferredPositions) {\n            // Get the exact (x, y) coordinate for the point-of-origin on the origin element.\n            let originPoint = this._getOriginPoint(originRect, pos);\n            // From that point-of-origin, get the exact (x, y) coordinate for the top-left corner of the\n            // overlay in this position. We use the top-left corner for calculations and later translate\n            // this into an appropriate (top, left, bottom, right) style.\n            let overlayPoint = this._getOverlayPoint(originPoint, overlayRect, pos);\n            // Calculate how well the overlay would fit into the viewport with this point.\n            let overlayFit = this._getOverlayFit(overlayPoint, overlayRect, viewportRect, pos);\n            // If the overlay, without any further work, fits into the viewport, use this position.\n            if (overlayFit.isCompletelyWithinViewport) {\n                this._isPushed = false;\n                this._applyPosition(pos, originPoint);\n                return;\n            }\n            // If the overlay has flexible dimensions, we can use this position\n            // so long as there's enough space for the minimum dimensions.\n            if (this._canFitWithFlexibleDimensions(overlayFit, overlayPoint, viewportRect)) {\n                // Save positions where the overlay will fit with flexible dimensions. We will use these\n                // if none of the positions fit *without* flexible dimensions.\n                flexibleFits.push({\n                    position: pos,\n                    origin: originPoint,\n                    overlayRect,\n                    boundingBoxRect: this._calculateBoundingBoxRect(originPoint, pos)\n                });\n                continue;\n            }\n            // If the current preferred position does not fit on the screen, remember the position\n            // if it has more visible area on-screen than we've seen and move onto the next preferred\n            // position.\n            if (!fallback || fallback.overlayFit.visibleArea < overlayFit.visibleArea) {\n                fallback = { overlayFit, overlayPoint, originPoint, position: pos, overlayRect };\n            }\n        }\n        // If there are any positions where the overlay would fit with flexible dimensions, choose the\n        // one that has the greatest area available modified by the position's weight\n        if (flexibleFits.length) {\n            let bestFit = null;\n            let bestScore = -1;\n            for (const fit of flexibleFits) {\n                const score = fit.boundingBoxRect.width * fit.boundingBoxRect.height * (fit.position.weight || 1);\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestFit = fit;\n                }\n            }\n            this._isPushed = false;\n            this._applyPosition(bestFit.position, bestFit.origin);\n            return;\n        }\n        // When none of the preferred positions fit within the viewport, take the position\n        // that went off-screen the least and attempt to push it on-screen.\n        if (this._canPush) {\n            // TODO(jelbourn): after pushing, the opening \"direction\" of the overlay might not make sense.\n            this._isPushed = true;\n            this._applyPosition(fallback.position, fallback.originPoint);\n            return;\n        }\n        // All options for getting the overlay within the viewport have been exhausted, so go with the\n        // position that went off-screen the least.\n        this._applyPosition(fallback.position, fallback.originPoint);\n    }\n    detach() {\n        this._clearPanelClasses();\n        this._lastPosition = null;\n        this._previousPushAmount = null;\n        this._resizeSubscription.unsubscribe();\n    }\n    /** Cleanup after the element gets destroyed. */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        // We can't use `_resetBoundingBoxStyles` here, because it resets\n        // some properties to zero, rather than removing them.\n        if (this._boundingBox) {\n            extendStyles(this._boundingBox.style, {\n                top: '',\n                left: '',\n                right: '',\n                bottom: '',\n                height: '',\n                width: '',\n                alignItems: '',\n                justifyContent: '',\n            });\n        }\n        if (this._pane) {\n            this._resetOverlayElementStyles();\n        }\n        if (this._overlayRef) {\n            this._overlayRef.hostElement.classList.remove(boundingBoxClass);\n        }\n        this.detach();\n        this._positionChanges.complete();\n        this._overlayRef = this._boundingBox = null;\n        this._isDisposed = true;\n    }\n    /**\n     * This re-aligns the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    reapplyLastPosition() {\n        if (!this._isDisposed && (!this._platform || this._platform.isBrowser)) {\n            this._originRect = this._getOriginRect();\n            this._overlayRect = this._pane.getBoundingClientRect();\n            this._viewportRect = this._getNarrowedViewportRect();\n            const lastPosition = this._lastPosition || this._preferredPositions[0];\n            const originPoint = this._getOriginPoint(this._originRect, lastPosition);\n            this._applyPosition(lastPosition, originPoint);\n        }\n    }\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    withScrollableContainers(scrollables) {\n        this._scrollables = scrollables;\n        return this;\n    }\n    /**\n     * Adds new preferred positions.\n     * @param positions List of positions options for this overlay.\n     */\n    withPositions(positions) {\n        this._preferredPositions = positions;\n        // If the last calculated position object isn't part of the positions anymore, clear\n        // it in order to avoid it being picked up if the consumer tries to re-apply.\n        if (positions.indexOf(this._lastPosition) === -1) {\n            this._lastPosition = null;\n        }\n        this._validatePositions();\n        return this;\n    }\n    /**\n     * Sets a minimum distance the overlay may be positioned to the edge of the viewport.\n     * @param margin Required margin between the overlay and the viewport edge in pixels.\n     */\n    withViewportMargin(margin) {\n        this._viewportMargin = margin;\n        return this;\n    }\n    /** Sets whether the overlay's width and height can be constrained to fit within the viewport. */\n    withFlexibleDimensions(flexibleDimensions = true) {\n        this._hasFlexibleDimensions = flexibleDimensions;\n        return this;\n    }\n    /** Sets whether the overlay can grow after the initial open via flexible width/height. */\n    withGrowAfterOpen(growAfterOpen = true) {\n        this._growAfterOpen = growAfterOpen;\n        return this;\n    }\n    /** Sets whether the overlay can be pushed on-screen if none of the provided positions fit. */\n    withPush(canPush = true) {\n        this._canPush = canPush;\n        return this;\n    }\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    withLockedPosition(isLocked = true) {\n        this._positionLocked = isLocked;\n        return this;\n    }\n    /**\n     * Sets the origin, relative to which to position the overlay.\n     * Using an element origin is useful for building components that need to be positioned\n     * relatively to a trigger (e.g. dropdown menus or tooltips), whereas using a point can be\n     * used for cases like contextual menus which open relative to the user's pointer.\n     * @param origin Reference to the new origin.\n     */\n    setOrigin(origin) {\n        this._origin = origin;\n        return this;\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the x-axis.\n     * @param offset New offset in the X axis.\n     */\n    withDefaultOffsetX(offset) {\n        this._offsetX = offset;\n        return this;\n    }\n    /**\n     * Sets the default offset for the overlay's connection point on the y-axis.\n     * @param offset New offset in the Y axis.\n     */\n    withDefaultOffsetY(offset) {\n        this._offsetY = offset;\n        return this;\n    }\n    /**\n     * Configures that the position strategy should set a `transform-origin` on some elements\n     * inside the overlay, depending on the current position that is being applied. This is\n     * useful for the cases where the origin of an animation can change depending on the\n     * alignment of the overlay.\n     * @param selector CSS selector that will be used to find the target\n     *    elements onto which to set the transform origin.\n     */\n    withTransformOriginOn(selector) {\n        this._transformOriginSelector = selector;\n        return this;\n    }\n    /**\n     * Gets the (x, y) coordinate of a connection point on the origin based on a relative position.\n     */\n    _getOriginPoint(originRect, pos) {\n        let x;\n        if (pos.originX == 'center') {\n            // Note: when centering we should always use the `left`\n            // offset, otherwise the position will be wrong in RTL.\n            x = originRect.left + (originRect.width / 2);\n        }\n        else {\n            const startX = this._isRtl() ? originRect.right : originRect.left;\n            const endX = this._isRtl() ? originRect.left : originRect.right;\n            x = pos.originX == 'start' ? startX : endX;\n        }\n        let y;\n        if (pos.originY == 'center') {\n            y = originRect.top + (originRect.height / 2);\n        }\n        else {\n            y = pos.originY == 'top' ? originRect.top : originRect.bottom;\n        }\n        return { x, y };\n    }\n    /**\n     * Gets the (x, y) coordinate of the top-left corner of the overlay given a given position and\n     * origin point to which the overlay should be connected.\n     */\n    _getOverlayPoint(originPoint, overlayRect, pos) {\n        // Calculate the (overlayStartX, overlayStartY), the start of the\n        // potential overlay position relative to the origin point.\n        let overlayStartX;\n        if (pos.overlayX == 'center') {\n            overlayStartX = -overlayRect.width / 2;\n        }\n        else if (pos.overlayX === 'start') {\n            overlayStartX = this._isRtl() ? -overlayRect.width : 0;\n        }\n        else {\n            overlayStartX = this._isRtl() ? 0 : -overlayRect.width;\n        }\n        let overlayStartY;\n        if (pos.overlayY == 'center') {\n            overlayStartY = -overlayRect.height / 2;\n        }\n        else {\n            overlayStartY = pos.overlayY == 'top' ? 0 : -overlayRect.height;\n        }\n        // The (x, y) coordinates of the overlay.\n        return {\n            x: originPoint.x + overlayStartX,\n            y: originPoint.y + overlayStartY,\n        };\n    }\n    /** Gets how well an overlay at the given point will fit within the viewport. */\n    _getOverlayFit(point, rawOverlayRect, viewport, position) {\n        // Round the overlay rect when comparing against the\n        // viewport, because the viewport is always rounded.\n        const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n        let { x, y } = point;\n        let offsetX = this._getOffset(position, 'x');\n        let offsetY = this._getOffset(position, 'y');\n        // Account for the offsets since they could push the overlay out of the viewport.\n        if (offsetX) {\n            x += offsetX;\n        }\n        if (offsetY) {\n            y += offsetY;\n        }\n        // How much the overlay would overflow at this position, on each side.\n        let leftOverflow = 0 - x;\n        let rightOverflow = (x + overlay.width) - viewport.width;\n        let topOverflow = 0 - y;\n        let bottomOverflow = (y + overlay.height) - viewport.height;\n        // Visible parts of the element on each axis.\n        let visibleWidth = this._subtractOverflows(overlay.width, leftOverflow, rightOverflow);\n        let visibleHeight = this._subtractOverflows(overlay.height, topOverflow, bottomOverflow);\n        let visibleArea = visibleWidth * visibleHeight;\n        return {\n            visibleArea,\n            isCompletelyWithinViewport: (overlay.width * overlay.height) === visibleArea,\n            fitsInViewportVertically: visibleHeight === overlay.height,\n            fitsInViewportHorizontally: visibleWidth == overlay.width,\n        };\n    }\n    /**\n     * Whether the overlay can fit within the viewport when it may resize either its width or height.\n     * @param fit How well the overlay fits in the viewport at some position.\n     * @param point The (x, y) coordinates of the overlat at some position.\n     * @param viewport The geometry of the viewport.\n     */\n    _canFitWithFlexibleDimensions(fit, point, viewport) {\n        if (this._hasFlexibleDimensions) {\n            const availableHeight = viewport.bottom - point.y;\n            const availableWidth = viewport.right - point.x;\n            const minHeight = getPixelValue(this._overlayRef.getConfig().minHeight);\n            const minWidth = getPixelValue(this._overlayRef.getConfig().minWidth);\n            const verticalFit = fit.fitsInViewportVertically ||\n                (minHeight != null && minHeight <= availableHeight);\n            const horizontalFit = fit.fitsInViewportHorizontally ||\n                (minWidth != null && minWidth <= availableWidth);\n            return verticalFit && horizontalFit;\n        }\n        return false;\n    }\n    /**\n     * Gets the point at which the overlay can be \"pushed\" on-screen. If the overlay is larger than\n     * the viewport, the top-left corner will be pushed on-screen (with overflow occuring on the\n     * right and bottom).\n     *\n     * @param start Starting point from which the overlay is pushed.\n     * @param overlay Dimensions of the overlay.\n     * @param scrollPosition Current viewport scroll position.\n     * @returns The point at which to position the overlay after pushing. This is effectively a new\n     *     originPoint.\n     */\n    _pushOverlayOnScreen(start, rawOverlayRect, scrollPosition) {\n        // If the position is locked and we've pushed the overlay already, reuse the previous push\n        // amount, rather than pushing it again. If we were to continue pushing, the element would\n        // remain in the viewport, which goes against the expectations when position locking is enabled.\n        if (this._previousPushAmount && this._positionLocked) {\n            return {\n                x: start.x + this._previousPushAmount.x,\n                y: start.y + this._previousPushAmount.y\n            };\n        }\n        // Round the overlay rect when comparing against the\n        // viewport, because the viewport is always rounded.\n        const overlay = getRoundedBoundingClientRect(rawOverlayRect);\n        const viewport = this._viewportRect;\n        // Determine how much the overlay goes outside the viewport on each\n        // side, which we'll use to decide which direction to push it.\n        const overflowRight = Math.max(start.x + overlay.width - viewport.width, 0);\n        const overflowBottom = Math.max(start.y + overlay.height - viewport.height, 0);\n        const overflowTop = Math.max(viewport.top - scrollPosition.top - start.y, 0);\n        const overflowLeft = Math.max(viewport.left - scrollPosition.left - start.x, 0);\n        // Amount by which to push the overlay in each axis such that it remains on-screen.\n        let pushX = 0;\n        let pushY = 0;\n        // If the overlay fits completely within the bounds of the viewport, push it from whichever\n        // direction is goes off-screen. Otherwise, push the top-left corner such that its in the\n        // viewport and allow for the trailing end of the overlay to go out of bounds.\n        if (overlay.width <= viewport.width) {\n            pushX = overflowLeft || -overflowRight;\n        }\n        else {\n            pushX = start.x < this._viewportMargin ? (viewport.left - scrollPosition.left) - start.x : 0;\n        }\n        if (overlay.height <= viewport.height) {\n            pushY = overflowTop || -overflowBottom;\n        }\n        else {\n            pushY = start.y < this._viewportMargin ? (viewport.top - scrollPosition.top) - start.y : 0;\n        }\n        this._previousPushAmount = { x: pushX, y: pushY };\n        return {\n            x: start.x + pushX,\n            y: start.y + pushY,\n        };\n    }\n    /**\n     * Applies a computed position to the overlay and emits a position change.\n     * @param position The position preference\n     * @param originPoint The point on the origin element where the overlay is connected.\n     */\n    _applyPosition(position, originPoint) {\n        this._setTransformOrigin(position);\n        this._setOverlayElementStyles(originPoint, position);\n        this._setBoundingBoxStyles(originPoint, position);\n        if (position.panelClass) {\n            this._addPanelClasses(position.panelClass);\n        }\n        // Save the last connected position in case the position needs to be re-calculated.\n        this._lastPosition = position;\n        // Notify that the position has been changed along with its change properties.\n        // We only emit if we've got any subscriptions, because the scroll visibility\n        // calculcations can be somewhat expensive.\n        if (this._positionChanges.observers.length) {\n            const scrollableViewProperties = this._getScrollVisibility();\n            const changeEvent = new ConnectedOverlayPositionChange(position, scrollableViewProperties);\n            this._positionChanges.next(changeEvent);\n        }\n        this._isInitialRender = false;\n    }\n    /** Sets the transform origin based on the configured selector and the passed-in position.  */\n    _setTransformOrigin(position) {\n        if (!this._transformOriginSelector) {\n            return;\n        }\n        const elements = this._boundingBox.querySelectorAll(this._transformOriginSelector);\n        let xOrigin;\n        let yOrigin = position.overlayY;\n        if (position.overlayX === 'center') {\n            xOrigin = 'center';\n        }\n        else if (this._isRtl()) {\n            xOrigin = position.overlayX === 'start' ? 'right' : 'left';\n        }\n        else {\n            xOrigin = position.overlayX === 'start' ? 'left' : 'right';\n        }\n        for (let i = 0; i < elements.length; i++) {\n            elements[i].style.transformOrigin = `${xOrigin} ${yOrigin}`;\n        }\n    }\n    /**\n     * Gets the position and size of the overlay's sizing container.\n     *\n     * This method does no measuring and applies no styles so that we can cheaply compute the\n     * bounds for all positions and choose the best fit based on these results.\n     */\n    _calculateBoundingBoxRect(origin, position) {\n        const viewport = this._viewportRect;\n        const isRtl = this._isRtl();\n        let height, top, bottom;\n        if (position.overlayY === 'top') {\n            // Overlay is opening \"downward\" and thus is bound by the bottom viewport edge.\n            top = origin.y;\n            height = viewport.height - top + this._viewportMargin;\n        }\n        else if (position.overlayY === 'bottom') {\n            // Overlay is opening \"upward\" and thus is bound by the top viewport edge. We need to add\n            // the viewport margin back in, because the viewport rect is narrowed down to remove the\n            // margin, whereas the `origin` position is calculated based on its `ClientRect`.\n            bottom = viewport.height - origin.y + this._viewportMargin * 2;\n            height = viewport.height - bottom + this._viewportMargin;\n        }\n        else {\n            // If neither top nor bottom, it means that the overlay is vertically centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.bottom - origin.y` and\n            // `origin.y - viewport.top`.\n            const smallestDistanceToViewportEdge = Math.min(viewport.bottom - origin.y + viewport.top, origin.y);\n            const previousHeight = this._lastBoundingBoxSize.height;\n            height = smallestDistanceToViewportEdge * 2;\n            top = origin.y - smallestDistanceToViewportEdge;\n            if (height > previousHeight && !this._isInitialRender && !this._growAfterOpen) {\n                top = origin.y - (previousHeight / 2);\n            }\n        }\n        // The overlay is opening 'right-ward' (the content flows to the right).\n        const isBoundedByRightViewportEdge = (position.overlayX === 'start' && !isRtl) ||\n            (position.overlayX === 'end' && isRtl);\n        // The overlay is opening 'left-ward' (the content flows to the left).\n        const isBoundedByLeftViewportEdge = (position.overlayX === 'end' && !isRtl) ||\n            (position.overlayX === 'start' && isRtl);\n        let width, left, right;\n        if (isBoundedByLeftViewportEdge) {\n            right = viewport.width - origin.x + this._viewportMargin;\n            width = origin.x - this._viewportMargin;\n        }\n        else if (isBoundedByRightViewportEdge) {\n            left = origin.x;\n            width = viewport.right - origin.x;\n        }\n        else {\n            // If neither start nor end, it means that the overlay is horizontally centered on the\n            // origin point. Note that we want the position relative to the viewport, rather than\n            // the page, which is why we don't use something like `viewport.right - origin.x` and\n            // `origin.x - viewport.left`.\n            const smallestDistanceToViewportEdge = Math.min(viewport.right - origin.x + viewport.left, origin.x);\n            const previousWidth = this._lastBoundingBoxSize.width;\n            width = smallestDistanceToViewportEdge * 2;\n            left = origin.x - smallestDistanceToViewportEdge;\n            if (width > previousWidth && !this._isInitialRender && !this._growAfterOpen) {\n                left = origin.x - (previousWidth / 2);\n            }\n        }\n        return { top: top, left: left, bottom: bottom, right: right, width, height };\n    }\n    /**\n     * Sets the position and size of the overlay's sizing wrapper. The wrapper is positioned on the\n     * origin's connection point and stetches to the bounds of the viewport.\n     *\n     * @param origin The point on the origin element where the overlay is connected.\n     * @param position The position preference\n     */\n    _setBoundingBoxStyles(origin, position) {\n        const boundingBoxRect = this._calculateBoundingBoxRect(origin, position);\n        // It's weird if the overlay *grows* while scrolling, so we take the last size into account\n        // when applying a new size.\n        if (!this._isInitialRender && !this._growAfterOpen) {\n            boundingBoxRect.height = Math.min(boundingBoxRect.height, this._lastBoundingBoxSize.height);\n            boundingBoxRect.width = Math.min(boundingBoxRect.width, this._lastBoundingBoxSize.width);\n        }\n        const styles = {};\n        if (this._hasExactPosition()) {\n            styles.top = styles.left = '0';\n            styles.bottom = styles.right = styles.maxHeight = styles.maxWidth = '';\n            styles.width = styles.height = '100%';\n        }\n        else {\n            const maxHeight = this._overlayRef.getConfig().maxHeight;\n            const maxWidth = this._overlayRef.getConfig().maxWidth;\n            styles.height = coerceCssPixelValue(boundingBoxRect.height);\n            styles.top = coerceCssPixelValue(boundingBoxRect.top);\n            styles.bottom = coerceCssPixelValue(boundingBoxRect.bottom);\n            styles.width = coerceCssPixelValue(boundingBoxRect.width);\n            styles.left = coerceCssPixelValue(boundingBoxRect.left);\n            styles.right = coerceCssPixelValue(boundingBoxRect.right);\n            // Push the pane content towards the proper direction.\n            if (position.overlayX === 'center') {\n                styles.alignItems = 'center';\n            }\n            else {\n                styles.alignItems = position.overlayX === 'end' ? 'flex-end' : 'flex-start';\n            }\n            if (position.overlayY === 'center') {\n                styles.justifyContent = 'center';\n            }\n            else {\n                styles.justifyContent = position.overlayY === 'bottom' ? 'flex-end' : 'flex-start';\n            }\n            if (maxHeight) {\n                styles.maxHeight = coerceCssPixelValue(maxHeight);\n            }\n            if (maxWidth) {\n                styles.maxWidth = coerceCssPixelValue(maxWidth);\n            }\n        }\n        this._lastBoundingBoxSize = boundingBoxRect;\n        extendStyles(this._boundingBox.style, styles);\n    }\n    /** Resets the styles for the bounding box so that a new positioning can be computed. */\n    _resetBoundingBoxStyles() {\n        extendStyles(this._boundingBox.style, {\n            top: '0',\n            left: '0',\n            right: '0',\n            bottom: '0',\n            height: '',\n            width: '',\n            alignItems: '',\n            justifyContent: '',\n        });\n    }\n    /** Resets the styles for the overlay pane so that a new positioning can be computed. */\n    _resetOverlayElementStyles() {\n        extendStyles(this._pane.style, {\n            top: '',\n            left: '',\n            bottom: '',\n            right: '',\n            position: '',\n            transform: '',\n        });\n    }\n    /** Sets positioning styles to the overlay element. */\n    _setOverlayElementStyles(originPoint, position) {\n        const styles = {};\n        const hasExactPosition = this._hasExactPosition();\n        const hasFlexibleDimensions = this._hasFlexibleDimensions;\n        const config = this._overlayRef.getConfig();\n        if (hasExactPosition) {\n            const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n            extendStyles(styles, this._getExactOverlayY(position, originPoint, scrollPosition));\n            extendStyles(styles, this._getExactOverlayX(position, originPoint, scrollPosition));\n        }\n        else {\n            styles.position = 'static';\n        }\n        // Use a transform to apply the offsets. We do this because the `center` positions rely on\n        // being in the normal flex flow and setting a `top` / `left` at all will completely throw\n        // off the position. We also can't use margins, because they won't have an effect in some\n        // cases where the element doesn't have anything to \"push off of\". Finally, this works\n        // better both with flexible and non-flexible positioning.\n        let transformString = '';\n        let offsetX = this._getOffset(position, 'x');\n        let offsetY = this._getOffset(position, 'y');\n        if (offsetX) {\n            transformString += `translateX(${offsetX}px) `;\n        }\n        if (offsetY) {\n            transformString += `translateY(${offsetY}px)`;\n        }\n        styles.transform = transformString.trim();\n        // If a maxWidth or maxHeight is specified on the overlay, we remove them. We do this because\n        // we need these values to both be set to \"100%\" for the automatic flexible sizing to work.\n        // The maxHeight and maxWidth are set on the boundingBox in order to enforce the constraint.\n        // Note that this doesn't apply when we have an exact position, in which case we do want to\n        // apply them because they'll be cleared from the bounding box.\n        if (config.maxHeight) {\n            if (hasExactPosition) {\n                styles.maxHeight = coerceCssPixelValue(config.maxHeight);\n            }\n            else if (hasFlexibleDimensions) {\n                styles.maxHeight = '';\n            }\n        }\n        if (config.maxWidth) {\n            if (hasExactPosition) {\n                styles.maxWidth = coerceCssPixelValue(config.maxWidth);\n            }\n            else if (hasFlexibleDimensions) {\n                styles.maxWidth = '';\n            }\n        }\n        extendStyles(this._pane.style, styles);\n    }\n    /** Gets the exact top/bottom for the overlay when not using flexible sizing or when pushing. */\n    _getExactOverlayY(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the\n        // preferred position has changed since the last `apply`.\n        let styles = { top: '', bottom: '' };\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        let virtualKeyboardOffset = this._overlayContainer.getContainerElement().getBoundingClientRect().top;\n        // Normally this would be zero, however when the overlay is attached to an input (e.g. in an\n        // autocomplete), mobile browsers will shift everything in order to put the input in the middle\n        // of the screen and to make space for the virtual keyboard. We need to account for this offset,\n        // otherwise our positioning will be thrown off.\n        overlayPoint.y -= virtualKeyboardOffset;\n        // We want to set either `top` or `bottom` based on whether the overlay wants to appear\n        // above or below the origin and the direction in which the element will expand.\n        if (position.overlayY === 'bottom') {\n            // When using `bottom`, we adjust the y position such that it is the distance\n            // from the bottom of the viewport rather than the top.\n            const documentHeight = this._document.documentElement.clientHeight;\n            styles.bottom = `${documentHeight - (overlayPoint.y + this._overlayRect.height)}px`;\n        }\n        else {\n            styles.top = coerceCssPixelValue(overlayPoint.y);\n        }\n        return styles;\n    }\n    /** Gets the exact left/right for the overlay when not using flexible sizing or when pushing. */\n    _getExactOverlayX(position, originPoint, scrollPosition) {\n        // Reset any existing styles. This is necessary in case the preferred position has\n        // changed since the last `apply`.\n        let styles = { left: '', right: '' };\n        let overlayPoint = this._getOverlayPoint(originPoint, this._overlayRect, position);\n        if (this._isPushed) {\n            overlayPoint = this._pushOverlayOnScreen(overlayPoint, this._overlayRect, scrollPosition);\n        }\n        // We want to set either `left` or `right` based on whether the overlay wants to appear \"before\"\n        // or \"after\" the origin, which determines the direction in which the element will expand.\n        // For the horizontal axis, the meaning of \"before\" and \"after\" change based on whether the\n        // page is in RTL or LTR.\n        let horizontalStyleProperty;\n        if (this._isRtl()) {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'left' : 'right';\n        }\n        else {\n            horizontalStyleProperty = position.overlayX === 'end' ? 'right' : 'left';\n        }\n        // When we're setting `right`, we adjust the x position such that it is the distance\n        // from the right edge of the viewport rather than the left edge.\n        if (horizontalStyleProperty === 'right') {\n            const documentWidth = this._document.documentElement.clientWidth;\n            styles.right = `${documentWidth - (overlayPoint.x + this._overlayRect.width)}px`;\n        }\n        else {\n            styles.left = coerceCssPixelValue(overlayPoint.x);\n        }\n        return styles;\n    }\n    /**\n     * Gets the view properties of the trigger and overlay, including whether they are clipped\n     * or completely outside the view of any of the strategy's scrollables.\n     */\n    _getScrollVisibility() {\n        // Note: needs fresh rects since the position could've changed.\n        const originBounds = this._getOriginRect();\n        const overlayBounds = this._pane.getBoundingClientRect();\n        // TODO(jelbourn): instead of needing all of the client rects for these scrolling containers\n        // every time, we should be able to use the scrollTop of the containers if the size of those\n        // containers hasn't changed.\n        const scrollContainerBounds = this._scrollables.map(scrollable => {\n            return scrollable.getElementRef().nativeElement.getBoundingClientRect();\n        });\n        return {\n            isOriginClipped: isElementClippedByScrolling(originBounds, scrollContainerBounds),\n            isOriginOutsideView: isElementScrolledOutsideView(originBounds, scrollContainerBounds),\n            isOverlayClipped: isElementClippedByScrolling(overlayBounds, scrollContainerBounds),\n            isOverlayOutsideView: isElementScrolledOutsideView(overlayBounds, scrollContainerBounds),\n        };\n    }\n    /** Subtracts the amount that an element is overflowing on an axis from its length. */\n    _subtractOverflows(length, ...overflows) {\n        return overflows.reduce((currentValue, currentOverflow) => {\n            return currentValue - Math.max(currentOverflow, 0);\n        }, length);\n    }\n    /** Narrows the given viewport rect by the current _viewportMargin. */\n    _getNarrowedViewportRect() {\n        // We recalculate the viewport rect here ourselves, rather than using the ViewportRuler,\n        // because we want to use the `clientWidth` and `clientHeight` as the base. The difference\n        // being that the client properties don't include the scrollbar, as opposed to `innerWidth`\n        // and `innerHeight` that do. This is necessary, because the overlay container uses\n        // 100% `width` and `height` which don't include the scrollbar either.\n        const width = this._document.documentElement.clientWidth;\n        const height = this._document.documentElement.clientHeight;\n        const scrollPosition = this._viewportRuler.getViewportScrollPosition();\n        return {\n            top: scrollPosition.top + this._viewportMargin,\n            left: scrollPosition.left + this._viewportMargin,\n            right: scrollPosition.left + width - this._viewportMargin,\n            bottom: scrollPosition.top + height - this._viewportMargin,\n            width: width - (2 * this._viewportMargin),\n            height: height - (2 * this._viewportMargin),\n        };\n    }\n    /** Whether the we're dealing with an RTL context */\n    _isRtl() {\n        return this._overlayRef.getDirection() === 'rtl';\n    }\n    /** Determines whether the overlay uses exact or flexible positioning. */\n    _hasExactPosition() {\n        return !this._hasFlexibleDimensions || this._isPushed;\n    }\n    /** Retrieves the offset of a position along the x or y axis. */\n    _getOffset(position, axis) {\n        if (axis === 'x') {\n            // We don't do something like `position['offset' + axis]` in\n            // order to avoid breking minifiers that rename properties.\n            return position.offsetX == null ? this._offsetX : position.offsetX;\n        }\n        return position.offsetY == null ? this._offsetY : position.offsetY;\n    }\n    /** Validates that the current position match the expected values. */\n    _validatePositions() {\n        if (typeof ngDevMode === 'undefined' || ngDevMode) {\n            if (!this._preferredPositions.length) {\n                throw Error('FlexibleConnectedPositionStrategy: At least one position is required.');\n            }\n            // TODO(crisbeto): remove these once Angular's template type\n            // checking is advanced enough to catch these cases.\n            this._preferredPositions.forEach(pair => {\n                validateHorizontalPosition('originX', pair.originX);\n                validateVerticalPosition('originY', pair.originY);\n                validateHorizontalPosition('overlayX', pair.overlayX);\n                validateVerticalPosition('overlayY', pair.overlayY);\n            });\n        }\n    }\n    /** Adds a single CSS class or an array of classes on the overlay panel. */\n    _addPanelClasses(cssClasses) {\n        if (this._pane) {\n            coerceArray(cssClasses).forEach(cssClass => {\n                if (cssClass !== '' && this._appliedPanelClasses.indexOf(cssClass) === -1) {\n                    this._appliedPanelClasses.push(cssClass);\n                    this._pane.classList.add(cssClass);\n                }\n            });\n        }\n    }\n    /** Clears the classes that the position strategy has applied from the overlay panel. */\n    _clearPanelClasses() {\n        if (this._pane) {\n            this._appliedPanelClasses.forEach(cssClass => {\n                this._pane.classList.remove(cssClass);\n            });\n            this._appliedPanelClasses = [];\n        }\n    }\n    /** Returns the ClientRect of the current origin. */\n    _getOriginRect() {\n        const origin = this._origin;\n        if (origin instanceof core[\"l\" /* ElementRef */]) {\n            return origin.nativeElement.getBoundingClientRect();\n        }\n        // Check for Element so SVG elements are also supported.\n        if (origin instanceof Element) {\n            return origin.getBoundingClientRect();\n        }\n        const width = origin.width || 0;\n        const height = origin.height || 0;\n        // If the origin is a point, return a client rect as if it was a 0x0 element at the point.\n        return {\n            top: origin.y,\n            bottom: origin.y + height,\n            left: origin.x,\n            right: origin.x + width,\n            height,\n            width\n        };\n    }\n}\n/** Shallow-extends a stylesheet object with another stylesheet object. */\nfunction extendStyles(destination, source) {\n    for (let key in source) {\n        if (source.hasOwnProperty(key)) {\n            destination[key] = source[key];\n        }\n    }\n    return destination;\n}\n/**\n * Extracts the pixel value as a number from a value, if it's a number\n * or a CSS pixel string (e.g. `1337px`). Otherwise returns null.\n */\nfunction getPixelValue(input) {\n    if (typeof input !== 'number' && input != null) {\n        const [value, units] = input.split(cssUnitPattern);\n        return (!units || units === 'px') ? parseFloat(value) : null;\n    }\n    return input || null;\n}\n/**\n * Gets a version of an element's bounding `ClientRect` where all the values are rounded down to\n * the nearest pixel. This allows us to account for the cases where there may be sub-pixel\n * deviations in the `ClientRect` returned by the browser (e.g. when zoomed in with a percentage\n * size, see #21350).\n */\nfunction getRoundedBoundingClientRect(clientRect) {\n    return {\n        top: Math.floor(clientRect.top),\n        right: Math.floor(clientRect.right),\n        bottom: Math.floor(clientRect.bottom),\n        left: Math.floor(clientRect.left),\n        width: Math.floor(clientRect.width),\n        height: Math.floor(clientRect.height)\n    };\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * implicit position relative to some origin element. The relative position is defined in terms of\n * a point on the origin element that is connected to a point on the overlay element. For example,\n * a basic dropdown is connecting the bottom-left corner of the origin to the top-left corner\n * of the overlay.\n * @deprecated Use `FlexibleConnectedPositionStrategy` instead.\n * @breaking-change 8.0.0\n */\nclass ConnectedPositionStrategy {\n    constructor(originPos, overlayPos, connectedTo, viewportRuler, document, platform, overlayContainer) {\n        /** Ordered list of preferred positions, from most to least desirable. */\n        this._preferredPositions = [];\n        // Since the `ConnectedPositionStrategy` is deprecated and we don't want to maintain\n        // the extra logic, we create an instance of the positioning strategy that has some\n        // defaults that make it behave as the old position strategy and to which we'll\n        // proxy all of the API calls.\n        this._positionStrategy = new overlay_FlexibleConnectedPositionStrategy(connectedTo, viewportRuler, document, platform, overlayContainer)\n            .withFlexibleDimensions(false)\n            .withPush(false)\n            .withViewportMargin(0);\n        this.withFallbackPosition(originPos, overlayPos);\n        this.onPositionChange = this._positionStrategy.positionChanges;\n    }\n    /** Ordered list of preferred positions, from most to least desirable. */\n    get positions() {\n        return this._preferredPositions;\n    }\n    /** Attach this position strategy to an overlay. */\n    attach(overlayRef) {\n        this._overlayRef = overlayRef;\n        this._positionStrategy.attach(overlayRef);\n        if (this._direction) {\n            overlayRef.setDirection(this._direction);\n            this._direction = null;\n        }\n    }\n    /** Disposes all resources used by the position strategy. */\n    dispose() {\n        this._positionStrategy.dispose();\n    }\n    /** @docs-private */\n    detach() {\n        this._positionStrategy.detach();\n    }\n    /**\n     * Updates the position of the overlay element, using whichever preferred position relative\n     * to the origin fits on-screen.\n     * @docs-private\n     */\n    apply() {\n        this._positionStrategy.apply();\n    }\n    /**\n     * Re-positions the overlay element with the trigger in its last calculated position,\n     * even if a position higher in the \"preferred positions\" list would now fit. This\n     * allows one to re-align the panel without changing the orientation of the panel.\n     */\n    recalculateLastPosition() {\n        this._positionStrategy.reapplyLastPosition();\n    }\n    /**\n     * Sets the list of Scrollable containers that host the origin element so that\n     * on reposition we can evaluate if it or the overlay has been clipped or outside view. Every\n     * Scrollable must be an ancestor element of the strategy's origin element.\n     */\n    withScrollableContainers(scrollables) {\n        this._positionStrategy.withScrollableContainers(scrollables);\n    }\n    /**\n     * Adds a new preferred fallback position.\n     * @param originPos\n     * @param overlayPos\n     */\n    withFallbackPosition(originPos, overlayPos, offsetX, offsetY) {\n        const position = new ConnectionPositionPair(originPos, overlayPos, offsetX, offsetY);\n        this._preferredPositions.push(position);\n        this._positionStrategy.withPositions(this._preferredPositions);\n        return this;\n    }\n    /**\n     * Sets the layout direction so the overlay's position can be adjusted to match.\n     * @param dir New layout direction.\n     */\n    withDirection(dir) {\n        // Since the direction might be declared before the strategy is attached,\n        // we save the value in a temporary property and we'll transfer it to the\n        // overlay ref on attachment.\n        if (this._overlayRef) {\n            this._overlayRef.setDirection(dir);\n        }\n        else {\n            this._direction = dir;\n        }\n        return this;\n    }\n    /**\n     * Sets an offset for the overlay's connection point on the x-axis\n     * @param offset New offset in the X axis.\n     */\n    withOffsetX(offset) {\n        this._positionStrategy.withDefaultOffsetX(offset);\n        return this;\n    }\n    /**\n     * Sets an offset for the overlay's connection point on the y-axis\n     * @param  offset New offset in the Y axis.\n     */\n    withOffsetY(offset) {\n        this._positionStrategy.withDefaultOffsetY(offset);\n        return this;\n    }\n    /**\n     * Sets whether the overlay's position should be locked in after it is positioned\n     * initially. When an overlay is locked in, it won't attempt to reposition itself\n     * when the position is re-applied (e.g. when the user scrolls away).\n     * @param isLocked Whether the overlay should locked in.\n     */\n    withLockedPosition(isLocked) {\n        this._positionStrategy.withLockedPosition(isLocked);\n        return this;\n    }\n    /**\n     * Overwrites the current set of positions with an array of new ones.\n     * @param positions Position pairs to be set on the strategy.\n     */\n    withPositions(positions) {\n        this._preferredPositions = positions.slice();\n        this._positionStrategy.withPositions(this._preferredPositions);\n        return this;\n    }\n    /**\n     * Sets the origin element, relative to which to position the overlay.\n     * @param origin Reference to the new origin element.\n     */\n    setOrigin(origin) {\n        this._positionStrategy.setOrigin(origin);\n        return this;\n    }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Class to be added to the overlay pane wrapper. */\nconst wrapperClass = 'cdk-global-overlay-wrapper';\n/**\n * A strategy for positioning overlays. Using this strategy, an overlay is given an\n * explicit position relative to the browser's viewport. We use flexbox, instead of\n * transforms, in order to avoid issues with subpixel rendering which can cause the\n * element to become blurry.\n */\nclass GlobalPositionStrategy {\n    constructor() {\n        this._cssPosition = 'static';\n        this._topOffset = '';\n        this._bottomOffset = '';\n        this._leftOffset = '';\n        this._rightOffset = '';\n        this._alignItems = '';\n        this._justifyContent = '';\n        this._width = '';\n        this._height = '';\n    }\n    attach(overlayRef) {\n        const config = overlayRef.getConfig();\n        this._overlayRef = overlayRef;\n        if (this._width && !config.width) {\n            overlayRef.updateSize({ width: this._width });\n        }\n        if (this._height && !config.height) {\n            overlayRef.updateSize({ height: this._height });\n        }\n        overlayRef.hostElement.classList.add(wrapperClass);\n        this._isDisposed = false;\n    }\n    /**\n     * Sets the top position of the overlay. Clears any previously set vertical position.\n     * @param value New top offset.\n     */\n    top(value = '') {\n        this._bottomOffset = '';\n        this._topOffset = value;\n        this._alignItems = 'flex-start';\n        return this;\n    }\n    /**\n     * Sets the left position of the overlay. Clears any previously set horizontal position.\n     * @param value New left offset.\n     */\n    left(value = '') {\n        this._rightOffset = '';\n        this._leftOffset = value;\n        this._justifyContent = 'flex-start';\n        return this;\n    }\n    /**\n     * Sets the bottom position of the overlay. Clears any previously set vertical position.\n     * @param value New bottom offset.\n     */\n    bottom(value = '') {\n        this._topOffset = '';\n        this._bottomOffset = value;\n        this._alignItems = 'flex-end';\n        return this;\n    }\n    /**\n     * Sets the right position of the overlay. Clears any previously set horizontal position.\n     * @param value New right offset.\n     */\n    right(value = '') {\n        this._leftOffset = '';\n        this._rightOffset = value;\n        this._justifyContent = 'flex-end';\n        return this;\n    }\n    /**\n     * Sets the overlay width and clears any previously set width.\n     * @param value New width for the overlay\n     * @deprecated Pass the `width` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    width(value = '') {\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ width: value });\n        }\n        else {\n            this._width = value;\n        }\n        return this;\n    }\n    /**\n     * Sets the overlay height and clears any previously set height.\n     * @param value New height for the overlay\n     * @deprecated Pass the `height` through the `OverlayConfig`.\n     * @breaking-change 8.0.0\n     */\n    height(value = '') {\n        if (this._overlayRef) {\n            this._overlayRef.updateSize({ height: value });\n        }\n        else {\n            this._height = value;\n        }\n        return this;\n    }\n    /**\n     * Centers the overlay horizontally with an optional offset.\n     * Clears any previously set horizontal position.\n     *\n     * @param offset Overlay offset from the horizontal center.\n     */\n    centerHorizontally(offset = '') {\n        this.left(offset);\n        this._justifyContent = 'center';\n        return this;\n    }\n    /**\n     * Centers the overlay vertically with an optional offset.\n     * Clears any previously set vertical position.\n     *\n     * @param offset Overlay offset from the vertical center.\n     */\n    centerVertically(offset = '') {\n        this.top(offset);\n        this._alignItems = 'center';\n        return this;\n    }\n    /**\n     * Apply the position to the element.\n     * @docs-private\n     */\n    apply() {\n        // Since the overlay ref applies the strategy asynchronously, it could\n        // have been disposed before it ends up being applied. If that is the\n        // case, we shouldn't do anything.\n        if (!this._overlayRef || !this._overlayRef.hasAttached()) {\n            return;\n        }\n        const styles = this._overlayRef.overlayElement.style;\n        const parentStyles = this._overlayRef.hostElement.style;\n        const config = this._overlayRef.getConfig();\n        const { width, height, maxWidth, maxHeight } = config;\n        const shouldBeFlushHorizontally = (width === '100%' || width === '100vw') &&\n            (!maxWidth || maxWidth === '100%' || maxWidth === '100vw');\n        const shouldBeFlushVertically = (height === '100%' || height === '100vh') &&\n            (!maxHeight || maxHeight === '100%' || maxHeight === '100vh');\n        styles.position = this._cssPosition;\n        styles.marginLeft = shouldBeFlushHorizontally ? '0' : this._leftOffset;\n        styles.marginTop = shouldBeFlushVertically ? '0' : this._topOffset;\n        styles.marginBottom = this._bottomOffset;\n        styles.marginRight = this._rightOffset;\n        if (shouldBeFlushHorizontally) {\n            parentStyles.justifyContent = 'flex-start';\n        }\n        else if (this._justifyContent === 'center') {\n            parentStyles.justifyContent = 'center';\n        }\n        else if (this._overlayRef.getConfig().direction === 'rtl') {\n            // In RTL the browser will invert `flex-start` and `flex-end` automatically, but we\n            // don't want that because our positioning is explicitly `left` and `right`, hence\n            // why we do another inversion to ensure that the overlay stays in the same position.\n            // TODO: reconsider this if we add `start` and `end` methods.\n            if (this._justifyContent === 'flex-start') {\n                parentStyles.justifyContent = 'flex-end';\n            }\n            else if (this._justifyContent === 'flex-end') {\n                parentStyles.justifyContent = 'flex-start';\n            }\n        }\n        else {\n            parentStyles.justifyContent = this._justifyContent;\n        }\n        parentStyles.alignItems = shouldBeFlushVertically ? 'flex-start' : this._alignItems;\n    }\n    /**\n     * Cleans up the DOM changes from the position strategy.\n     * @docs-private\n     */\n    dispose() {\n        if (this._isDisposed || !this._overlayRef) {\n            return;\n        }\n        const styles = this._overlayRef.overlayElement.style;\n        const parent = this._overlayRef.hostElement;\n        const parentStyles = parent.style;\n        parent.classList.remove(wrapperClass);\n        parentStyles.justifyContent = parentStyles.alignItems = styles.marginTop =\n            styles.marginBottom = styles.marginLeft = styles.marginRight = styles.position = '';\n        this._overlayRef = null;\n        this._isDisposed = true;\n    }\n}\nlet overlay_OverlayPositionBuilder = /*@__PURE__*/ (() => {\n    class OverlayPositionBuilder {\n        constructor(_viewportRuler, _document, _platform, _overlayContainer) {\n            this._viewportRuler = _viewportRuler;\n            this._document = _document;\n            this._platform = _platform;\n            this._overlayContainer = _overlayContainer;\n        }\n        /**\n         * Creates a global position strategy.\n         */\n        global() {\n            return new GlobalPositionStrategy();\n        }\n        /**\n         * Creates a relative position strategy.\n         * @param elementRef\n         * @param originPos\n         * @param overlayPos\n         * @deprecated Use `flexibleConnectedTo` instead.\n         * @breaking-change 8.0.0\n         */\n        connectedTo(elementRef, originPos, overlayPos) {\n            return new ConnectedPositionStrategy(originPos, overlayPos, elementRef, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n        }\n        /**\n         * Creates a flexible position strategy.\n         * @param origin Origin relative to which to position the overlay.\n         */\n        flexibleConnectedTo(origin) {\n            return new overlay_FlexibleConnectedPositionStrategy(origin, this._viewportRuler, this._document, this._platform, this._overlayContainer);\n        }\n    }\n    OverlayPositionBuilder.fac = function OverlayPositionBuilder_Factory(t) { return new (t || OverlayPositionBuilder)(core[\"Wb\" /* inject */](scrolling_ViewportRuler), core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */]), core[\"Wb\" /* inject */](platform_Platform), core[\"Wb\" /* inject */](overlay_OverlayContainer)); };\n    OverlayPositionBuilder.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function OverlayPositionBuilder_Factory() { return new OverlayPositionBuilder(Object(core[\"Wb\" /* inject */])(scrolling_ViewportRuler), Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */]), Object(core[\"Wb\" /* inject */])(platform_Platform), Object(core[\"Wb\" /* inject */])(overlay_OverlayContainer)); }, token: OverlayPositionBuilder, providedIn: \"root\" });\n    return OverlayPositionBuilder;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Next overlay unique ID. */\nlet nextUniqueId = 0;\nlet overlay_Overlay = /*@__PURE__*/ (() => {\n    class Overlay {\n        constructor(\n        /** Scrolling strategies that can be used when creating an overlay. */\n        scrollStrategies, _overlayContainer, _componentFactoryResolver, _positionBuilder, _keyboardDispatcher, _injector, _ngZone, _document, _directionality, _location, _outsideClickDispatcher) {\n            this.scrollStrategies = scrollStrategies;\n            this._overlayContainer = _overlayContainer;\n            this._componentFactoryResolver = _componentFactoryResolver;\n            this._positionBuilder = _positionBuilder;\n            this._keyboardDispatcher = _keyboardDispatcher;\n            this._injector = _injector;\n            this._ngZone = _ngZone;\n            this._document = _document;\n            this._directionality = _directionality;\n            this._location = _location;\n            this._outsideClickDispatcher = _outsideClickDispatcher;\n        }\n        /**\n         * Creates an overlay.\n         * @param config Configuration applied to the overlay.\n         * @returns Reference to the created overlay.\n         */\n        create(config) {\n            const host = this._createHostElement();\n            const pane = this._createPaneElement(host);\n            const portalOutlet = this._createPortalOutlet(pane);\n            const overlayConfig = new OverlayConfig(config);\n            overlayConfig.direction = overlayConfig.direction || this._directionality.value;\n            return new overlay_OverlayRef(portalOutlet, host, pane, overlayConfig, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher);\n        }\n        /**\n         * Gets a position builder that can be used, via fluent API,\n         * to construct and configure a position strategy.\n         * @returns An overlay position builder.\n         */\n        position() {\n            return this._positionBuilder;\n        }\n        /**\n         * Creates the DOM element for an overlay and appends it to the overlay container.\n         * @returns Newly-created pane element\n         */\n        _createPaneElement(host) {\n            const pane = this._document.createElement('div');\n            pane.id = `cdk-overlay-${nextUniqueId++}`;\n            pane.classList.add('cdk-overlay-pane');\n            host.appendChild(pane);\n            return pane;\n        }\n        /**\n         * Creates the host element that wraps around an overlay\n         * and can be used for advanced positioning.\n         * @returns Newly-create host element.\n         */\n        _createHostElement() {\n            const host = this._document.createElement('div');\n            this._overlayContainer.getContainerElement().appendChild(host);\n            return host;\n        }\n        /**\n         * Create a DomPortalOutlet into which the overlay content can be loaded.\n         * @param pane The DOM element to turn into a portal outlet.\n         * @returns A portal outlet for the given DOM element.\n         */\n        _createPortalOutlet(pane) {\n            // We have to resolve the ApplicationRef later in order to allow people\n            // to use overlay-based providers during app initialization.\n            if (!this._appRef) {\n                this._appRef = this._injector.get(core[\"g\" /* ApplicationRef */]);\n            }\n            return new DomPortalOutlet(pane, this._componentFactoryResolver, this._appRef, this._injector, this._document);\n        }\n    }\n    Overlay.fac = function Overlay_Factory(t) { return new (t || Overlay)(core[\"Wb\" /* inject */](overlay_ScrollStrategyOptions), core[\"Wb\" /* inject */](overlay_OverlayContainer), core[\"Wb\" /* inject */](core[\"j\" /* ComponentFactoryResolver */]), core[\"Wb\" /* inject */](overlay_OverlayPositionBuilder), core[\"Wb\" /* inject */](overlay_OverlayKeyboardDispatcher), core[\"Wb\" /* inject */](core[\"r\" /* Injector */]), core[\"Wb\" /* inject */](core[\"A\" /* NgZone */]), core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */]), core[\"Wb\" /* inject */](bidi_Directionality), core[\"Wb\" /* inject */](common[\"f\" /* Location */]), core[\"Wb\" /* inject */](overlay_OverlayOutsideClickDispatcher)); };\n    Overlay.prov = /*@__PURE__*/ core[\"Ib\" /* defineInjectable */]({ token: Overlay, factory: Overlay.fac });\n    return Overlay;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** Default set of positions for the overlay. Follows the behavior of a dropdown. */\nconst defaultPositionList = [\n    {\n        originX: 'start',\n        originY: 'bottom',\n        overlayX: 'start',\n        overlayY: 'top'\n    },\n    {\n        originX: 'start',\n        originY: 'top',\n        overlayX: 'start',\n        overlayY: 'bottom'\n    },\n    {\n        originX: 'end',\n        originY: 'top',\n        overlayX: 'end',\n        overlayY: 'bottom'\n    },\n    {\n        originX: 'end',\n        originY: 'bottom',\n        overlayX: 'end',\n        overlayY: 'top'\n    }\n];\n/** Injection token that determines the scroll handling while the connected overlay is open. */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('cdk-connected-overlay-scroll-strategy');\nlet overlay_CdkOverlayOrigin = /*@__PURE__*/ (() => {\n    class CdkOverlayOrigin {\n        constructor(\n        /** Reference to the element on which the directive is applied. */\n        elementRef) {\n            this.elementRef = elementRef;\n        }\n    }\n    CdkOverlayOrigin.fac = function CdkOverlayOrigin_Factory(t) { return new (t || CdkOverlayOrigin)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */])); };\n    CdkOverlayOrigin.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: CdkOverlayOrigin, selectors: [[\"\", \"cdk-overlay-origin\", \"\"], [\"\", \"overlay-origin\", \"\"], [\"\", \"cdkOverlayOrigin\", \"\"]], exportAs: [\"cdkOverlayOrigin\"] });\n    return CdkOverlayOrigin;\n})();\nlet overlay_CdkConnectedOverlay = /*@__PURE__*/ (() => {\n    class CdkConnectedOverlay {\n        // TODO(jelbourn): inputs for size, scroll behavior, animation, etc.\n        constructor(_overlay, templateRef, viewContainerRef, scrollStrategyFactory, _dir) {\n            this._overlay = _overlay;\n            this._dir = _dir;\n            this._hasBackdrop = false;\n            this._lockPosition = false;\n            this._growAfterOpen = false;\n            this._flexibleDimensions = false;\n            this._push = false;\n            this._backdropSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n            this._attachSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n            this._detachSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n            this._positionSubscription = Subscription[\"a\" /* Subscription */].EMPTY;\n            /** Margin between the overlay and the viewport edges. */\n            this.viewportMargin = 0;\n            /** Whether the overlay is open. */\n            this.open = false;\n            /** Whether the overlay can be closed by user interaction. */\n            this.disableClose = false;\n            /** Event emitted when the backdrop is clicked. */\n            this.backdropClick = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted when the position has changed. */\n            this.positionChange = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted when the overlay has been attached. */\n            this.attach = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted when the overlay has been detached. */\n            this.detach = new core[\"n\" /* EventEmitter */]();\n            /** Emits when there are keyboard events that are targeted at the overlay. */\n            this.overlayKeydown = new core[\"n\" /* EventEmitter */]();\n            /** Emits when there are mouse outside click events that are targeted at the overlay. */\n            this.overlayOutsideClick = new core[\"n\" /* EventEmitter */]();\n            this._templatePortal = new TemplatePortal(templateRef, viewContainerRef);\n            this._scrollStrategyFactory = scrollStrategyFactory;\n            this.scrollStrategy = this._scrollStrategyFactory();\n        }\n        /** The offset in pixels for the overlay connection point on the x-axis */\n        get offsetX() { return this._offsetX; }\n        set offsetX(offsetX) {\n            this._offsetX = offsetX;\n            if (this._position) {\n                this._updatePositionStrategy(this._position);\n            }\n        }\n        /** The offset in pixels for the overlay connection point on the y-axis */\n        get offsetY() { return this._offsetY; }\n        set offsetY(offsetY) {\n            this._offsetY = offsetY;\n            if (this._position) {\n                this._updatePositionStrategy(this._position);\n            }\n        }\n        /** Whether or not the overlay should attach a backdrop. */\n        get hasBackdrop() { return this._hasBackdrop; }\n        set hasBackdrop(value) { this._hasBackdrop = coerceBooleanProperty(value); }\n        /** Whether or not the overlay should be locked when scrolling. */\n        get lockPosition() { return this._lockPosition; }\n        set lockPosition(value) { this._lockPosition = coerceBooleanProperty(value); }\n        /** Whether the overlay's width and height can be constrained to fit within the viewport. */\n        get flexibleDimensions() { return this._flexibleDimensions; }\n        set flexibleDimensions(value) {\n            this._flexibleDimensions = coerceBooleanProperty(value);\n        }\n        /** Whether the overlay can grow after the initial open when flexible positioning is turned on. */\n        get growAfterOpen() { return this._growAfterOpen; }\n        set growAfterOpen(value) { this._growAfterOpen = coerceBooleanProperty(value); }\n        /** Whether the overlay can be pushed on-screen if none of the provided positions fit. */\n        get push() { return this._push; }\n        set push(value) { this._push = coerceBooleanProperty(value); }\n        /** The associated overlay reference. */\n        get overlayRef() {\n            return this._overlayRef;\n        }\n        /** The element's layout direction. */\n        get dir() {\n            return this._dir ? this._dir.value : 'ltr';\n        }\n        ngOnDestroy() {\n            this._attachSubscription.unsubscribe();\n            this._detachSubscription.unsubscribe();\n            this._backdropSubscription.unsubscribe();\n            this._positionSubscription.unsubscribe();\n            if (this._overlayRef) {\n                this._overlayRef.dispose();\n            }\n        }\n        ngOnChanges(changes) {\n            if (this._position) {\n                this._updatePositionStrategy(this._position);\n                this._overlayRef.updateSize({\n                    width: this.width,\n                    minWidth: this.minWidth,\n                    height: this.height,\n                    minHeight: this.minHeight,\n                });\n                if (changes['origin'] && this.open) {\n                    this._position.apply();\n                }\n            }\n            if (changes['open']) {\n                this.open ? this._attachOverlay() : this._detachOverlay();\n            }\n        }\n        /** Creates an overlay */\n        _createOverlay() {\n            if (!this.positions || !this.positions.length) {\n                this.positions = defaultPositionList;\n            }\n            const overlayRef = this._overlayRef = this._overlay.create(this._buildConfig());\n            this._attachSubscription = overlayRef.attachments().subscribe(() => this.attach.emit());\n            this._detachSubscription = overlayRef.detachments().subscribe(() => this.detach.emit());\n            overlayRef.keydownEvents().subscribe((event) => {\n                this.overlayKeydown.next(event);\n                if (event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event)) {\n                    event.preventDefault();\n                    this._detachOverlay();\n                }\n            });\n            this._overlayRef.outsidePointerEvents().subscribe((event) => {\n                this.overlayOutsideClick.next(event);\n            });\n        }\n        /** Builds the overlay config based on the directive's inputs */\n        _buildConfig() {\n            const positionStrategy = this._position =\n                this.positionStrategy || this._createPositionStrategy();\n            const overlayConfig = new OverlayConfig({\n                direction: this._dir,\n                positionStrategy,\n                scrollStrategy: this.scrollStrategy,\n                hasBackdrop: this.hasBackdrop\n            });\n            if (this.width || this.width === 0) {\n                overlayConfig.width = this.width;\n            }\n            if (this.height || this.height === 0) {\n                overlayConfig.height = this.height;\n            }\n            if (this.minWidth || this.minWidth === 0) {\n                overlayConfig.minWidth = this.minWidth;\n            }\n            if (this.minHeight || this.minHeight === 0) {\n                overlayConfig.minHeight = this.minHeight;\n            }\n            if (this.backdropClass) {\n                overlayConfig.backdropClass = this.backdropClass;\n            }\n            if (this.panelClass) {\n                overlayConfig.panelClass = this.panelClass;\n            }\n            return overlayConfig;\n        }\n        /** Updates the state of a position strategy, based on the values of the directive inputs. */\n        _updatePositionStrategy(positionStrategy) {\n            const positions = this.positions.map(currentPosition => ({\n                originX: currentPosition.originX,\n                originY: currentPosition.originY,\n                overlayX: currentPosition.overlayX,\n                overlayY: currentPosition.overlayY,\n                offsetX: currentPosition.offsetX || this.offsetX,\n                offsetY: currentPosition.offsetY || this.offsetY,\n                panelClass: currentPosition.panelClass || undefined,\n            }));\n            return positionStrategy\n                .setOrigin(this.origin.elementRef)\n                .withPositions(positions)\n                .withFlexibleDimensions(this.flexibleDimensions)\n                .withPush(this.push)\n                .withGrowAfterOpen(this.growAfterOpen)\n                .withViewportMargin(this.viewportMargin)\n                .withLockedPosition(this.lockPosition)\n                .withTransformOriginOn(this.transformOriginSelector);\n        }\n        /** Returns the position strategy of the overlay to be set on the overlay config */\n        _createPositionStrategy() {\n            const strategy = this._overlay.position().flexibleConnectedTo(this.origin.elementRef);\n            this._updatePositionStrategy(strategy);\n            return strategy;\n        }\n        /** Attaches the overlay and subscribes to backdrop clicks if backdrop exists */\n        _attachOverlay() {\n            if (!this._overlayRef) {\n                this._createOverlay();\n            }\n            else {\n                // Update the overlay size, in case the directive's inputs have changed\n                this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop;\n            }\n            if (!this._overlayRef.hasAttached()) {\n                this._overlayRef.attach(this._templatePortal);\n            }\n            if (this.hasBackdrop) {\n                this._backdropSubscription = this._overlayRef.backdropClick().subscribe(event => {\n                    this.backdropClick.emit(event);\n                });\n            }\n            else {\n                this._backdropSubscription.unsubscribe();\n            }\n            this._positionSubscription.unsubscribe();\n            // Only subscribe to `positionChanges` if requested, because putting\n            // together all the information for it can be expensive.\n            if (this.positionChange.observers.length > 0) {\n                this._positionSubscription = this._position.positionChanges\n                    .pipe(takeWhile(() => this.positionChange.observers.length > 0))\n                    .subscribe(position => {\n                    this.positionChange.emit(position);\n                    if (this.positionChange.observers.length === 0) {\n                        this._positionSubscription.unsubscribe();\n                    }\n                });\n            }\n        }\n        /** Detaches the overlay and unsubscribes to backdrop clicks if backdrop exists */\n        _detachOverlay() {\n            if (this._overlayRef) {\n                this._overlayRef.detach();\n            }\n            this._backdropSubscription.unsubscribe();\n            this._positionSubscription.unsubscribe();\n        }\n    }\n    CdkConnectedOverlay.fac = function CdkConnectedOverlay_Factory(t) { return new (t || CdkConnectedOverlay)(core[\"Mb\" /* directiveInject */](overlay_Overlay), core[\"Mb\" /* directiveInject */](core[\"M\" /* TemplateRef */]), core[\"Mb\" /* directiveInject */](core[\"Q\" /* ViewContainerRef */]), core[\"Mb\" /* directiveInject */](CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8)); };\n    CdkConnectedOverlay.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: CdkConnectedOverlay, selectors: [[\"\", \"cdk-connected-overlay\", \"\"], [\"\", \"connected-overlay\", \"\"], [\"\", \"cdkConnectedOverlay\", \"\"]], inputs: { viewportMargin: [\"cdkConnectedOverlayViewportMargin\", \"viewportMargin\"], open: [\"cdkConnectedOverlayOpen\", \"open\"], disableClose: [\"cdkConnectedOverlayDisableClose\", \"disableClose\"], scrollStrategy: [\"cdkConnectedOverlayScrollStrategy\", \"scrollStrategy\"], offsetX: [\"cdkConnectedOverlayOffsetX\", \"offsetX\"], offsetY: [\"cdkConnectedOverlayOffsetY\", \"offsetY\"], hasBackdrop: [\"cdkConnectedOverlayHasBackdrop\", \"hasBackdrop\"], lockPosition: [\"cdkConnectedOverlayLockPosition\", \"lockPosition\"], flexibleDimensions: [\"cdkConnectedOverlayFlexibleDimensions\", \"flexibleDimensions\"], growAfterOpen: [\"cdkConnectedOverlayGrowAfterOpen\", \"growAfterOpen\"], push: [\"cdkConnectedOverlayPush\", \"push\"], positions: [\"cdkConnectedOverlayPositions\", \"positions\"], origin: [\"cdkConnectedOverlayOrigin\", \"origin\"], positionStrategy: [\"cdkConnectedOverlayPositionStrategy\", \"positionStrategy\"], width: [\"cdkConnectedOverlayWidth\", \"width\"], height: [\"cdkConnectedOverlayHeight\", \"height\"], minWidth: [\"cdkConnectedOverlayMinWidth\", \"minWidth\"], minHeight: [\"cdkConnectedOverlayMinHeight\", \"minHeight\"], backdropClass: [\"cdkConnectedOverlayBackdropClass\", \"backdropClass\"], panelClass: [\"cdkConnectedOverlayPanelClass\", \"panelClass\"], transformOriginSelector: [\"cdkConnectedOverlayTransformOriginOn\", \"transformOriginSelector\"] }, outputs: { backdropClick: \"backdropClick\", positionChange: \"positionChange\", attach: \"attach\", detach: \"detach\", overlayKeydown: \"overlayKeydown\", overlayOutsideClick: \"overlayOutsideClick\" }, exportAs: [\"cdkConnectedOverlay\"], features: [core[\"yb\" /* NgOnChangesFeature */]] });\n    return CdkConnectedOverlay;\n})();\n/** @docs-private */\nfunction CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/** @docs-private */\nconst CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER = {\n    provide: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY,\n    deps: [overlay_Overlay],\n    useFactory: CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\nlet overlay_OverlayModule = /*@__PURE__*/ (() => {\n    class OverlayModule {\n    }\n    OverlayModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: OverlayModule });\n    OverlayModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function OverlayModule_Factory(t) { return new (t || OverlayModule)(); }, providers: [\n            overlay_Overlay,\n            CDK_CONNECTED_OVERLAY_SCROLL_STRATEGY_PROVIDER,\n        ], imports: [[bidi_BidiModule, portal_PortalModule, scrolling_ScrollingModule], scrolling_ScrollingModule] });\n    return OverlayModule;\n})();\n/*@__PURE__*/ (function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](overlay_OverlayModule, { declarations: function () { return [overlay_CdkConnectedOverlay, overlay_CdkOverlayOrigin]; }, imports: function () { return [bidi_BidiModule, portal_PortalModule, scrolling_ScrollingModule]; }, exports: function () { return [overlay_CdkConnectedOverlay, overlay_CdkOverlayOrigin, scrolling_ScrollingModule]; } }); })();\nlet overlay_FullscreenOverlayContainer = /*@__PURE__*/ (() => {\n    class FullscreenOverlayContainer extends overlay_OverlayContainer {\n        constructor(_document, platform) {\n            super(_document, platform);\n        }\n        ngOnDestroy() {\n            super.ngOnDestroy();\n            if (this._fullScreenEventName && this._fullScreenListener) {\n                this._document.removeEventListener(this._fullScreenEventName, this._fullScreenListener);\n            }\n        }\n        _createContainer() {\n            super._createContainer();\n            this._adjustParentForFullscreenChange();\n            this._addFullscreenChangeListener(() => this._adjustParentForFullscreenChange());\n        }\n        _adjustParentForFullscreenChange() {\n            if (!this._containerElement) {\n                return;\n            }\n            const fullscreenElement = this.getFullscreenElement();\n            const parent = fullscreenElement || this._document.body;\n            parent.appendChild(this._containerElement);\n        }\n        _addFullscreenChangeListener(fn) {\n            const eventName = this._getEventName();\n            if (eventName) {\n                if (this._fullScreenListener) {\n                    this._document.removeEventListener(eventName, this._fullScreenListener);\n                }\n                this._document.addEventListener(eventName, fn);\n                this._fullScreenListener = fn;\n            }\n        }\n        _getEventName() {\n            if (!this._fullScreenEventName) {\n                const _document = this._document;\n                if (_document.fullscreenEnabled) {\n                    this._fullScreenEventName = 'fullscreenchange';\n                }\n                else if (_document.webkitFullscreenEnabled) {\n                    this._fullScreenEventName = 'webkitfullscreenchange';\n                }\n                else if (_document.mozFullScreenEnabled) {\n                    this._fullScreenEventName = 'mozfullscreenchange';\n                }\n                else if (_document.msFullscreenEnabled) {\n                    this._fullScreenEventName = 'MSFullscreenChange';\n                }\n            }\n            return this._fullScreenEventName;\n        }\n        /**\n         * When the page is put into fullscreen mode, a specific element is specified.\n         * Only that element and its children are visible when in fullscreen mode.\n         */\n        getFullscreenElement() {\n            const _document = this._document;\n            return _document.fullscreenElement ||\n                _document.webkitFullscreenElement ||\n                _document.mozFullScreenElement ||\n                _document.msFullscreenElement ||\n                null;\n        }\n    }\n    FullscreenOverlayContainer.fac = function FullscreenOverlayContainer_Factory(t) { return new (t || FullscreenOverlayContainer)(core[\"Wb\" /* inject */](common[\"c\" /* DOCUMENT */]), core[\"Wb\" /* inject */](platform_Platform)); };\n    FullscreenOverlayContainer.prov = /*@__PURE__*/ Object(core[\"Ib\" /* defineInjectable */])({ factory: function FullscreenOverlayContainer_Factory() { return new FullscreenOverlayContainer(Object(core[\"Wb\" /* inject */])(common[\"c\" /* DOCUMENT */]), Object(core[\"Wb\" /* inject */])(platform_Platform)); }, token: FullscreenOverlayContainer, providedIn: \"root\" });\n    return FullscreenOverlayContainer;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=overlay.js.map\n\n// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/form-field.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n\n\n\nconst form_field_c0 = [\"underline\"];\nconst form_field_c1 = [\"connectionContainer\"];\nconst form_field_c2 = [\"inputContainer\"];\nconst form_field_c3 = [\"label\"];\nfunction MatFormField_ng_container_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* elementContainerStart */](0);\n        core[\"Sb\" /* elementStart */](1, \"div\", 14);\n        core[\"Nb\" /* element */](2, \"div\", 15);\n        core[\"Nb\" /* element */](3, \"div\", 16);\n        core[\"Nb\" /* element */](4, \"div\", 17);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Sb\" /* elementStart */](5, \"div\", 18);\n        core[\"Nb\" /* element */](6, \"div\", 15);\n        core[\"Nb\" /* element */](7, \"div\", 16);\n        core[\"Nb\" /* element */](8, \"div\", 17);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Pb\" /* elementContainerEnd */]();\n    }\n}\nfunction MatFormField_div_4_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 19);\n        core[\"cc\" /* projection */](1, 1);\n        core[\"Rb\" /* elementEnd */]();\n    }\n}\nfunction MatFormField_label_9_ng_container_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Qb\" /* elementContainerStart */](0);\n        core[\"cc\" /* projection */](1, 2);\n        core[\"Sb\" /* elementStart */](2, \"span\");\n        core[\"uc\" /* text */](3);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Pb\" /* elementContainerEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r10 = core[\"bc\" /* nextContext */](2);\n        core[\"Ab\" /* advance */](3);\n        core[\"vc\" /* textInterpolate */](ctx_r10._control.placeholder);\n    }\n}\nfunction MatFormField_label_9_ng_content_3_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"cc\" /* projection */](0, 3, [\"*ngSwitchCase\", \"true\"]);\n    }\n}\nfunction MatFormField_label_9_span_4_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"span\", 23);\n        core[\"uc\" /* text */](1, \" *\");\n        core[\"Rb\" /* elementEnd */]();\n    }\n}\nfunction MatFormField_label_9_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r14 = core[\"Tb\" /* getCurrentView */]();\n        core[\"Sb\" /* elementStart */](0, \"label\", 20, 21);\n        core[\"Zb\" /* listener */](\"cdkObserveContent\", function MatFormField_label_9_Template_label_cdkObserveContent_0_listener() { core[\"mc\" /* restoreView */](_r14); const ctx_r13 = core[\"bc\" /* nextContext */](); return ctx_r13.updateOutlineGap(); });\n        core[\"sc\" /* template */](2, MatFormField_label_9_ng_container_2_Template, 4, 1, \"ng-container\", 12);\n        core[\"sc\" /* template */](3, MatFormField_label_9_ng_content_3_Template, 1, 0, \"ng-content\", 12);\n        core[\"sc\" /* template */](4, MatFormField_label_9_span_4_Template, 2, 0, \"span\", 22);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r4 = core[\"bc\" /* nextContext */]();\n        core[\"Eb\" /* classProp */](\"mat-empty\", ctx_r4._control.empty && !ctx_r4._shouldAlwaysFloat())(\"mat-form-field-empty\", ctx_r4._control.empty && !ctx_r4._shouldAlwaysFloat())(\"mat-accent\", ctx_r4.color == \"accent\")(\"mat-warn\", ctx_r4.color == \"warn\");\n        core[\"ec\" /* property */](\"cdkObserveContentDisabled\", ctx_r4.appearance != \"outline\")(\"id\", ctx_r4._labelId)(\"ngSwitch\", ctx_r4._hasLabel());\n        core[\"Bb\" /* attribute */](\"for\", ctx_r4._control.id)(\"aria-owns\", ctx_r4._control.id);\n        core[\"Ab\" /* advance */](2);\n        core[\"ec\" /* property */](\"ngSwitchCase\", false);\n        core[\"Ab\" /* advance */](1);\n        core[\"ec\" /* property */](\"ngSwitchCase\", true);\n        core[\"Ab\" /* advance */](1);\n        core[\"ec\" /* property */](\"ngIf\", !ctx_r4.hideRequiredMarker && ctx_r4._control.required && !ctx_r4._control.disabled);\n    }\n}\nfunction MatFormField_div_10_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 24);\n        core[\"cc\" /* projection */](1, 4);\n        core[\"Rb\" /* elementEnd */]();\n    }\n}\nfunction MatFormField_div_11_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 25, 26);\n        core[\"Nb\" /* element */](2, \"span\", 27);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r6 = core[\"bc\" /* nextContext */]();\n        core[\"Ab\" /* advance */](2);\n        core[\"Eb\" /* classProp */](\"mat-accent\", ctx_r6.color == \"accent\")(\"mat-warn\", ctx_r6.color == \"warn\");\n    }\n}\nfunction MatFormField_div_13_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\");\n        core[\"cc\" /* projection */](1, 5);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r7 = core[\"bc\" /* nextContext */]();\n        core[\"ec\" /* property */](\"@transitionMessages\", ctx_r7._subscriptAnimationState);\n    }\n}\nfunction MatFormField_div_14_div_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 31);\n        core[\"uc\" /* text */](1);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r16 = core[\"bc\" /* nextContext */](2);\n        core[\"ec\" /* property */](\"id\", ctx_r16._hintLabelId);\n        core[\"Ab\" /* advance */](1);\n        core[\"vc\" /* textInterpolate */](ctx_r16.hintLabel);\n    }\n}\nfunction MatFormField_div_14_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"div\", 28);\n        core[\"sc\" /* template */](1, MatFormField_div_14_div_1_Template, 2, 2, \"div\", 29);\n        core[\"cc\" /* projection */](2, 6);\n        core[\"Nb\" /* element */](3, \"div\", 30);\n        core[\"cc\" /* projection */](4, 7);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r8 = core[\"bc\" /* nextContext */]();\n        core[\"ec\" /* property */](\"@transitionMessages\", ctx_r8._subscriptAnimationState);\n        core[\"Ab\" /* advance */](1);\n        core[\"ec\" /* property */](\"ngIf\", ctx_r8.hintLabel);\n    }\n}\nconst form_field_c4 = [\"*\", [[\"\", \"matPrefix\", \"\"]], [[\"mat-placeholder\"]], [[\"mat-label\"]], [[\"\", \"matSuffix\", \"\"]], [[\"mat-error\"]], [[\"mat-hint\", 3, \"align\", \"end\"]], [[\"mat-hint\", \"align\", \"end\"]]];\nconst form_field_c5 = [\"*\", \"[matPrefix]\", \"mat-placeholder\", \"mat-label\", \"[matSuffix]\", \"mat-error\", \"mat-hint:not([align='end'])\", \"mat-hint[align='end']\"];\nlet form_field_nextUniqueId = 0;\n/**\n * Injection token that can be used to reference instances of `MatError`. It serves as\n * alternative token to the actual `MatError` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_ERROR = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MatError');\nlet form_field_MatError = /*@__PURE__*/ (() => {\n    class MatError {\n        constructor() {\n            this.id = `mat-error-${form_field_nextUniqueId++}`;\n        }\n    }\n    MatError.fac = function MatError_Factory(t) { return new (t || MatError)(); };\n    MatError.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatError, selectors: [[\"mat-error\"]], hostAttrs: [\"role\", \"alert\", 1, \"mat-error\"], hostVars: 1, hostBindings: function MatError_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Bb\" /* attribute */](\"id\", ctx.id);\n            }\n        }, inputs: { id: \"id\" }, features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{ provide: MAT_ERROR, useExisting: MatError }])] });\n    return MatError;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Animations used by the MatFormField.\n * @docs-private\n */\nconst matFormFieldAnimations = {\n    /** Animation that transitions the form field's error and hint messages. */\n    transitionMessages: /*@__PURE__*/ Object(fesm2015_animations[\"l\" /* trigger */])('transitionMessages', [\n        // TODO(mmalerba): Use angular animations for label animation as well.\n        /*@__PURE__*/ Object(fesm2015_animations[\"i\" /* state */])('enter', /*@__PURE__*/ Object(fesm2015_animations[\"j\" /* style */])({ opacity: 1, transform: 'translateY(0%)' })),\n        /*@__PURE__*/ Object(fesm2015_animations[\"k\" /* transition */])('void => enter', [\n            /*@__PURE__*/ Object(fesm2015_animations[\"j\" /* style */])({ opacity: 0, transform: 'translateY(-5px)' }),\n            /*@__PURE__*/ Object(fesm2015_animations[\"e\" /* animate */])('300ms cubic-bezier(0.55, 0, 0.55, 0.2)'),\n        ]),\n    ])\n};\nlet form_field_MatFormFieldControl = /*@__PURE__*/ (() => {\n    class MatFormFieldControl {\n    }\n    MatFormFieldControl.fac = function MatFormFieldControl_Factory(t) { return new (t || MatFormFieldControl)(); };\n    MatFormFieldControl.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatFormFieldControl });\n    return MatFormFieldControl;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** @docs-private */\nfunction getMatFormFieldPlaceholderConflictError() {\n    return Error('Placeholder attribute and child element were both specified.');\n}\n/** @docs-private */\nfunction getMatFormFieldDuplicatedHintError(align) {\n    return Error(`A hint was already declared for 'align=\"${align}\"'.`);\n}\n/** @docs-private */\nfunction getMatFormFieldMissingControlError() {\n    return Error('mat-form-field must contain a MatFormFieldControl.');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet nextUniqueId$1 = 0;\n/**\n * Injection token that can be used to reference instances of `MatHint`. It serves as\n * alternative token to the actual `MatHint` class which could cause unnecessary\n * retention of the class and its directive metadata.\n *\n * *Note*: This is not part of the public API as the MDC-based form-field will not\n * need a lightweight token for `MatHint` and we want to reduce breaking changes.\n */\nconst _MAT_HINT = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MatHint');\nlet form_field_MatHint = /*@__PURE__*/ (() => {\n    class MatHint {\n        constructor() {\n            /** Whether to align the hint label at the start or end of the line. */\n            this.align = 'start';\n            /** Unique ID for the hint. Used for the aria-describedby on the form field control. */\n            this.id = `mat-hint-${nextUniqueId$1++}`;\n        }\n    }\n    MatHint.fac = function MatHint_Factory(t) { return new (t || MatHint)(); };\n    MatHint.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatHint, selectors: [[\"mat-hint\"]], hostAttrs: [1, \"mat-hint\"], hostVars: 4, hostBindings: function MatHint_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Bb\" /* attribute */](\"id\", ctx.id)(\"align\", null);\n                core[\"Eb\" /* classProp */](\"mat-form-field-hint-end\", ctx.align === \"end\");\n            }\n        }, inputs: { align: \"align\", id: \"id\" }, features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{ provide: _MAT_HINT, useExisting: MatHint }])] });\n    return MatHint;\n})();\nlet form_field_MatLabel = /*@__PURE__*/ (() => {\n    class MatLabel {\n    }\n    MatLabel.fac = function MatLabel_Factory(t) { return new (t || MatLabel)(); };\n    MatLabel.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatLabel, selectors: [[\"mat-label\"]] });\n    return MatLabel;\n})();\nlet form_field_MatPlaceholder = /*@__PURE__*/ (() => {\n    class MatPlaceholder {\n    }\n    MatPlaceholder.fac = function MatPlaceholder_Factory(t) { return new (t || MatPlaceholder)(); };\n    MatPlaceholder.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatPlaceholder, selectors: [[\"mat-placeholder\"]] });\n    return MatPlaceholder;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `MatPrefix`. It serves as\n * alternative token to the actual `MatPrefix` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_PREFIX = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MatPrefix');\nlet form_field_MatPrefix = /*@__PURE__*/ (() => {\n    class MatPrefix {\n    }\n    MatPrefix.fac = function MatPrefix_Factory(t) { return new (t || MatPrefix)(); };\n    MatPrefix.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatPrefix, selectors: [[\"\", \"matPrefix\", \"\"]], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{ provide: MAT_PREFIX, useExisting: MatPrefix }])] });\n    return MatPrefix;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Injection token that can be used to reference instances of `MatSuffix`. It serves as\n * alternative token to the actual `MatSuffix` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_SUFFIX = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MatSuffix');\nlet form_field_MatSuffix = /*@__PURE__*/ (() => {\n    class MatSuffix {\n    }\n    MatSuffix.fac = function MatSuffix_Factory(t) { return new (t || MatSuffix)(); };\n    MatSuffix.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatSuffix, selectors: [[\"\", \"matSuffix\", \"\"]], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{ provide: MAT_SUFFIX, useExisting: MatSuffix }])] });\n    return MatSuffix;\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet nextUniqueId$2 = 0;\nconst floatingLabelScale = 0.75;\nconst outlineGapPadding = 5;\n/**\n * Boilerplate for applying mixins to MatFormField.\n * @docs-private\n */\nclass MatFormFieldBase {\n    constructor(_elementRef) {\n        this._elementRef = _elementRef;\n    }\n}\n/**\n * Base class to which we're applying the form field mixins.\n * @docs-private\n */\nconst _MatFormFieldMixinBase = /*@__PURE__*/ mixinColor(MatFormFieldBase, 'primary');\n/**\n * Injection token that can be used to configure the\n * default options for all form field within an app.\n */\nconst MAT_FORM_FIELD_DEFAULT_OPTIONS = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MAT_FORM_FIELD_DEFAULT_OPTIONS');\n/**\n * Injection token that can be used to inject an instances of `MatFormField`. It serves\n * as alternative token to the actual `MatFormField` class which would cause unnecessary\n * retention of the `MatFormField` class and its component metadata.\n */\nconst MAT_FORM_FIELD = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MatFormField');\nlet form_field_MatFormField = /*@__PURE__*/ (() => {\n    class MatFormField extends _MatFormFieldMixinBase {\n        constructor(_elementRef, _changeDetectorRef, \n        /**\n         * @deprecated `_labelOptions` parameter no longer being used. To be removed.\n         * @breaking-change 12.0.0\n         */\n        // Use `ElementRef` here so Angular has something to inject.\n        _labelOptions, _dir, _defaults, _platform, _ngZone, _animationMode) {\n            super(_elementRef);\n            this._elementRef = _elementRef;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._dir = _dir;\n            this._defaults = _defaults;\n            this._platform = _platform;\n            this._ngZone = _ngZone;\n            /**\n             * Whether the outline gap needs to be calculated\n             * immediately on the next change detection run.\n             */\n            this._outlineGapCalculationNeededImmediately = false;\n            /** Whether the outline gap needs to be calculated next time the zone has stabilized. */\n            this._outlineGapCalculationNeededOnStable = false;\n            this._destroyed = new Subject[\"a\" /* Subject */]();\n            /** Override for the logic that disables the label animation in certain cases. */\n            this._showAlwaysAnimate = false;\n            /** State of the mat-hint and mat-error animations. */\n            this._subscriptAnimationState = '';\n            this._hintLabel = '';\n            // Unique id for the hint label.\n            this._hintLabelId = `mat-hint-${nextUniqueId$2++}`;\n            // Unique id for the label element.\n            this._labelId = `mat-form-field-label-${nextUniqueId$2++}`;\n            this.floatLabel = this._getDefaultFloatLabelState();\n            this._animationsEnabled = _animationMode !== 'NoopAnimations';\n            // Set the default through here so we invoke the setter on the first run.\n            this.appearance = (_defaults && _defaults.appearance) ? _defaults.appearance : 'legacy';\n            this._hideRequiredMarker = (_defaults && _defaults.hideRequiredMarker != null) ?\n                _defaults.hideRequiredMarker : false;\n        }\n        /** The form-field appearance style. */\n        get appearance() { return this._appearance; }\n        set appearance(value) {\n            const oldValue = this._appearance;\n            this._appearance = value || (this._defaults && this._defaults.appearance) || 'legacy';\n            if (this._appearance === 'outline' && oldValue !== value) {\n                this._outlineGapCalculationNeededOnStable = true;\n            }\n        }\n        /** Whether the required marker should be hidden. */\n        get hideRequiredMarker() { return this._hideRequiredMarker; }\n        set hideRequiredMarker(value) {\n            this._hideRequiredMarker = coerceBooleanProperty(value);\n        }\n        /** Whether the floating label should always float or not. */\n        _shouldAlwaysFloat() {\n            return this.floatLabel === 'always' && !this._showAlwaysAnimate;\n        }\n        /** Whether the label can float or not. */\n        _canLabelFloat() { return this.floatLabel !== 'never'; }\n        /** Text for the form field hint. */\n        get hintLabel() { return this._hintLabel; }\n        set hintLabel(value) {\n            this._hintLabel = value;\n            this._processHints();\n        }\n        /**\n         * Whether the label should always float, never float or float as the user types.\n         *\n         * Note: only the legacy appearance supports the `never` option. `never` was originally added as a\n         * way to make the floating label emulate the behavior of a standard input placeholder. However\n         * the form field now supports both floating labels and placeholders. Therefore in the non-legacy\n         * appearances the `never` option has been disabled in favor of just using the placeholder.\n         */\n        get floatLabel() {\n            return this.appearance !== 'legacy' && this._floatLabel === 'never' ? 'auto' : this._floatLabel;\n        }\n        set floatLabel(value) {\n            if (value !== this._floatLabel) {\n                this._floatLabel = value || this._getDefaultFloatLabelState();\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        get _control() {\n            // TODO(crisbeto): we need this workaround in order to support both Ivy and ViewEngine.\n            //  We should clean this up once Ivy is the default renderer.\n            return this._explicitFormFieldControl || this._controlNonStatic || this._controlStatic;\n        }\n        set _control(value) {\n            this._explicitFormFieldControl = value;\n        }\n        /**\n         * Gets the id of the label element. If no label is present, returns `null`.\n         */\n        getLabelId() {\n            return this._hasFloatingLabel() ? this._labelId : null;\n        }\n        /**\n         * Gets an ElementRef for the element that a overlay attached to the form-field should be\n         * positioned relative to.\n         */\n        getConnectedOverlayOrigin() {\n            return this._connectionContainerRef || this._elementRef;\n        }\n        ngAfterContentInit() {\n            this._validateControlChild();\n            const control = this._control;\n            if (control.controlType) {\n                this._elementRef.nativeElement.classList.add(`mat-form-field-type-${control.controlType}`);\n            }\n            // Subscribe to changes in the child control state in order to update the form field UI.\n            control.stateChanges.pipe(Object(startWith[\"a\" /* startWith */])(null)).subscribe(() => {\n                this._validatePlaceholders();\n                this._syncDescribedByIds();\n                this._changeDetectorRef.markForCheck();\n            });\n            // Run change detection if the value changes.\n            if (control.ngControl && control.ngControl.valueChanges) {\n                control.ngControl.valueChanges\n                    .pipe(takeUntil(this._destroyed))\n                    .subscribe(() => this._changeDetectorRef.markForCheck());\n            }\n            // Note that we have to run outside of the `NgZone` explicitly,\n            // in order to avoid throwing users into an infinite loop\n            // if `zone-patch-rxjs` is included.\n            this._ngZone.runOutsideAngular(() => {\n                this._ngZone.onStable.pipe(takeUntil(this._destroyed)).subscribe(() => {\n                    if (this._outlineGapCalculationNeededOnStable) {\n                        this.updateOutlineGap();\n                    }\n                });\n            });\n            // Run change detection and update the outline if the suffix or prefix changes.\n            Object(merge[\"a\" /* merge */])(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => {\n                this._outlineGapCalculationNeededOnStable = true;\n                this._changeDetectorRef.markForCheck();\n            });\n            // Re-validate when the number of hints changes.\n            this._hintChildren.changes.pipe(Object(startWith[\"a\" /* startWith */])(null)).subscribe(() => {\n                this._processHints();\n                this._changeDetectorRef.markForCheck();\n            });\n            // Update the aria-described by when the number of errors changes.\n            this._errorChildren.changes.pipe(Object(startWith[\"a\" /* startWith */])(null)).subscribe(() => {\n                this._syncDescribedByIds();\n                this._changeDetectorRef.markForCheck();\n            });\n            if (this._dir) {\n                this._dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => {\n                    if (typeof requestAnimationFrame === 'function') {\n                        this._ngZone.runOutsideAngular(() => {\n                            requestAnimationFrame(() => this.updateOutlineGap());\n                        });\n                    }\n                    else {\n                        this.updateOutlineGap();\n                    }\n                });\n            }\n        }\n        ngAfterContentChecked() {\n            this._validateControlChild();\n            if (this._outlineGapCalculationNeededImmediately) {\n                this.updateOutlineGap();\n            }\n        }\n        ngAfterViewInit() {\n            // Avoid animations on load.\n            this._subscriptAnimationState = 'enter';\n            this._changeDetectorRef.detectChanges();\n        }\n        ngOnDestroy() {\n            this._destroyed.next();\n            this._destroyed.complete();\n        }\n        /** Determines whether a class from the NgControl should be forwarded to the host element. */\n        _shouldForward(prop) {\n            const ngControl = this._control ? this._control.ngControl : null;\n            return ngControl && ngControl[prop];\n        }\n        _hasPlaceholder() {\n            return !!(this._control && this._control.placeholder || this._placeholderChild);\n        }\n        _hasLabel() {\n            return !!(this._labelChildNonStatic || this._labelChildStatic);\n        }\n        _shouldLabelFloat() {\n            return this._canLabelFloat() &&\n                ((this._control && this._control.shouldLabelFloat) || this._shouldAlwaysFloat());\n        }\n        _hideControlPlaceholder() {\n            // In the legacy appearance the placeholder is promoted to a label if no label is given.\n            return this.appearance === 'legacy' && !this._hasLabel() ||\n                this._hasLabel() && !this._shouldLabelFloat();\n        }\n        _hasFloatingLabel() {\n            // In the legacy appearance the placeholder is promoted to a label if no label is given.\n            return this._hasLabel() || this.appearance === 'legacy' && this._hasPlaceholder();\n        }\n        /** Determines whether to display hints or errors. */\n        _getDisplayedMessages() {\n            return (this._errorChildren && this._errorChildren.length > 0 &&\n                this._control.errorState) ? 'error' : 'hint';\n        }\n        /** Animates the placeholder up and locks it in position. */\n        _animateAndLockLabel() {\n            if (this._hasFloatingLabel() && this._canLabelFloat()) {\n                // If animations are disabled, we shouldn't go in here,\n                // because the `transitionend` will never fire.\n                if (this._animationsEnabled && this._label) {\n                    this._showAlwaysAnimate = true;\n                    fromEvent(this._label.nativeElement, 'transitionend').pipe(Object(take[\"a\" /* take */])(1)).subscribe(() => {\n                        this._showAlwaysAnimate = false;\n                    });\n                }\n                this.floatLabel = 'always';\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        /**\n         * Ensure that there is only one placeholder (either `placeholder` attribute on the child control\n         * or child element with the `mat-placeholder` directive).\n         */\n        _validatePlaceholders() {\n            if (this._control.placeholder && this._placeholderChild &&\n                (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getMatFormFieldPlaceholderConflictError();\n            }\n        }\n        /** Does any extra processing that is required when handling the hints. */\n        _processHints() {\n            this._validateHints();\n            this._syncDescribedByIds();\n        }\n        /**\n         * Ensure that there is a maximum of one of each `<mat-hint>` alignment specified, with the\n         * attribute being considered as `align=\"start\"`.\n         */\n        _validateHints() {\n            if (this._hintChildren && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                let startHint;\n                let endHint;\n                this._hintChildren.forEach((hint) => {\n                    if (hint.align === 'start') {\n                        if (startHint || this.hintLabel) {\n                            throw getMatFormFieldDuplicatedHintError('start');\n                        }\n                        startHint = hint;\n                    }\n                    else if (hint.align === 'end') {\n                        if (endHint) {\n                            throw getMatFormFieldDuplicatedHintError('end');\n                        }\n                        endHint = hint;\n                    }\n                });\n            }\n        }\n        /** Gets the default float label state. */\n        _getDefaultFloatLabelState() {\n            return (this._defaults && this._defaults.floatLabel) || 'auto';\n        }\n        /**\n         * Sets the list of element IDs that describe the child control. This allows the control to update\n         * its `aria-describedby` attribute accordingly.\n         */\n        _syncDescribedByIds() {\n            if (this._control) {\n                let ids = [];\n                // TODO(wagnermaciel): Remove the type check when we find the root cause of this bug.\n                if (this._control.userAriaDescribedBy &&\n                    typeof this._control.userAriaDescribedBy === 'string') {\n                    ids.push(...this._control.userAriaDescribedBy.split(' '));\n                }\n                if (this._getDisplayedMessages() === 'hint') {\n                    const startHint = this._hintChildren ?\n                        this._hintChildren.find(hint => hint.align === 'start') : null;\n                    const endHint = this._hintChildren ?\n                        this._hintChildren.find(hint => hint.align === 'end') : null;\n                    if (startHint) {\n                        ids.push(startHint.id);\n                    }\n                    else if (this._hintLabel) {\n                        ids.push(this._hintLabelId);\n                    }\n                    if (endHint) {\n                        ids.push(endHint.id);\n                    }\n                }\n                else if (this._errorChildren) {\n                    ids.push(...this._errorChildren.map(error => error.id));\n                }\n                this._control.setDescribedByIds(ids);\n            }\n        }\n        /** Throws an error if the form field's control is missing. */\n        _validateControlChild() {\n            if (!this._control && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getMatFormFieldMissingControlError();\n            }\n        }\n        /**\n         * Updates the width and position of the gap in the outline. Only relevant for the outline\n         * appearance.\n         */\n        updateOutlineGap() {\n            const labelEl = this._label ? this._label.nativeElement : null;\n            if (this.appearance !== 'outline' || !labelEl || !labelEl.children.length ||\n                !labelEl.textContent.trim()) {\n                return;\n            }\n            if (!this._platform.isBrowser) {\n                // getBoundingClientRect isn't available on the server.\n                return;\n            }\n            // If the element is not present in the DOM, the outline gap will need to be calculated\n            // the next time it is checked and in the DOM.\n            if (!this._isAttachedToDOM()) {\n                this._outlineGapCalculationNeededImmediately = true;\n                return;\n            }\n            let startWidth = 0;\n            let gapWidth = 0;\n            const container = this._connectionContainerRef.nativeElement;\n            const startEls = container.querySelectorAll('.mat-form-field-outline-start');\n            const gapEls = container.querySelectorAll('.mat-form-field-outline-gap');\n            if (this._label && this._label.nativeElement.children.length) {\n                const containerRect = container.getBoundingClientRect();\n                // If the container's width and height are zero, it means that the element is\n                // invisible and we can't calculate the outline gap. Mark the element as needing\n                // to be checked the next time the zone stabilizes. We can't do this immediately\n                // on the next change detection, because even if the element becomes visible,\n                // the `ClientRect` won't be reclaculated immediately. We reset the\n                // `_outlineGapCalculationNeededImmediately` flag some we don't run the checks twice.\n                if (containerRect.width === 0 && containerRect.height === 0) {\n                    this._outlineGapCalculationNeededOnStable = true;\n                    this._outlineGapCalculationNeededImmediately = false;\n                    return;\n                }\n                const containerStart = this._getStartEnd(containerRect);\n                const labelChildren = labelEl.children;\n                const labelStart = this._getStartEnd(labelChildren[0].getBoundingClientRect());\n                let labelWidth = 0;\n                for (let i = 0; i < labelChildren.length; i++) {\n                    labelWidth += labelChildren[i].offsetWidth;\n                }\n                startWidth = Math.abs(labelStart - containerStart) - outlineGapPadding;\n                gapWidth = labelWidth > 0 ? labelWidth * floatingLabelScale + outlineGapPadding * 2 : 0;\n            }\n            for (let i = 0; i < startEls.length; i++) {\n                startEls[i].style.width = `${startWidth}px`;\n            }\n            for (let i = 0; i < gapEls.length; i++) {\n                gapEls[i].style.width = `${gapWidth}px`;\n            }\n            this._outlineGapCalculationNeededOnStable =\n                this._outlineGapCalculationNeededImmediately = false;\n        }\n        /** Gets the start end of the rect considering the current directionality. */\n        _getStartEnd(rect) {\n            return (this._dir && this._dir.value === 'rtl') ? rect.right : rect.left;\n        }\n        /** Checks whether the form field is attached to the DOM. */\n        _isAttachedToDOM() {\n            const element = this._elementRef.nativeElement;\n            if (element.getRootNode) {\n                const rootNode = element.getRootNode();\n                // If the element is inside the DOM the root node will be either the document\n                // or the closest shadow root, otherwise it'll be the element itself.\n                return rootNode && rootNode !== element;\n            }\n            // Otherwise fall back to checking if it's in the document. This doesn't account for\n            // shadow DOM, however browser that support shadow DOM should support `getRootNode` as well.\n            return document.documentElement.contains(element);\n        }\n    }\n    MatFormField.fac = function MatFormField_Factory(t) { return new (t || MatFormField)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8), core[\"Mb\" /* directiveInject */](MAT_FORM_FIELD_DEFAULT_OPTIONS, 8), core[\"Mb\" /* directiveInject */](platform_Platform), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](animations[\"a\" /* ANIMATION_MODULE_TYPE */], 8)); };\n    MatFormField.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatFormField, selectors: [[\"mat-form-field\"]], contentQueries: function MatFormField_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Fb\" /* contentQuery */](dirIndex, form_field_MatFormFieldControl, true);\n                core[\"pc\" /* staticContentQuery */](dirIndex, form_field_MatFormFieldControl, true);\n                core[\"Fb\" /* contentQuery */](dirIndex, form_field_MatLabel, true);\n                core[\"pc\" /* staticContentQuery */](dirIndex, form_field_MatLabel, true);\n                core[\"Fb\" /* contentQuery */](dirIndex, form_field_MatPlaceholder, true);\n                core[\"Fb\" /* contentQuery */](dirIndex, MAT_ERROR, true);\n                core[\"Fb\" /* contentQuery */](dirIndex, _MAT_HINT, true);\n                core[\"Fb\" /* contentQuery */](dirIndex, MAT_PREFIX, true);\n                core[\"Fb\" /* contentQuery */](dirIndex, MAT_SUFFIX, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._controlNonStatic = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._controlStatic = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._labelChildNonStatic = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._labelChildStatic = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._placeholderChild = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._errorChildren = _t);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._hintChildren = _t);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._prefixChildren = _t);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._suffixChildren = _t);\n            }\n        }, viewQuery: function MatFormField_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"xc\" /* viewQuery */](form_field_c0, true);\n                core[\"qc\" /* staticViewQuery */](form_field_c1, true);\n                core[\"xc\" /* viewQuery */](form_field_c2, true);\n                core[\"xc\" /* viewQuery */](form_field_c3, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.underlineRef = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._connectionContainerRef = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._inputContainerRef = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx._label = _t.first);\n            }\n        }, hostAttrs: [1, \"mat-form-field\"], hostVars: 40, hostBindings: function MatFormField_HostBindings(rf, ctx) {\n            if (rf & 2) {\n                core[\"Eb\" /* classProp */](\"mat-form-field-appearance-standard\", ctx.appearance == \"standard\")(\"mat-form-field-appearance-fill\", ctx.appearance == \"fill\")(\"mat-form-field-appearance-outline\", ctx.appearance == \"outline\")(\"mat-form-field-appearance-legacy\", ctx.appearance == \"legacy\")(\"mat-form-field-invalid\", ctx._control.errorState)(\"mat-form-field-can-float\", ctx._canLabelFloat())(\"mat-form-field-should-float\", ctx._shouldLabelFloat())(\"mat-form-field-has-label\", ctx._hasFloatingLabel())(\"mat-form-field-hide-placeholder\", ctx._hideControlPlaceholder())(\"mat-form-field-disabled\", ctx._control.disabled)(\"mat-form-field-autofilled\", ctx._control.autofilled)(\"mat-focused\", ctx._control.focused)(\"ng-untouched\", ctx._shouldForward(\"untouched\"))(\"ng-touched\", ctx._shouldForward(\"touched\"))(\"ng-pristine\", ctx._shouldForward(\"pristine\"))(\"ng-dirty\", ctx._shouldForward(\"dirty\"))(\"ng-valid\", ctx._shouldForward(\"valid\"))(\"ng-invalid\", ctx._shouldForward(\"invalid\"))(\"ng-pending\", ctx._shouldForward(\"pending\"))(\"_mat-animation-noopable\", !ctx._animationsEnabled);\n            }\n        }, inputs: { color: \"color\", floatLabel: \"floatLabel\", appearance: \"appearance\", hideRequiredMarker: \"hideRequiredMarker\", hintLabel: \"hintLabel\" }, exportAs: [\"matFormField\"], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([\n                { provide: MAT_FORM_FIELD, useExisting: MatFormField },\n            ]), core[\"xb\" /* InheritDefinitionFeature */]], ngContentSelectors: form_field_c5, decls: 15, vars: 8, consts: [[1, \"mat-form-field-wrapper\"], [1, \"mat-form-field-flex\", 3, \"click\"], [\"connectionContainer\", \"\"], [4, \"ngIf\"], [\"class\", \"mat-form-field-prefix\", 4, \"ngIf\"], [1, \"mat-form-field-infix\"], [\"inputContainer\", \"\"], [1, \"mat-form-field-label-wrapper\"], [\"class\", \"mat-form-field-label\", 3, \"cdkObserveContentDisabled\", \"id\", \"mat-empty\", \"mat-form-field-empty\", \"mat-accent\", \"mat-warn\", \"ngSwitch\", \"cdkObserveContent\", 4, \"ngIf\"], [\"class\", \"mat-form-field-suffix\", 4, \"ngIf\"], [\"class\", \"mat-form-field-underline\", 4, \"ngIf\"], [1, \"mat-form-field-subscript-wrapper\", 3, \"ngSwitch\"], [4, \"ngSwitchCase\"], [\"class\", \"mat-form-field-hint-wrapper\", 4, \"ngSwitchCase\"], [1, \"mat-form-field-outline\"], [1, \"mat-form-field-outline-start\"], [1, \"mat-form-field-outline-gap\"], [1, \"mat-form-field-outline-end\"], [1, \"mat-form-field-outline\", \"mat-form-field-outline-thick\"], [1, \"mat-form-field-prefix\"], [1, \"mat-form-field-label\", 3, \"cdkObserveContentDisabled\", \"id\", \"ngSwitch\", \"cdkObserveContent\"], [\"label\", \"\"], [\"class\", \"mat-placeholder-required mat-form-field-required-marker\", \"aria-hidden\", \"true\", 4, \"ngIf\"], [\"aria-hidden\", \"true\", 1, \"mat-placeholder-required\", \"mat-form-field-required-marker\"], [1, \"mat-form-field-suffix\"], [1, \"mat-form-field-underline\"], [\"underline\", \"\"], [1, \"mat-form-field-ripple\"], [1, \"mat-form-field-hint-wrapper\"], [\"class\", \"mat-hint\", 3, \"id\", 4, \"ngIf\"], [1, \"mat-form-field-hint-spacer\"], [1, \"mat-hint\", 3, \"id\"]], template: function MatFormField_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"dc\" /* projectionDef */](form_field_c4);\n                core[\"Sb\" /* elementStart */](0, \"div\", 0);\n                core[\"Sb\" /* elementStart */](1, \"div\", 1, 2);\n                core[\"Zb\" /* listener */](\"click\", function MatFormField_Template_div_click_1_listener($event) { return ctx._control.onContainerClick && ctx._control.onContainerClick($event); });\n                core[\"sc\" /* template */](3, MatFormField_ng_container_3_Template, 9, 0, \"ng-container\", 3);\n                core[\"sc\" /* template */](4, MatFormField_div_4_Template, 2, 0, \"div\", 4);\n                core[\"Sb\" /* elementStart */](5, \"div\", 5, 6);\n                core[\"cc\" /* projection */](7);\n                core[\"Sb\" /* elementStart */](8, \"span\", 7);\n                core[\"sc\" /* template */](9, MatFormField_label_9_Template, 5, 16, \"label\", 8);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"sc\" /* template */](10, MatFormField_div_10_Template, 2, 0, \"div\", 9);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"sc\" /* template */](11, MatFormField_div_11_Template, 3, 4, \"div\", 10);\n                core[\"Sb\" /* elementStart */](12, \"div\", 11);\n                core[\"sc\" /* template */](13, MatFormField_div_13_Template, 2, 1, \"div\", 12);\n                core[\"sc\" /* template */](14, MatFormField_div_14_Template, 5, 2, \"div\", 13);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"Ab\" /* advance */](3);\n                core[\"ec\" /* property */](\"ngIf\", ctx.appearance == \"outline\");\n                core[\"Ab\" /* advance */](1);\n                core[\"ec\" /* property */](\"ngIf\", ctx._prefixChildren.length);\n                core[\"Ab\" /* advance */](5);\n                core[\"ec\" /* property */](\"ngIf\", ctx._hasFloatingLabel());\n                core[\"Ab\" /* advance */](1);\n                core[\"ec\" /* property */](\"ngIf\", ctx._suffixChildren.length);\n                core[\"Ab\" /* advance */](1);\n                core[\"ec\" /* property */](\"ngIf\", ctx.appearance != \"outline\");\n                core[\"Ab\" /* advance */](1);\n                core[\"ec\" /* property */](\"ngSwitch\", ctx._getDisplayedMessages());\n                core[\"Ab\" /* advance */](1);\n                core[\"ec\" /* property */](\"ngSwitchCase\", \"error\");\n                core[\"Ab\" /* advance */](1);\n                core[\"ec\" /* property */](\"ngSwitchCase\", \"hint\");\n            }\n        }, directives: [common[\"j\" /* NgIf */], common[\"l\" /* NgSwitch */], common[\"m\" /* NgSwitchCase */], observers_CdkObserveContent], styles: [\".mat-form-field{display:inline-block;position:relative;text-align:left}[dir=rtl] .mat-form-field{text-align:right}.mat-form-field-wrapper{position:relative}.mat-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-form-field-prefix,.mat-form-field-suffix{white-space:nowrap;flex:none;position:relative}.mat-form-field-infix{display:block;position:relative;flex:auto;min-width:0;width:180px}.cdk-high-contrast-active .mat-form-field-infix{border-image:linear-gradient(transparent, transparent)}.mat-form-field-label-wrapper{position:absolute;left:0;box-sizing:content-box;width:100%;height:100%;overflow:hidden;pointer-events:none}[dir=rtl] .mat-form-field-label-wrapper{left:auto;right:0}.mat-form-field-label{position:absolute;left:0;font:inherit;pointer-events:none;width:100%;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),width 400ms cubic-bezier(0.25, 0.8, 0.25, 1);display:none}[dir=rtl] .mat-form-field-label{transform-origin:100% 0;left:auto;right:0}.mat-form-field-empty.mat-form-field-label,.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-label{display:block}.mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-form-field-autofill-control:-webkit-autofill+.mat-form-field-label-wrapper .mat-form-field-label{display:block;transition:none}.mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:none}.mat-form-field-can-float .mat-input-server:focus+.mat-form-field-label-wrapper .mat-form-field-label,.mat-form-field-can-float .mat-input-server[placeholder]:not(:placeholder-shown)+.mat-form-field-label-wrapper .mat-form-field-label{display:block}.mat-form-field-label:not(.mat-form-field-empty){transition:none}.mat-form-field-underline{position:absolute;width:100%;pointer-events:none;transform:scale3d(1, 1.0001, 1)}.mat-form-field-ripple{position:absolute;left:0;width:100%;transform-origin:50%;transform:scaleX(0.5);opacity:0;transition:background-color 300ms cubic-bezier(0.55, 0, 0.55, 0.2)}.mat-form-field.mat-focused .mat-form-field-ripple,.mat-form-field.mat-form-field-invalid .mat-form-field-ripple{opacity:1;transform:none;transition:transform 300ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 300ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-subscript-wrapper{position:absolute;box-sizing:border-box;width:100%;overflow:hidden}.mat-form-field-subscript-wrapper .mat-icon,.mat-form-field-label-wrapper .mat-icon{width:1em;height:1em;font-size:inherit;vertical-align:baseline}.mat-form-field-hint-wrapper{display:flex}.mat-form-field-hint-spacer{flex:1 0 1em}.mat-error{display:block}.mat-form-field-control-wrapper{position:relative}.mat-form-field-hint-end{order:1}.mat-form-field._mat-animation-noopable .mat-form-field-label,.mat-form-field._mat-animation-noopable .mat-form-field-ripple{transition:none}\\n\", \".mat-form-field-appearance-fill .mat-form-field-flex{border-radius:4px 4px 0 0;padding:.75em .75em 0 .75em}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-flex{outline:solid 1px}.mat-form-field-appearance-fill .mat-form-field-underline::before{content:\\\"\\\";display:block;position:absolute;bottom:0;height:1px;width:100%}.mat-form-field-appearance-fill .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-fill:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-fill._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}.mat-form-field-appearance-fill .mat-form-field-subscript-wrapper{padding:0 1em}\\n\", \".mat-input-element{font:inherit;background:transparent;color:currentColor;border:none;outline:none;padding:0;margin:0;width:100%;max-width:100%;vertical-align:bottom;text-align:inherit;box-sizing:content-box}.mat-input-element:-moz-ui-invalid{box-shadow:none}.mat-input-element::-ms-clear,.mat-input-element::-ms-reveal{display:none}.mat-input-element,.mat-input-element::-webkit-search-cancel-button,.mat-input-element::-webkit-search-decoration,.mat-input-element::-webkit-search-results-button,.mat-input-element::-webkit-search-results-decoration{-webkit-appearance:none}.mat-input-element::-webkit-contacts-auto-fill-button,.mat-input-element::-webkit-caps-lock-indicator,.mat-input-element::-webkit-credentials-auto-fill-button{visibility:hidden}.mat-input-element[type=date],.mat-input-element[type=datetime],.mat-input-element[type=datetime-local],.mat-input-element[type=month],.mat-input-element[type=week],.mat-input-element[type=time]{line-height:1}.mat-input-element[type=date]::after,.mat-input-element[type=datetime]::after,.mat-input-element[type=datetime-local]::after,.mat-input-element[type=month]::after,.mat-input-element[type=week]::after,.mat-input-element[type=time]::after{content:\\\" \\\";white-space:pre;width:1px}.mat-input-element::-webkit-inner-spin-button,.mat-input-element::-webkit-calendar-picker-indicator,.mat-input-element::-webkit-clear-button{font-size:.75em}.mat-input-element::placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-moz-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-moz-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element::-webkit-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element::-webkit-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-input-element:-ms-input-placeholder{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-input-element:-ms-input-placeholder:-ms-input-placeholder{-ms-user-select:text}.mat-form-field-hide-placeholder .mat-input-element::placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-moz-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element::-webkit-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}.mat-form-field-hide-placeholder .mat-input-element:-ms-input-placeholder{color:transparent !important;-webkit-text-fill-color:transparent;transition:none}textarea.mat-input-element{resize:vertical;overflow:auto}textarea.mat-input-element.cdk-textarea-autosize{resize:none}textarea.mat-input-element{padding:2px 0;margin:-2px 0}select.mat-input-element{-moz-appearance:none;-webkit-appearance:none;position:relative;background-color:transparent;display:inline-flex;box-sizing:border-box;padding-top:1em;top:-1em;margin-bottom:-1em}select.mat-input-element::-ms-expand{display:none}select.mat-input-element::-moz-focus-inner{border:0}select.mat-input-element:not(:disabled){cursor:pointer}select.mat-input-element::-ms-value{color:inherit;background:none}.mat-focused .cdk-high-contrast-active select.mat-input-element::-ms-value{color:inherit}.mat-form-field-type-mat-native-select .mat-form-field-infix::after{content:\\\"\\\";width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;position:absolute;top:50%;right:0;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-form-field-type-mat-native-select .mat-form-field-infix::after{right:auto;left:0}.mat-form-field-type-mat-native-select .mat-input-element{padding-right:15px}[dir=rtl] .mat-form-field-type-mat-native-select .mat-input-element{padding-right:0;padding-left:15px}.mat-form-field-type-mat-native-select .mat-form-field-label-wrapper{max-width:calc(100% - 10px)}.mat-form-field-type-mat-native-select.mat-form-field-appearance-outline .mat-form-field-infix::after{margin-top:-5px}.mat-form-field-type-mat-native-select.mat-form-field-appearance-fill .mat-form-field-infix::after{margin-top:-10px}\\n\", \".mat-form-field-appearance-legacy .mat-form-field-label{transform:perspective(100px);-ms-transform:none}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon{width:1em}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button{font:inherit;vertical-align:baseline}.mat-form-field-appearance-legacy .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field-appearance-legacy .mat-form-field-suffix .mat-icon-button .mat-icon{font-size:inherit}.mat-form-field-appearance-legacy .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-legacy .mat-form-field-ripple{top:0;height:2px;overflow:hidden}.cdk-high-contrast-active .mat-form-field-appearance-legacy .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-legacy.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-legacy.mat-form-field-invalid:not(.mat-focused) .mat-form-field-ripple{height:1px}\\n\", \".mat-form-field-appearance-outline .mat-form-field-wrapper{margin:.25em 0}.mat-form-field-appearance-outline .mat-form-field-flex{padding:0 .75em 0 .75em;margin-top:-0.25em;position:relative}.mat-form-field-appearance-outline .mat-form-field-prefix,.mat-form-field-appearance-outline .mat-form-field-suffix{top:.25em}.mat-form-field-appearance-outline .mat-form-field-outline{display:flex;position:absolute;top:.25em;left:0;right:0;bottom:0;pointer-events:none}.mat-form-field-appearance-outline .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-end{border:1px solid currentColor;min-width:5px}.mat-form-field-appearance-outline .mat-form-field-outline-start{border-radius:5px 0 0 5px;border-right-style:none}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-start{border-right-style:solid;border-left-style:none;border-radius:0 5px 5px 0}.mat-form-field-appearance-outline .mat-form-field-outline-end{border-radius:0 5px 5px 0;border-left-style:none;flex-grow:1}[dir=rtl] .mat-form-field-appearance-outline .mat-form-field-outline-end{border-left-style:solid;border-right-style:none;border-radius:5px 0 0 5px}.mat-form-field-appearance-outline .mat-form-field-outline-gap{border-radius:.000001px;border:1px solid currentColor;border-left-style:none;border-right-style:none}.mat-form-field-appearance-outline.mat-form-field-can-float.mat-form-field-should-float .mat-form-field-outline-gap{border-top-color:transparent}.mat-form-field-appearance-outline .mat-form-field-outline-thick{opacity:0}.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-start,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-end,.mat-form-field-appearance-outline .mat-form-field-outline-thick .mat-form-field-outline-gap{border-width:2px}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline{opacity:0;transition:opacity 100ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline.mat-focused .mat-form-field-outline-thick,.mat-form-field-appearance-outline.mat-form-field-invalid .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline{opacity:0;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-outline:not(.mat-form-field-disabled) .mat-form-field-flex:hover .mat-form-field-outline-thick{opacity:1}.mat-form-field-appearance-outline .mat-form-field-subscript-wrapper{padding:0 1em}.mat-form-field-appearance-outline._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-start,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-end,.mat-form-field-appearance-outline._mat-animation-noopable .mat-form-field-outline-gap{transition:none}\\n\", \".mat-form-field-appearance-standard .mat-form-field-flex{padding-top:.75em}.mat-form-field-appearance-standard .mat-form-field-underline{height:1px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-underline{height:0;border-top:solid 1px}.mat-form-field-appearance-standard .mat-form-field-ripple{bottom:0;height:2px}.cdk-high-contrast-active .mat-form-field-appearance-standard .mat-form-field-ripple{height:0;border-top:solid 2px}.mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{background-position:0;background-color:transparent}.cdk-high-contrast-active .mat-form-field-appearance-standard.mat-form-field-disabled .mat-form-field-underline{border-top-style:dotted;border-top-width:2px}.mat-form-field-appearance-standard:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{opacity:1;transform:none;transition:opacity 600ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-form-field-appearance-standard._mat-animation-noopable:not(.mat-form-field-disabled) .mat-form-field-flex:hover~.mat-form-field-underline .mat-form-field-ripple{transition:none}\\n\"], encapsulation: 2, data: { animation: [matFormFieldAnimations.transitionMessages] }, changeDetection: 0 });\n    return MatFormField;\n})();\nlet form_field_MatFormFieldModule = /*@__PURE__*/ (() => {\n    class MatFormFieldModule {\n    }\n    MatFormFieldModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: MatFormFieldModule });\n    MatFormFieldModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function MatFormFieldModule_Factory(t) { return new (t || MatFormFieldModule)(); }, imports: [[\n                common[\"b\" /* CommonModule */],\n                core_MatCommonModule,\n                observers_ObserversModule,\n            ], core_MatCommonModule] });\n    return MatFormFieldModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](form_field_MatFormFieldModule, { declarations: function () { return [form_field_MatError, form_field_MatFormField, form_field_MatHint, form_field_MatLabel, form_field_MatPlaceholder, form_field_MatPrefix, form_field_MatSuffix]; }, imports: function () {\n            return [common[\"b\" /* CommonModule */],\n                core_MatCommonModule,\n                observers_ObserversModule];\n        }, exports: function () { return [core_MatCommonModule, form_field_MatError, form_field_MatFormField, form_field_MatHint, form_field_MatLabel, form_field_MatPlaceholder, form_field_MatPrefix, form_field_MatSuffix]; } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=form-field.js.map\n\n// EXTERNAL MODULE: ./node_modules/rxjs/_esm2015/internal/observable/defer.js\nvar defer = __webpack_require__(\"NXyV\");\n\n// CONCATENATED MODULE: ./node_modules/@angular/material/__ivy_ngcc__/fesm2015/select.js\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * The following are all the animations for the mat-select component, with each\n * const containing the metadata for one animation.\n *\n * The values below match the implementation of the AngularJS Material mat-select animation.\n * @docs-private\n */\n\n\n\n\n\n\n\n\n\nconst select_c0 = [\"trigger\"];\nconst select_c1 = [\"panel\"];\nfunction MatSelect_span_4_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"span\", 8);\n        core[\"uc\" /* text */](1);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r2 = core[\"bc\" /* nextContext */]();\n        core[\"Ab\" /* advance */](1);\n        core[\"vc\" /* textInterpolate */](ctx_r2.placeholder);\n    }\n}\nfunction MatSelect_span_5_span_1_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"span\", 12);\n        core[\"uc\" /* text */](1);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r5 = core[\"bc\" /* nextContext */](2);\n        core[\"Ab\" /* advance */](1);\n        core[\"vc\" /* textInterpolate */](ctx_r5.triggerValue);\n    }\n}\nfunction MatSelect_span_5_ng_content_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"cc\" /* projection */](0, 0, [\"*ngSwitchCase\", \"true\"]);\n    }\n}\nfunction MatSelect_span_5_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Sb\" /* elementStart */](0, \"span\", 9);\n        core[\"sc\" /* template */](1, MatSelect_span_5_span_1_Template, 2, 1, \"span\", 10);\n        core[\"sc\" /* template */](2, MatSelect_span_5_ng_content_2_Template, 1, 0, \"ng-content\", 11);\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r3 = core[\"bc\" /* nextContext */]();\n        core[\"ec\" /* property */](\"ngSwitch\", !!ctx_r3.customTrigger);\n        core[\"Ab\" /* advance */](2);\n        core[\"ec\" /* property */](\"ngSwitchCase\", true);\n    }\n}\nfunction MatSelect_ng_template_8_Template(rf, ctx) {\n    if (rf & 1) {\n        const _r9 = core[\"Tb\" /* getCurrentView */]();\n        core[\"Sb\" /* elementStart */](0, \"div\", 13);\n        core[\"Sb\" /* elementStart */](1, \"div\", 14, 15);\n        core[\"Zb\" /* listener */](\"@transformPanel.done\", function MatSelect_ng_template_8_Template_div_animation_transformPanel_done_1_listener($event) { core[\"mc\" /* restoreView */](_r9); const ctx_r8 = core[\"bc\" /* nextContext */](); return ctx_r8._panelDoneAnimatingStream.next($event.toState); })(\"keydown\", function MatSelect_ng_template_8_Template_div_keydown_1_listener($event) { core[\"mc\" /* restoreView */](_r9); const ctx_r10 = core[\"bc\" /* nextContext */](); return ctx_r10._handleKeydown($event); });\n        core[\"cc\" /* projection */](3, 1);\n        core[\"Rb\" /* elementEnd */]();\n        core[\"Rb\" /* elementEnd */]();\n    }\n    if (rf & 2) {\n        const ctx_r4 = core[\"bc\" /* nextContext */]();\n        core[\"ec\" /* property */](\"@transformPanelWrap\", undefined);\n        core[\"Ab\" /* advance */](1);\n        core[\"Db\" /* classMapInterpolate1 */](\"mat-select-panel \", ctx_r4._getPanelTheme(), \"\");\n        core[\"rc\" /* styleProp */](\"transform-origin\", ctx_r4._transformOrigin)(\"font-size\", ctx_r4._triggerFontSize, \"px\");\n        core[\"ec\" /* property */](\"ngClass\", ctx_r4.panelClass)(\"@transformPanel\", ctx_r4.multiple ? \"showing-multiple\" : \"showing\");\n        core[\"Bb\" /* attribute */](\"id\", ctx_r4.id + \"-panel\")(\"aria-multiselectable\", ctx_r4.multiple)(\"aria-label\", ctx_r4.ariaLabel || null)(\"aria-labelledby\", ctx_r4._getPanelAriaLabelledby());\n    }\n}\nconst select_c2 = [[[\"mat-select-trigger\"]], \"*\"];\nconst select_c3 = [\"mat-select-trigger\", \"*\"];\nconst matSelectAnimations = {\n    /**\n     * This animation ensures the select's overlay panel animation (transformPanel) is called when\n     * closing the select.\n     * This is needed due to https://github.com/angular/angular/issues/23302\n     */\n    transformPanelWrap: /*@__PURE__*/ Object(fesm2015_animations[\"l\" /* trigger */])('transformPanelWrap', [\n        /*@__PURE__*/ Object(fesm2015_animations[\"k\" /* transition */])('* => void', /*@__PURE__*/ Object(fesm2015_animations[\"g\" /* query */])('@transformPanel', [/*@__PURE__*/ Object(fesm2015_animations[\"f\" /* animateChild */])()], { optional: true }))\n    ]),\n    /**\n     * This animation transforms the select's overlay panel on and off the page.\n     *\n     * When the panel is attached to the DOM, it expands its width by the amount of padding, scales it\n     * up to 100% on the Y axis, fades in its border, and translates slightly up and to the\n     * side to ensure the option text correctly overlaps the trigger text.\n     *\n     * When the panel is removed from the DOM, it simply fades out linearly.\n     */\n    transformPanel: /*@__PURE__*/ Object(fesm2015_animations[\"l\" /* trigger */])('transformPanel', [\n        /*@__PURE__*/ Object(fesm2015_animations[\"i\" /* state */])('void', /*@__PURE__*/ Object(fesm2015_animations[\"j\" /* style */])({\n            transform: 'scaleY(0.8)',\n            minWidth: '100%',\n            opacity: 0\n        })),\n        /*@__PURE__*/ Object(fesm2015_animations[\"i\" /* state */])('showing', /*@__PURE__*/ Object(fesm2015_animations[\"j\" /* style */])({\n            opacity: 1,\n            minWidth: 'calc(100% + 32px)',\n            transform: 'scaleY(1)'\n        })),\n        /*@__PURE__*/ Object(fesm2015_animations[\"i\" /* state */])('showing-multiple', /*@__PURE__*/ Object(fesm2015_animations[\"j\" /* style */])({\n            opacity: 1,\n            minWidth: 'calc(100% + 64px)',\n            transform: 'scaleY(1)'\n        })),\n        /*@__PURE__*/ Object(fesm2015_animations[\"k\" /* transition */])('void => *', /*@__PURE__*/ Object(fesm2015_animations[\"e\" /* animate */])('120ms cubic-bezier(0, 0, 0.2, 1)')),\n        /*@__PURE__*/ Object(fesm2015_animations[\"k\" /* transition */])('* => void', /*@__PURE__*/ Object(fesm2015_animations[\"e\" /* animate */])('100ms 25ms linear', /*@__PURE__*/ Object(fesm2015_animations[\"j\" /* style */])({ opacity: 0 })))\n    ])\n};\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Returns an exception to be thrown when attempting to change a select's `multiple` option\n * after initialization.\n * @docs-private\n */\nfunction getMatSelectDynamicMultipleError() {\n    return Error('Cannot change `multiple` mode of select after initialization.');\n}\n/**\n * Returns an exception to be thrown when attempting to assign a non-array value to a select\n * in `multiple` mode. Note that `undefined` and `null` are still valid values to allow for\n * resetting the value.\n * @docs-private\n */\nfunction getMatSelectNonArrayValueError() {\n    return Error('Value must be an array in multiple-selection mode.');\n}\n/**\n * Returns an exception to be thrown when assigning a non-function value to the comparator\n * used to determine if a value corresponds to an option. Note that whether the function\n * actually takes two values and returns a boolean is not checked.\n */\nfunction getMatSelectNonFunctionValueError() {\n    return Error('`compareWith` must be a function.');\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nlet select_nextUniqueId = 0;\n/**\n * The following style constants are necessary to save here in order\n * to properly calculate the alignment of the selected option over\n * the trigger element.\n */\n/**\n * The max height of the select's overlay panel.\n * @deprecated To be turned into a private variable.\n * @breaking-change 12.0.0\n */\nconst SELECT_PANEL_MAX_HEIGHT = 256;\n/**\n * The panel's padding on the x-axis.\n * @deprecated To be turned into a private variable.\n * @breaking-change 12.0.0\n */\nconst SELECT_PANEL_PADDING_X = 16;\n/**\n * The panel's x axis padding if it is indented (e.g. there is an option group).\n * @deprecated To be turned into a private variable.\n * @breaking-change 12.0.0\n */\nconst SELECT_PANEL_INDENT_PADDING_X = SELECT_PANEL_PADDING_X * 2;\n/**\n * The height of the select items in `em` units.\n * @deprecated To be turned into a private variable.\n * @breaking-change 12.0.0\n */\nconst SELECT_ITEM_HEIGHT_EM = 3;\n// TODO(josephperrott): Revert to a constant after 2018 spec updates are fully merged.\n/**\n * Distance between the panel edge and the option text in\n * multi-selection mode.\n *\n * Calculated as:\n * (SELECT_PANEL_PADDING_X * 1.5) + 16 = 40\n * The padding is multiplied by 1.5 because the checkbox's margin is half the padding.\n * The checkbox width is 16px.\n *\n * @deprecated To be turned into a private variable.\n * @breaking-change 12.0.0\n */\nconst SELECT_MULTIPLE_PANEL_PADDING_X = SELECT_PANEL_PADDING_X * 1.5 + 16;\n/**\n * The select panel will only \"fit\" inside the viewport if it is positioned at\n * this value or more away from the viewport boundary.\n *\n * @deprecated To be turned into a private variable.\n * @breaking-change 12.0.0\n */\nconst SELECT_PANEL_VIEWPORT_PADDING = 8;\n/** Injection token that determines the scroll handling while a select is open. */\nconst MAT_SELECT_SCROLL_STRATEGY = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('mat-select-scroll-strategy');\n/** @docs-private */\nfunction MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\n    return () => overlay.scrollStrategies.reposition();\n}\n/** Injection token that can be used to provide the default options the select module. */\nconst MAT_SELECT_CONFIG = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MAT_SELECT_CONFIG');\n/** @docs-private */\nconst MAT_SELECT_SCROLL_STRATEGY_PROVIDER = {\n    provide: MAT_SELECT_SCROLL_STRATEGY,\n    deps: [overlay_Overlay],\n    useFactory: MAT_SELECT_SCROLL_STRATEGY_PROVIDER_FACTORY,\n};\n/** Change event object that is emitted when the select value has changed. */\nclass MatSelectChange {\n    constructor(\n    /** Reference to the select that emitted the change event. */\n    source, \n    /** Current value of the select that emitted the event. */\n    value) {\n        this.source = source;\n        this.value = value;\n    }\n}\n// Boilerplate for applying mixins to MatSelect.\n/** @docs-private */\nclass MatSelectBase {\n    constructor(_elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl) {\n        this._elementRef = _elementRef;\n        this._defaultErrorStateMatcher = _defaultErrorStateMatcher;\n        this._parentForm = _parentForm;\n        this._parentFormGroup = _parentFormGroup;\n        this.ngControl = ngControl;\n    }\n}\nconst _MatSelectMixinBase = /*@__PURE__*/ mixinDisableRipple(/*@__PURE__*/ mixinTabIndex(/*@__PURE__*/ mixinDisabled(/*@__PURE__*/ mixinErrorState(MatSelectBase))));\n/**\n * Injection token that can be used to reference instances of `MatSelectTrigger`. It serves as\n * alternative token to the actual `MatSelectTrigger` class which could cause unnecessary\n * retention of the class and its directive metadata.\n */\nconst MAT_SELECT_TRIGGER = /*@__PURE__*/ new core[\"q\" /* InjectionToken */]('MatSelectTrigger');\nlet select_MatSelectTrigger = /*@__PURE__*/ (() => {\n    class MatSelectTrigger {\n    }\n    MatSelectTrigger.fac = function MatSelectTrigger_Factory(t) { return new (t || MatSelectTrigger)(); };\n    MatSelectTrigger.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: MatSelectTrigger, selectors: [[\"mat-select-trigger\"]], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([{ provide: MAT_SELECT_TRIGGER, useExisting: MatSelectTrigger }])] });\n    return MatSelectTrigger;\n})();\nlet select_MatSelectBase = /*@__PURE__*/ (() => {\n    class _MatSelectBase extends _MatSelectMixinBase {\n        constructor(_viewportRuler, _changeDetectorRef, _ngZone, _defaultErrorStateMatcher, elementRef, _dir, _parentForm, _parentFormGroup, _parentFormField, ngControl, tabIndex, scrollStrategyFactory, _liveAnnouncer, _defaultOptions) {\n            var _a, _b, _c;\n            super(elementRef, _defaultErrorStateMatcher, _parentForm, _parentFormGroup, ngControl);\n            this._viewportRuler = _viewportRuler;\n            this._changeDetectorRef = _changeDetectorRef;\n            this._ngZone = _ngZone;\n            this._dir = _dir;\n            this._parentFormField = _parentFormField;\n            this.ngControl = ngControl;\n            this._liveAnnouncer = _liveAnnouncer;\n            this._defaultOptions = _defaultOptions;\n            /** Whether or not the overlay panel is open. */\n            this._panelOpen = false;\n            /** Comparison function to specify which option is displayed. Defaults to object equality. */\n            this._compareWith = (o1, o2) => o1 === o2;\n            /** Unique id for this input. */\n            this._uid = `mat-select-${select_nextUniqueId++}`;\n            /** Current `ariar-labelledby` value for the select trigger. */\n            this._triggerAriaLabelledBy = null;\n            /** Emits whenever the component is destroyed. */\n            this._destroy = new Subject[\"a\" /* Subject */]();\n            /** `View -> model callback called when value changes` */\n            this._onChange = () => { };\n            /** `View -> model callback called when select has been touched` */\n            this._onTouched = () => { };\n            /** ID for the DOM node containing the select's value. */\n            this._valueId = `mat-select-value-${select_nextUniqueId++}`;\n            /** Emits when the panel element is finished transforming in. */\n            this._panelDoneAnimatingStream = new Subject[\"a\" /* Subject */]();\n            this._overlayPanelClass = ((_a = this._defaultOptions) === null || _a === void 0 ? void 0 : _a.overlayPanelClass) || '';\n            this._focused = false;\n            /** A name for this control that can be used by `mat-form-field`. */\n            this.controlType = 'mat-select';\n            this._required = false;\n            this._multiple = false;\n            this._disableOptionCentering = (_c = (_b = this._defaultOptions) === null || _b === void 0 ? void 0 : _b.disableOptionCentering) !== null && _c !== void 0 ? _c : false;\n            /** Aria label of the select. */\n            this.ariaLabel = '';\n            /** Combined stream of all of the child options' change events. */\n            this.optionSelectionChanges = Object(defer[\"a\" /* defer */])(() => {\n                const options = this.options;\n                if (options) {\n                    return options.changes.pipe(Object(startWith[\"a\" /* startWith */])(options), Object(switchMap[\"a\" /* switchMap */])(() => Object(merge[\"a\" /* merge */])(...options.map(option => option.onSelectionChange))));\n                }\n                return this._ngZone.onStable\n                    .pipe(Object(take[\"a\" /* take */])(1), Object(switchMap[\"a\" /* switchMap */])(() => this.optionSelectionChanges));\n            });\n            /** Event emitted when the select panel has been toggled. */\n            this.openedChange = new core[\"n\" /* EventEmitter */]();\n            /** Event emitted when the select has been opened. */\n            this._openedStream = this.openedChange.pipe(Object(filter[\"a\" /* filter */])(o => o), Object(map[\"a\" /* map */])(() => { }));\n            /** Event emitted when the select has been closed. */\n            this._closedStream = this.openedChange.pipe(Object(filter[\"a\" /* filter */])(o => !o), Object(map[\"a\" /* map */])(() => { }));\n            /** Event emitted when the selected value has been changed by the user. */\n            this.selectionChange = new core[\"n\" /* EventEmitter */]();\n            /**\n             * Event that emits whenever the raw value of the select changes. This is here primarily\n             * to facilitate the two-way binding for the `value` input.\n             * @docs-private\n             */\n            this.valueChange = new core[\"n\" /* EventEmitter */]();\n            if (this.ngControl) {\n                // Note: we provide the value accessor through here, instead of\n                // the `providers` to avoid running into a circular import.\n                this.ngControl.valueAccessor = this;\n            }\n            // Note that we only want to set this when the defaults pass it in, otherwise it should\n            // stay as `undefined` so that it falls back to the default in the key manager.\n            if ((_defaultOptions === null || _defaultOptions === void 0 ? void 0 : _defaultOptions.typeaheadDebounceInterval) != null) {\n                this._typeaheadDebounceInterval = _defaultOptions.typeaheadDebounceInterval;\n            }\n            this._scrollStrategyFactory = scrollStrategyFactory;\n            this._scrollStrategy = this._scrollStrategyFactory();\n            this.tabIndex = parseInt(tabIndex) || 0;\n            // Force setter to be called in case id was not specified.\n            this.id = this.id;\n        }\n        /** Whether the select is focused. */\n        get focused() {\n            return this._focused || this._panelOpen;\n        }\n        /** Placeholder to be shown if no value has been selected. */\n        get placeholder() { return this._placeholder; }\n        set placeholder(value) {\n            this._placeholder = value;\n            this.stateChanges.next();\n        }\n        /** Whether the component is required. */\n        get required() { return this._required; }\n        set required(value) {\n            this._required = coerceBooleanProperty(value);\n            this.stateChanges.next();\n        }\n        /** Whether the user should be allowed to select multiple options. */\n        get multiple() { return this._multiple; }\n        set multiple(value) {\n            if (this._selectionModel && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getMatSelectDynamicMultipleError();\n            }\n            this._multiple = coerceBooleanProperty(value);\n        }\n        /** Whether to center the active option over the trigger. */\n        get disableOptionCentering() { return this._disableOptionCentering; }\n        set disableOptionCentering(value) {\n            this._disableOptionCentering = coerceBooleanProperty(value);\n        }\n        /**\n         * Function to compare the option values with the selected values. The first argument\n         * is a value from an option. The second is a value from the selection. A boolean\n         * should be returned.\n         */\n        get compareWith() { return this._compareWith; }\n        set compareWith(fn) {\n            if (typeof fn !== 'function' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                throw getMatSelectNonFunctionValueError();\n            }\n            this._compareWith = fn;\n            if (this._selectionModel) {\n                // A different comparator means the selection could change.\n                this._initializeSelection();\n            }\n        }\n        /** Value of the select control. */\n        get value() { return this._value; }\n        set value(newValue) {\n            // Always re-assign an array, because it might have been mutated.\n            if (newValue !== this._value || (this._multiple && Array.isArray(newValue))) {\n                if (this.options) {\n                    this._setSelectionByValue(newValue);\n                }\n                this._value = newValue;\n            }\n        }\n        /** Time to wait in milliseconds after the last keystroke before moving focus to an item. */\n        get typeaheadDebounceInterval() { return this._typeaheadDebounceInterval; }\n        set typeaheadDebounceInterval(value) {\n            this._typeaheadDebounceInterval = coerceNumberProperty(value);\n        }\n        /** Unique id of the element. */\n        get id() { return this._id; }\n        set id(value) {\n            this._id = value || this._uid;\n            this.stateChanges.next();\n        }\n        ngOnInit() {\n            this._selectionModel = new collections_SelectionModel(this.multiple);\n            this.stateChanges.next();\n            // We need `distinctUntilChanged` here, because some browsers will\n            // fire the animation end event twice for the same animation. See:\n            // https://github.com/angular/angular/issues/24084\n            this._panelDoneAnimatingStream\n                .pipe(distinctUntilChanged(), takeUntil(this._destroy))\n                .subscribe(() => this._panelDoneAnimating(this.panelOpen));\n        }\n        ngAfterContentInit() {\n            this._initKeyManager();\n            this._selectionModel.changed.pipe(takeUntil(this._destroy)).subscribe(event => {\n                event.added.forEach(option => option.select());\n                event.removed.forEach(option => option.deselect());\n            });\n            this.options.changes.pipe(Object(startWith[\"a\" /* startWith */])(null), takeUntil(this._destroy)).subscribe(() => {\n                this._resetOptions();\n                this._initializeSelection();\n            });\n        }\n        ngDoCheck() {\n            const newAriaLabelledby = this._getTriggerAriaLabelledby();\n            // We have to manage setting the `aria-labelledby` ourselves, because part of its value\n            // is computed as a result of a content query which can cause this binding to trigger a\n            // \"changed after checked\" error.\n            if (newAriaLabelledby !== this._triggerAriaLabelledBy) {\n                const element = this._elementRef.nativeElement;\n                this._triggerAriaLabelledBy = newAriaLabelledby;\n                if (newAriaLabelledby) {\n                    element.setAttribute('aria-labelledby', newAriaLabelledby);\n                }\n                else {\n                    element.removeAttribute('aria-labelledby');\n                }\n            }\n            if (this.ngControl) {\n                this.updateErrorState();\n            }\n        }\n        ngOnChanges(changes) {\n            // Updating the disabled state is handled by `mixinDisabled`, but we need to additionally let\n            // the parent form field know to run change detection when the disabled state changes.\n            if (changes['disabled']) {\n                this.stateChanges.next();\n            }\n            if (changes['typeaheadDebounceInterval'] && this._keyManager) {\n                this._keyManager.withTypeAhead(this._typeaheadDebounceInterval);\n            }\n        }\n        ngOnDestroy() {\n            this._destroy.next();\n            this._destroy.complete();\n            this.stateChanges.complete();\n        }\n        /** Toggles the overlay panel open or closed. */\n        toggle() {\n            this.panelOpen ? this.close() : this.open();\n        }\n        /** Opens the overlay panel. */\n        open() {\n            if (this._canOpen()) {\n                this._panelOpen = true;\n                this._keyManager.withHorizontalOrientation(null);\n                this._highlightCorrectOption();\n                this._changeDetectorRef.markForCheck();\n            }\n        }\n        /** Closes the overlay panel and focuses the host element. */\n        close() {\n            if (this._panelOpen) {\n                this._panelOpen = false;\n                this._keyManager.withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr');\n                this._changeDetectorRef.markForCheck();\n                this._onTouched();\n            }\n        }\n        /**\n         * Sets the select's value. Part of the ControlValueAccessor interface\n         * required to integrate with Angular's core forms API.\n         *\n         * @param value New value to be written to the model.\n         */\n        writeValue(value) {\n            this.value = value;\n        }\n        /**\n         * Saves a callback function to be invoked when the select's value\n         * changes from user input. Part of the ControlValueAccessor interface\n         * required to integrate with Angular's core forms API.\n         *\n         * @param fn Callback to be triggered when the value changes.\n         */\n        registerOnChange(fn) {\n            this._onChange = fn;\n        }\n        /**\n         * Saves a callback function to be invoked when the select is blurred\n         * by the user. Part of the ControlValueAccessor interface required\n         * to integrate with Angular's core forms API.\n         *\n         * @param fn Callback to be triggered when the component has been touched.\n         */\n        registerOnTouched(fn) {\n            this._onTouched = fn;\n        }\n        /**\n         * Disables the select. Part of the ControlValueAccessor interface required\n         * to integrate with Angular's core forms API.\n         *\n         * @param isDisabled Sets whether the component is disabled.\n         */\n        setDisabledState(isDisabled) {\n            this.disabled = isDisabled;\n            this._changeDetectorRef.markForCheck();\n            this.stateChanges.next();\n        }\n        /** Whether or not the overlay panel is open. */\n        get panelOpen() {\n            return this._panelOpen;\n        }\n        /** The currently selected option. */\n        get selected() {\n            return this.multiple ? this._selectionModel.selected : this._selectionModel.selected[0];\n        }\n        /** The value displayed in the trigger. */\n        get triggerValue() {\n            if (this.empty) {\n                return '';\n            }\n            if (this._multiple) {\n                const selectedOptions = this._selectionModel.selected.map(option => option.viewValue);\n                if (this._isRtl()) {\n                    selectedOptions.reverse();\n                }\n                // TODO(crisbeto): delimiter should be configurable for proper localization.\n                return selectedOptions.join(', ');\n            }\n            return this._selectionModel.selected[0].viewValue;\n        }\n        /** Whether the element is in RTL mode. */\n        _isRtl() {\n            return this._dir ? this._dir.value === 'rtl' : false;\n        }\n        /** Handles all keydown events on the select. */\n        _handleKeydown(event) {\n            if (!this.disabled) {\n                this.panelOpen ? this._handleOpenKeydown(event) : this._handleClosedKeydown(event);\n            }\n        }\n        /** Handles keyboard events while the select is closed. */\n        _handleClosedKeydown(event) {\n            const keyCode = event.keyCode;\n            const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW ||\n                keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW;\n            const isOpenKey = keyCode === ENTER || keyCode === SPACE;\n            const manager = this._keyManager;\n            // Open the select on ALT + arrow key to match the native <select>\n            if (!manager.isTyping() && (isOpenKey && !hasModifierKey(event)) ||\n                ((this.multiple || event.altKey) && isArrowKey)) {\n                event.preventDefault(); // prevents the page from scrolling down when pressing space\n                this.open();\n            }\n            else if (!this.multiple) {\n                const previouslySelectedOption = this.selected;\n                manager.onKeydown(event);\n                const selectedOption = this.selected;\n                // Since the value has changed, we need to announce it ourselves.\n                if (selectedOption && previouslySelectedOption !== selectedOption) {\n                    // We set a duration on the live announcement, because we want the live element to be\n                    // cleared after a while so that users can't navigate to it using the arrow keys.\n                    this._liveAnnouncer.announce(selectedOption.viewValue, 10000);\n                }\n            }\n        }\n        /** Handles keyboard events when the selected is open. */\n        _handleOpenKeydown(event) {\n            const manager = this._keyManager;\n            const keyCode = event.keyCode;\n            const isArrowKey = keyCode === DOWN_ARROW || keyCode === UP_ARROW;\n            const isTyping = manager.isTyping();\n            if (isArrowKey && event.altKey) {\n                // Close the select on ALT + arrow key to match the native <select>\n                event.preventDefault();\n                this.close();\n                // Don't do anything in this case if the user is typing,\n                // because the typing sequence can include the space key.\n            }\n            else if (!isTyping && (keyCode === ENTER || keyCode === SPACE) && manager.activeItem &&\n                !hasModifierKey(event)) {\n                event.preventDefault();\n                manager.activeItem._selectViaInteraction();\n            }\n            else if (!isTyping && this._multiple && keyCode === A && event.ctrlKey) {\n                event.preventDefault();\n                const hasDeselectedOptions = this.options.some(opt => !opt.disabled && !opt.selected);\n                this.options.forEach(option => {\n                    if (!option.disabled) {\n                        hasDeselectedOptions ? option.select() : option.deselect();\n                    }\n                });\n            }\n            else {\n                const previouslyFocusedIndex = manager.activeItemIndex;\n                manager.onKeydown(event);\n                if (this._multiple && isArrowKey && event.shiftKey && manager.activeItem &&\n                    manager.activeItemIndex !== previouslyFocusedIndex) {\n                    manager.activeItem._selectViaInteraction();\n                }\n            }\n        }\n        _onFocus() {\n            if (!this.disabled) {\n                this._focused = true;\n                this.stateChanges.next();\n            }\n        }\n        /**\n         * Calls the touched callback only if the panel is closed. Otherwise, the trigger will\n         * \"blur\" to the panel when it opens, causing a false positive.\n         */\n        _onBlur() {\n            this._focused = false;\n            if (!this.disabled && !this.panelOpen) {\n                this._onTouched();\n                this._changeDetectorRef.markForCheck();\n                this.stateChanges.next();\n            }\n        }\n        /**\n         * Callback that is invoked when the overlay panel has been attached.\n         */\n        _onAttached() {\n            this.overlayDir.positionChange.pipe(Object(take[\"a\" /* take */])(1)).subscribe(() => {\n                this._changeDetectorRef.detectChanges();\n                this._positioningSettled();\n            });\n        }\n        /** Returns the theme to be used on the panel. */\n        _getPanelTheme() {\n            return this._parentFormField ? `mat-${this._parentFormField.color}` : '';\n        }\n        /** Whether the select has a value. */\n        get empty() {\n            return !this._selectionModel || this._selectionModel.isEmpty();\n        }\n        _initializeSelection() {\n            // Defer setting the value in order to avoid the \"Expression\n            // has changed after it was checked\" errors from Angular.\n            Promise.resolve().then(() => {\n                this._setSelectionByValue(this.ngControl ? this.ngControl.value : this._value);\n                this.stateChanges.next();\n            });\n        }\n        /**\n         * Sets the selected option based on a value. If no option can be\n         * found with the designated value, the select trigger is cleared.\n         */\n        _setSelectionByValue(value) {\n            this._selectionModel.selected.forEach(option => option.setInactiveStyles());\n            this._selectionModel.clear();\n            if (this.multiple && value) {\n                if (!Array.isArray(value) && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n                    throw getMatSelectNonArrayValueError();\n                }\n                value.forEach((currentValue) => this._selectValue(currentValue));\n                this._sortValues();\n            }\n            else {\n                const correspondingOption = this._selectValue(value);\n                // Shift focus to the active item. Note that we shouldn't do this in multiple\n                // mode, because we don't know what option the user interacted with last.\n                if (correspondingOption) {\n                    this._keyManager.updateActiveItem(correspondingOption);\n                }\n                else if (!this.panelOpen) {\n                    // Otherwise reset the highlighted option. Note that we only want to do this while\n                    // closed, because doing it while open can shift the user's focus unnecessarily.\n                    this._keyManager.updateActiveItem(-1);\n                }\n            }\n            this._changeDetectorRef.markForCheck();\n        }\n        /**\n         * Finds and selects and option based on its value.\n         * @returns Option that has the corresponding value.\n         */\n        _selectValue(value) {\n            const correspondingOption = this.options.find((option) => {\n                // Skip options that are already in the model. This allows us to handle cases\n                // where the same primitive value is selected multiple times.\n                if (this._selectionModel.isSelected(option)) {\n                    return false;\n                }\n                try {\n                    // Treat null as a special reset value.\n                    return option.value != null && this._compareWith(option.value, value);\n                }\n                catch (error) {\n                    if (typeof ngDevMode === 'undefined' || ngDevMode) {\n                        // Notify developers of errors in their comparator.\n                        console.warn(error);\n                    }\n                    return false;\n                }\n            });\n            if (correspondingOption) {\n                this._selectionModel.select(correspondingOption);\n            }\n            return correspondingOption;\n        }\n        /** Sets up a key manager to listen to keyboard events on the overlay panel. */\n        _initKeyManager() {\n            this._keyManager = new ActiveDescendantKeyManager(this.options)\n                .withTypeAhead(this._typeaheadDebounceInterval)\n                .withVerticalOrientation()\n                .withHorizontalOrientation(this._isRtl() ? 'rtl' : 'ltr')\n                .withHomeAndEnd()\n                .withAllowedModifierKeys(['shiftKey']);\n            this._keyManager.tabOut.pipe(takeUntil(this._destroy)).subscribe(() => {\n                if (this.panelOpen) {\n                    // Select the active item when tabbing away. This is consistent with how the native\n                    // select behaves. Note that we only want to do this in single selection mode.\n                    if (!this.multiple && this._keyManager.activeItem) {\n                        this._keyManager.activeItem._selectViaInteraction();\n                    }\n                    // Restore focus to the trigger before closing. Ensures that the focus\n                    // position won't be lost if the user got focus into the overlay.\n                    this.focus();\n                    this.close();\n                }\n            });\n            this._keyManager.change.pipe(takeUntil(this._destroy)).subscribe(() => {\n                if (this._panelOpen && this.panel) {\n                    this._scrollOptionIntoView(this._keyManager.activeItemIndex || 0);\n                }\n                else if (!this._panelOpen && !this.multiple && this._keyManager.activeItem) {\n                    this._keyManager.activeItem._selectViaInteraction();\n                }\n            });\n        }\n        /** Drops current option subscriptions and IDs and resets from scratch. */\n        _resetOptions() {\n            const changedOrDestroyed = Object(merge[\"a\" /* merge */])(this.options.changes, this._destroy);\n            this.optionSelectionChanges.pipe(takeUntil(changedOrDestroyed)).subscribe(event => {\n                this._onSelect(event.source, event.isUserInput);\n                if (event.isUserInput && !this.multiple && this._panelOpen) {\n                    this.close();\n                    this.focus();\n                }\n            });\n            // Listen to changes in the internal state of the options and react accordingly.\n            // Handles cases like the labels of the selected options changing.\n            Object(merge[\"a\" /* merge */])(...this.options.map(option => option._stateChanges))\n                .pipe(takeUntil(changedOrDestroyed))\n                .subscribe(() => {\n                this._changeDetectorRef.markForCheck();\n                this.stateChanges.next();\n            });\n        }\n        /** Invoked when an option is clicked. */\n        _onSelect(option, isUserInput) {\n            const wasSelected = this._selectionModel.isSelected(option);\n            if (option.value == null && !this._multiple) {\n                option.deselect();\n                this._selectionModel.clear();\n                if (this.value != null) {\n                    this._propagateChanges(option.value);\n                }\n            }\n            else {\n                if (wasSelected !== option.selected) {\n                    option.selected ? this._selectionModel.select(option) :\n                        this._selectionModel.deselect(option);\n                }\n                if (isUserInput) {\n                    this._keyManager.setActiveItem(option);\n                }\n                if (this.multiple) {\n                    this._sortValues();\n                    if (isUserInput) {\n                        // In case the user selected the option with their mouse, we\n                        // want to restore focus back to the trigger, in order to\n                        // prevent the select keyboard controls from clashing with\n                        // the ones from `mat-option`.\n                        this.focus();\n                    }\n                }\n            }\n            if (wasSelected !== this._selectionModel.isSelected(option)) {\n                this._propagateChanges();\n            }\n            this.stateChanges.next();\n        }\n        /** Sorts the selected values in the selected based on their order in the panel. */\n        _sortValues() {\n            if (this.multiple) {\n                const options = this.options.toArray();\n                this._selectionModel.sort((a, b) => {\n                    return this.sortComparator ? this.sortComparator(a, b, options) :\n                        options.indexOf(a) - options.indexOf(b);\n                });\n                this.stateChanges.next();\n            }\n        }\n        /** Emits change event to set the model value. */\n        _propagateChanges(fallbackValue) {\n            let valueToEmit = null;\n            if (this.multiple) {\n                valueToEmit = this.selected.map(option => option.value);\n            }\n            else {\n                valueToEmit = this.selected ? this.selected.value : fallbackValue;\n            }\n            this._value = valueToEmit;\n            this.valueChange.emit(valueToEmit);\n            this._onChange(valueToEmit);\n            this.selectionChange.emit(this._getChangeEvent(valueToEmit));\n            this._changeDetectorRef.markForCheck();\n        }\n        /**\n         * Highlights the selected item. If no option is selected, it will highlight\n         * the first item instead.\n         */\n        _highlightCorrectOption() {\n            if (this._keyManager) {\n                if (this.empty) {\n                    this._keyManager.setFirstItemActive();\n                }\n                else {\n                    this._keyManager.setActiveItem(this._selectionModel.selected[0]);\n                }\n            }\n        }\n        /** Whether the panel is allowed to open. */\n        _canOpen() {\n            var _a;\n            return !this._panelOpen && !this.disabled && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        }\n        /** Focuses the select element. */\n        focus(options) {\n            this._elementRef.nativeElement.focus(options);\n        }\n        /** Gets the aria-labelledby for the select panel. */\n        _getPanelAriaLabelledby() {\n            var _a;\n            if (this.ariaLabel) {\n                return null;\n            }\n            const labelId = (_a = this._parentFormField) === null || _a === void 0 ? void 0 : _a.getLabelId();\n            const labelExpression = (labelId ? labelId + ' ' : '');\n            return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\n        }\n        /** Determines the `aria-activedescendant` to be set on the host. */\n        _getAriaActiveDescendant() {\n            if (this.panelOpen && this._keyManager && this._keyManager.activeItem) {\n                return this._keyManager.activeItem.id;\n            }\n            return null;\n        }\n        /** Gets the aria-labelledby of the select component trigger. */\n        _getTriggerAriaLabelledby() {\n            var _a;\n            if (this.ariaLabel) {\n                return null;\n            }\n            const labelId = (_a = this._parentFormField) === null || _a === void 0 ? void 0 : _a.getLabelId();\n            let value = (labelId ? labelId + ' ' : '') + this._valueId;\n            if (this.ariaLabelledby) {\n                value += ' ' + this.ariaLabelledby;\n            }\n            return value;\n        }\n        /** Called when the overlay panel is done animating. */\n        _panelDoneAnimating(isOpen) {\n            this.openedChange.emit(isOpen);\n        }\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        setDescribedByIds(ids) {\n            this._ariaDescribedby = ids.join(' ');\n        }\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        onContainerClick() {\n            this.focus();\n            this.open();\n        }\n        /**\n         * Implemented as part of MatFormFieldControl.\n         * @docs-private\n         */\n        get shouldLabelFloat() {\n            return this._panelOpen || !this.empty || (this._focused && !!this._placeholder);\n        }\n    }\n    _MatSelectBase.fac = function _MatSelectBase_Factory(t) { return new (t || _MatSelectBase)(core[\"Mb\" /* directiveInject */](scrolling_ViewportRuler), core[\"Mb\" /* directiveInject */](core[\"h\" /* ChangeDetectorRef */]), core[\"Mb\" /* directiveInject */](core[\"A\" /* NgZone */]), core[\"Mb\" /* directiveInject */](core_ErrorStateMatcher), core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */]), core[\"Mb\" /* directiveInject */](bidi_Directionality, 8), core[\"Mb\" /* directiveInject */](fesm2015_forms[\"i\" /* NgForm */], 8), core[\"Mb\" /* directiveInject */](fesm2015_forms[\"d\" /* FormGroupDirective */], 8), core[\"Mb\" /* directiveInject */](MAT_FORM_FIELD, 8), core[\"Mb\" /* directiveInject */](fesm2015_forms[\"f\" /* NgControl */], 10), core[\"Xb\" /* injectAttribute */]('tabindex'), core[\"Mb\" /* directiveInject */](MAT_SELECT_SCROLL_STRATEGY), core[\"Mb\" /* directiveInject */](a11y_LiveAnnouncer), core[\"Mb\" /* directiveInject */](MAT_SELECT_CONFIG, 8)); };\n    _MatSelectBase.dir = /*@__PURE__*/ core[\"Hb\" /* defineDirective */]({ type: _MatSelectBase, viewQuery: function _MatSelectBase_Query(rf, ctx) {\n            if (rf & 1) {\n                core[\"xc\" /* viewQuery */](select_c0, true);\n                core[\"xc\" /* viewQuery */](select_c1, true);\n                core[\"xc\" /* viewQuery */](overlay_CdkConnectedOverlay, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.trigger = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.panel = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.overlayDir = _t.first);\n            }\n        }, inputs: { ariaLabel: [\"aria-label\", \"ariaLabel\"], id: \"id\", placeholder: \"placeholder\", required: \"required\", multiple: \"multiple\", disableOptionCentering: \"disableOptionCentering\", compareWith: \"compareWith\", value: \"value\", typeaheadDebounceInterval: \"typeaheadDebounceInterval\", panelClass: \"panelClass\", ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"], errorStateMatcher: \"errorStateMatcher\", sortComparator: \"sortComparator\" }, outputs: { openedChange: \"openedChange\", _openedStream: \"opened\", _closedStream: \"closed\", selectionChange: \"selectionChange\", valueChange: \"valueChange\" }, features: [core[\"xb\" /* InheritDefinitionFeature */], core[\"yb\" /* NgOnChangesFeature */]] });\n    return _MatSelectBase;\n})();\nlet select_MatSelect = /*@__PURE__*/ (() => {\n    class MatSelect extends select_MatSelectBase {\n        constructor() {\n            super(...arguments);\n            /** The scroll position of the overlay panel, calculated to center the selected option. */\n            this._scrollTop = 0;\n            /** The cached font-size of the trigger element. */\n            this._triggerFontSize = 0;\n            /** The value of the select panel's transform-origin property. */\n            this._transformOrigin = 'top';\n            /**\n             * The y-offset of the overlay panel in relation to the trigger's top start corner.\n             * This must be adjusted to align the selected option text over the trigger text.\n             * when the panel opens. Will change based on the y-position of the selected option.\n             */\n            this._offsetY = 0;\n            this._positions = [\n                {\n                    originX: 'start',\n                    originY: 'top',\n                    overlayX: 'start',\n                    overlayY: 'top',\n                },\n                {\n                    originX: 'start',\n                    originY: 'bottom',\n                    overlayX: 'start',\n                    overlayY: 'bottom',\n                },\n            ];\n        }\n        /**\n         * Calculates the scroll position of the select's overlay panel.\n         *\n         * Attempts to center the selected option in the panel. If the option is\n         * too high or too low in the panel to be scrolled to the center, it clamps the\n         * scroll position to the min or max scroll positions respectively.\n         */\n        _calculateOverlayScroll(selectedIndex, scrollBuffer, maxScroll) {\n            const itemHeight = this._getItemHeight();\n            const optionOffsetFromScrollTop = itemHeight * selectedIndex;\n            const halfOptionHeight = itemHeight / 2;\n            // Starts at the optionOffsetFromScrollTop, which scrolls the option to the top of the\n            // scroll container, then subtracts the scroll buffer to scroll the option down to\n            // the center of the overlay panel. Half the option height must be re-added to the\n            // scrollTop so the option is centered based on its middle, not its top edge.\n            const optimalScrollPosition = optionOffsetFromScrollTop - scrollBuffer + halfOptionHeight;\n            return Math.min(Math.max(0, optimalScrollPosition), maxScroll);\n        }\n        ngOnInit() {\n            super.ngOnInit();\n            this._viewportRuler.change().pipe(takeUntil(this._destroy)).subscribe(() => {\n                if (this.panelOpen) {\n                    this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();\n                    this._changeDetectorRef.markForCheck();\n                }\n            });\n        }\n        open() {\n            if (super._canOpen()) {\n                super.open();\n                this._triggerRect = this.trigger.nativeElement.getBoundingClientRect();\n                // Note: The computed font-size will be a string pixel value (e.g. \"16px\").\n                // `parseInt` ignores the trailing 'px' and converts this to a number.\n                this._triggerFontSize =\n                    parseInt(getComputedStyle(this.trigger.nativeElement).fontSize || '0');\n                this._calculateOverlayPosition();\n                // Set the font size on the panel element once it exists.\n                this._ngZone.onStable.pipe(Object(take[\"a\" /* take */])(1)).subscribe(() => {\n                    if (this._triggerFontSize && this.overlayDir.overlayRef &&\n                        this.overlayDir.overlayRef.overlayElement) {\n                        this.overlayDir.overlayRef.overlayElement.style.fontSize = `${this._triggerFontSize}px`;\n                    }\n                });\n            }\n        }\n        /** Scrolls the active option into view. */\n        _scrollOptionIntoView(index) {\n            const labelCount = _countGroupLabelsBeforeOption(index, this.options, this.optionGroups);\n            const itemHeight = this._getItemHeight();\n            this.panel.nativeElement.scrollTop = _getOptionScrollPosition((index + labelCount) * itemHeight, itemHeight, this.panel.nativeElement.scrollTop, SELECT_PANEL_MAX_HEIGHT);\n        }\n        _positioningSettled() {\n            this._calculateOverlayOffsetX();\n            this.panel.nativeElement.scrollTop = this._scrollTop;\n        }\n        _panelDoneAnimating(isOpen) {\n            if (this.panelOpen) {\n                this._scrollTop = 0;\n            }\n            else {\n                this.overlayDir.offsetX = 0;\n                this._changeDetectorRef.markForCheck();\n            }\n            super._panelDoneAnimating(isOpen);\n        }\n        _getChangeEvent(value) {\n            return new MatSelectChange(this, value);\n        }\n        /**\n         * Sets the x-offset of the overlay panel in relation to the trigger's top start corner.\n         * This must be adjusted to align the selected option text over the trigger text when\n         * the panel opens. Will change based on LTR or RTL text direction. Note that the offset\n         * can't be calculated until the panel has been attached, because we need to know the\n         * content width in order to constrain the panel within the viewport.\n         */\n        _calculateOverlayOffsetX() {\n            const overlayRect = this.overlayDir.overlayRef.overlayElement.getBoundingClientRect();\n            const viewportSize = this._viewportRuler.getViewportSize();\n            const isRtl = this._isRtl();\n            const paddingWidth = this.multiple ? SELECT_MULTIPLE_PANEL_PADDING_X + SELECT_PANEL_PADDING_X :\n                SELECT_PANEL_PADDING_X * 2;\n            let offsetX;\n            // Adjust the offset, depending on the option padding.\n            if (this.multiple) {\n                offsetX = SELECT_MULTIPLE_PANEL_PADDING_X;\n            }\n            else if (this.disableOptionCentering) {\n                offsetX = SELECT_PANEL_PADDING_X;\n            }\n            else {\n                let selected = this._selectionModel.selected[0] || this.options.first;\n                offsetX = selected && selected.group ? SELECT_PANEL_INDENT_PADDING_X : SELECT_PANEL_PADDING_X;\n            }\n            // Invert the offset in LTR.\n            if (!isRtl) {\n                offsetX *= -1;\n            }\n            // Determine how much the select overflows on each side.\n            const leftOverflow = 0 - (overlayRect.left + offsetX - (isRtl ? paddingWidth : 0));\n            const rightOverflow = overlayRect.right + offsetX - viewportSize.width\n                + (isRtl ? 0 : paddingWidth);\n            // If the element overflows on either side, reduce the offset to allow it to fit.\n            if (leftOverflow > 0) {\n                offsetX += leftOverflow + SELECT_PANEL_VIEWPORT_PADDING;\n            }\n            else if (rightOverflow > 0) {\n                offsetX -= rightOverflow + SELECT_PANEL_VIEWPORT_PADDING;\n            }\n            // Set the offset directly in order to avoid having to go through change detection and\n            // potentially triggering \"changed after it was checked\" errors. Round the value to avoid\n            // blurry content in some browsers.\n            this.overlayDir.offsetX = Math.round(offsetX);\n            this.overlayDir.overlayRef.updatePosition();\n        }\n        /**\n         * Calculates the y-offset of the select's overlay panel in relation to the\n         * top start corner of the trigger. It has to be adjusted in order for the\n         * selected option to be aligned over the trigger when the panel opens.\n         */\n        _calculateOverlayOffsetY(selectedIndex, scrollBuffer, maxScroll) {\n            const itemHeight = this._getItemHeight();\n            const optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;\n            const maxOptionsDisplayed = Math.floor(SELECT_PANEL_MAX_HEIGHT / itemHeight);\n            let optionOffsetFromPanelTop;\n            // Disable offset if requested by user by returning 0 as value to offset\n            if (this.disableOptionCentering) {\n                return 0;\n            }\n            if (this._scrollTop === 0) {\n                optionOffsetFromPanelTop = selectedIndex * itemHeight;\n            }\n            else if (this._scrollTop === maxScroll) {\n                const firstDisplayedIndex = this._getItemCount() - maxOptionsDisplayed;\n                const selectedDisplayIndex = selectedIndex - firstDisplayedIndex;\n                // The first item is partially out of the viewport. Therefore we need to calculate what\n                // portion of it is shown in the viewport and account for it in our offset.\n                let partialItemHeight = itemHeight - (this._getItemCount() * itemHeight - SELECT_PANEL_MAX_HEIGHT) % itemHeight;\n                // Because the panel height is longer than the height of the options alone,\n                // there is always extra padding at the top or bottom of the panel. When\n                // scrolled to the very bottom, this padding is at the top of the panel and\n                // must be added to the offset.\n                optionOffsetFromPanelTop = selectedDisplayIndex * itemHeight + partialItemHeight;\n            }\n            else {\n                // If the option was scrolled to the middle of the panel using a scroll buffer,\n                // its offset will be the scroll buffer minus the half height that was added to\n                // center it.\n                optionOffsetFromPanelTop = scrollBuffer - itemHeight / 2;\n            }\n            // The final offset is the option's offset from the top, adjusted for the height difference,\n            // multiplied by -1 to ensure that the overlay moves in the correct direction up the page.\n            // The value is rounded to prevent some browsers from blurring the content.\n            return Math.round(optionOffsetFromPanelTop * -1 - optionHeightAdjustment);\n        }\n        /**\n         * Checks that the attempted overlay position will fit within the viewport.\n         * If it will not fit, tries to adjust the scroll position and the associated\n         * y-offset so the panel can open fully on-screen. If it still won't fit,\n         * sets the offset back to 0 to allow the fallback position to take over.\n         */\n        _checkOverlayWithinViewport(maxScroll) {\n            const itemHeight = this._getItemHeight();\n            const viewportSize = this._viewportRuler.getViewportSize();\n            const topSpaceAvailable = this._triggerRect.top - SELECT_PANEL_VIEWPORT_PADDING;\n            const bottomSpaceAvailable = viewportSize.height - this._triggerRect.bottom - SELECT_PANEL_VIEWPORT_PADDING;\n            const panelHeightTop = Math.abs(this._offsetY);\n            const totalPanelHeight = Math.min(this._getItemCount() * itemHeight, SELECT_PANEL_MAX_HEIGHT);\n            const panelHeightBottom = totalPanelHeight - panelHeightTop - this._triggerRect.height;\n            if (panelHeightBottom > bottomSpaceAvailable) {\n                this._adjustPanelUp(panelHeightBottom, bottomSpaceAvailable);\n            }\n            else if (panelHeightTop > topSpaceAvailable) {\n                this._adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll);\n            }\n            else {\n                this._transformOrigin = this._getOriginBasedOnOption();\n            }\n        }\n        /** Adjusts the overlay panel up to fit in the viewport. */\n        _adjustPanelUp(panelHeightBottom, bottomSpaceAvailable) {\n            // Browsers ignore fractional scroll offsets, so we need to round.\n            const distanceBelowViewport = Math.round(panelHeightBottom - bottomSpaceAvailable);\n            // Scrolls the panel up by the distance it was extending past the boundary, then\n            // adjusts the offset by that amount to move the panel up into the viewport.\n            this._scrollTop -= distanceBelowViewport;\n            this._offsetY -= distanceBelowViewport;\n            this._transformOrigin = this._getOriginBasedOnOption();\n            // If the panel is scrolled to the very top, it won't be able to fit the panel\n            // by scrolling, so set the offset to 0 to allow the fallback position to take\n            // effect.\n            if (this._scrollTop <= 0) {\n                this._scrollTop = 0;\n                this._offsetY = 0;\n                this._transformOrigin = `50% bottom 0px`;\n            }\n        }\n        /** Adjusts the overlay panel down to fit in the viewport. */\n        _adjustPanelDown(panelHeightTop, topSpaceAvailable, maxScroll) {\n            // Browsers ignore fractional scroll offsets, so we need to round.\n            const distanceAboveViewport = Math.round(panelHeightTop - topSpaceAvailable);\n            // Scrolls the panel down by the distance it was extending past the boundary, then\n            // adjusts the offset by that amount to move the panel down into the viewport.\n            this._scrollTop += distanceAboveViewport;\n            this._offsetY += distanceAboveViewport;\n            this._transformOrigin = this._getOriginBasedOnOption();\n            // If the panel is scrolled to the very bottom, it won't be able to fit the\n            // panel by scrolling, so set the offset to 0 to allow the fallback position\n            // to take effect.\n            if (this._scrollTop >= maxScroll) {\n                this._scrollTop = maxScroll;\n                this._offsetY = 0;\n                this._transformOrigin = `50% top 0px`;\n                return;\n            }\n        }\n        /** Calculates the scroll position and x- and y-offsets of the overlay panel. */\n        _calculateOverlayPosition() {\n            const itemHeight = this._getItemHeight();\n            const items = this._getItemCount();\n            const panelHeight = Math.min(items * itemHeight, SELECT_PANEL_MAX_HEIGHT);\n            const scrollContainerHeight = items * itemHeight;\n            // The farthest the panel can be scrolled before it hits the bottom\n            const maxScroll = scrollContainerHeight - panelHeight;\n            // If no value is selected we open the popup to the first item.\n            let selectedOptionOffset;\n            if (this.empty) {\n                selectedOptionOffset = 0;\n            }\n            else {\n                selectedOptionOffset =\n                    Math.max(this.options.toArray().indexOf(this._selectionModel.selected[0]), 0);\n            }\n            selectedOptionOffset += _countGroupLabelsBeforeOption(selectedOptionOffset, this.options, this.optionGroups);\n            // We must maintain a scroll buffer so the selected option will be scrolled to the\n            // center of the overlay panel rather than the top.\n            const scrollBuffer = panelHeight / 2;\n            this._scrollTop = this._calculateOverlayScroll(selectedOptionOffset, scrollBuffer, maxScroll);\n            this._offsetY = this._calculateOverlayOffsetY(selectedOptionOffset, scrollBuffer, maxScroll);\n            this._checkOverlayWithinViewport(maxScroll);\n        }\n        /** Sets the transform origin point based on the selected option. */\n        _getOriginBasedOnOption() {\n            const itemHeight = this._getItemHeight();\n            const optionHeightAdjustment = (itemHeight - this._triggerRect.height) / 2;\n            const originY = Math.abs(this._offsetY) - optionHeightAdjustment + itemHeight / 2;\n            return `50% ${originY}px 0px`;\n        }\n        /** Calculates the height of the select's options. */\n        _getItemHeight() {\n            return this._triggerFontSize * SELECT_ITEM_HEIGHT_EM;\n        }\n        /** Calculates the amount of items in the select. This includes options and group labels. */\n        _getItemCount() {\n            return this.options.length + this.optionGroups.length;\n        }\n    }\n    MatSelect.fac = function MatSelect_Factory(t) { return MatSelect_BaseFactory(t || MatSelect); };\n    MatSelect.cmp = /*@__PURE__*/ core[\"Gb\" /* defineComponent */]({ type: MatSelect, selectors: [[\"mat-select\"]], contentQueries: function MatSelect_ContentQueries(rf, ctx, dirIndex) {\n            if (rf & 1) {\n                core[\"Fb\" /* contentQuery */](dirIndex, MAT_SELECT_TRIGGER, true);\n                core[\"Fb\" /* contentQuery */](dirIndex, core_MatOption, true);\n                core[\"Fb\" /* contentQuery */](dirIndex, MAT_OPTGROUP, true);\n            }\n            if (rf & 2) {\n                let _t;\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.customTrigger = _t.first);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.options = _t);\n                core[\"kc\" /* queryRefresh */](_t = core[\"ac\" /* loadQuery */]()) && (ctx.optionGroups = _t);\n            }\n        }, hostAttrs: [\"role\", \"combobox\", \"aria-autocomplete\", \"none\", \"aria-haspopup\", \"true\", 1, \"mat-select\"], hostVars: 20, hostBindings: function MatSelect_HostBindings(rf, ctx) {\n            if (rf & 1) {\n                core[\"Zb\" /* listener */](\"keydown\", function MatSelect_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); })(\"focus\", function MatSelect_focus_HostBindingHandler() { return ctx._onFocus(); })(\"blur\", function MatSelect_blur_HostBindingHandler() { return ctx._onBlur(); });\n            }\n            if (rf & 2) {\n                core[\"Bb\" /* attribute */](\"id\", ctx.id)(\"tabindex\", ctx.tabIndex)(\"aria-controls\", ctx.panelOpen ? ctx.id + \"-panel\" : null)(\"aria-expanded\", ctx.panelOpen)(\"aria-label\", ctx.ariaLabel || null)(\"aria-required\", ctx.required.toString())(\"aria-disabled\", ctx.disabled.toString())(\"aria-invalid\", ctx.errorState)(\"aria-describedby\", ctx._ariaDescribedby || null)(\"aria-activedescendant\", ctx._getAriaActiveDescendant());\n                core[\"Eb\" /* classProp */](\"mat-select-disabled\", ctx.disabled)(\"mat-select-invalid\", ctx.errorState)(\"mat-select-required\", ctx.required)(\"mat-select-empty\", ctx.empty)(\"mat-select-multiple\", ctx.multiple);\n            }\n        }, inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", tabIndex: \"tabIndex\" }, exportAs: [\"matSelect\"], features: [/*@__PURE__*/ core[\"zb\" /* ProvidersFeature */]([\n                { provide: form_field_MatFormFieldControl, useExisting: MatSelect },\n                { provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatSelect }\n            ]), core[\"xb\" /* InheritDefinitionFeature */]], ngContentSelectors: select_c3, decls: 9, vars: 12, consts: [[\"cdk-overlay-origin\", \"\", 1, \"mat-select-trigger\", 3, \"click\"], [\"origin\", \"cdkOverlayOrigin\", \"trigger\", \"\"], [1, \"mat-select-value\", 3, \"ngSwitch\"], [\"class\", \"mat-select-placeholder mat-select-min-line\", 4, \"ngSwitchCase\"], [\"class\", \"mat-select-value-text\", 3, \"ngSwitch\", 4, \"ngSwitchCase\"], [1, \"mat-select-arrow-wrapper\"], [1, \"mat-select-arrow\"], [\"cdk-connected-overlay\", \"\", \"cdkConnectedOverlayLockPosition\", \"\", \"cdkConnectedOverlayHasBackdrop\", \"\", \"cdkConnectedOverlayBackdropClass\", \"cdk-overlay-transparent-backdrop\", 3, \"cdkConnectedOverlayPanelClass\", \"cdkConnectedOverlayScrollStrategy\", \"cdkConnectedOverlayOrigin\", \"cdkConnectedOverlayOpen\", \"cdkConnectedOverlayPositions\", \"cdkConnectedOverlayMinWidth\", \"cdkConnectedOverlayOffsetY\", \"backdropClick\", \"attach\", \"detach\"], [1, \"mat-select-placeholder\", \"mat-select-min-line\"], [1, \"mat-select-value-text\", 3, \"ngSwitch\"], [\"class\", \"mat-select-min-line\", 4, \"ngSwitchDefault\"], [4, \"ngSwitchCase\"], [1, \"mat-select-min-line\"], [1, \"mat-select-panel-wrap\"], [\"role\", \"listbox\", \"tabindex\", \"-1\", 3, \"ngClass\", \"keydown\"], [\"panel\", \"\"]], template: function MatSelect_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"dc\" /* projectionDef */](select_c2);\n                core[\"Sb\" /* elementStart */](0, \"div\", 0, 1);\n                core[\"Zb\" /* listener */](\"click\", function MatSelect_Template_div_click_0_listener() { return ctx.toggle(); });\n                core[\"Sb\" /* elementStart */](3, \"div\", 2);\n                core[\"sc\" /* template */](4, MatSelect_span_4_Template, 2, 1, \"span\", 3);\n                core[\"sc\" /* template */](5, MatSelect_span_5_Template, 3, 2, \"span\", 4);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Sb\" /* elementStart */](6, \"div\", 5);\n                core[\"Nb\" /* element */](7, \"div\", 6);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n                core[\"sc\" /* template */](8, MatSelect_ng_template_8_Template, 4, 14, \"ng-template\", 7);\n                core[\"Zb\" /* listener */](\"backdropClick\", function MatSelect_Template_ng_template_backdropClick_8_listener() { return ctx.close(); })(\"attach\", function MatSelect_Template_ng_template_attach_8_listener() { return ctx._onAttached(); })(\"detach\", function MatSelect_Template_ng_template_detach_8_listener() { return ctx.close(); });\n            }\n            if (rf & 2) {\n                const _r0 = core[\"lc\" /* reference */](1);\n                core[\"Bb\" /* attribute */](\"aria-owns\", ctx.panelOpen ? ctx.id + \"-panel\" : null);\n                core[\"Ab\" /* advance */](3);\n                core[\"ec\" /* property */](\"ngSwitch\", ctx.empty);\n                core[\"Bb\" /* attribute */](\"id\", ctx._valueId);\n                core[\"Ab\" /* advance */](1);\n                core[\"ec\" /* property */](\"ngSwitchCase\", true);\n                core[\"Ab\" /* advance */](1);\n                core[\"ec\" /* property */](\"ngSwitchCase\", false);\n                core[\"Ab\" /* advance */](3);\n                core[\"ec\" /* property */](\"cdkConnectedOverlayPanelClass\", ctx._overlayPanelClass)(\"cdkConnectedOverlayScrollStrategy\", ctx._scrollStrategy)(\"cdkConnectedOverlayOrigin\", _r0)(\"cdkConnectedOverlayOpen\", ctx.panelOpen)(\"cdkConnectedOverlayPositions\", ctx._positions)(\"cdkConnectedOverlayMinWidth\", ctx._triggerRect == null ? null : ctx._triggerRect.width)(\"cdkConnectedOverlayOffsetY\", ctx._offsetY);\n            }\n        }, directives: [overlay_CdkOverlayOrigin, common[\"l\" /* NgSwitch */], common[\"m\" /* NgSwitchCase */], overlay_CdkConnectedOverlay, common[\"n\" /* NgSwitchDefault */], common[\"h\" /* NgClass */]], styles: [\".mat-select{display:inline-block;width:100%;outline:none}.mat-select-trigger{display:inline-table;cursor:pointer;position:relative;box-sizing:border-box}.mat-select-disabled .mat-select-trigger{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:default}.mat-select-value{display:table-cell;max-width:0;width:100%;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.mat-select-value-text{white-space:nowrap;overflow:hidden;text-overflow:ellipsis}.mat-select-arrow-wrapper{display:table-cell;vertical-align:middle}.mat-form-field-appearance-fill .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-outline .mat-select-arrow-wrapper{transform:translateY(-25%)}.mat-form-field-appearance-standard.mat-form-field-has-label .mat-select:not(.mat-select-empty) .mat-select-arrow-wrapper{transform:translateY(-50%)}.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable.mat-form-field-appearance-standard .mat-select.mat-select-empty .mat-select-arrow-wrapper{transition:none}.mat-select-arrow{width:0;height:0;border-left:5px solid transparent;border-right:5px solid transparent;border-top:5px solid;margin:0 4px}.mat-select-panel-wrap{flex-basis:100%}.mat-select-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;padding-top:0;padding-bottom:0;max-height:256px;min-width:100%;border-radius:4px;outline:0}.cdk-high-contrast-active .mat-select-panel{outline:solid 1px}.mat-select-panel .mat-optgroup-label,.mat-select-panel .mat-option{font-size:inherit;line-height:3em;height:3em}.mat-form-field-type-mat-select:not(.mat-form-field-disabled) .mat-form-field-flex{cursor:pointer}.mat-form-field-type-mat-select .mat-form-field-label{width:calc(100% - 18px)}.mat-select-placeholder{transition:color 400ms 133.3333333333ms cubic-bezier(0.25, 0.8, 0.25, 1)}._mat-animation-noopable .mat-select-placeholder{transition:none}.mat-form-field-hide-placeholder .mat-select-placeholder{color:transparent;-webkit-text-fill-color:transparent;transition:none;display:block}.mat-select-min-line:empty::before{content:\\\" \\\";white-space:pre;width:1px}\\n\"], encapsulation: 2, data: { animation: [\n                matSelectAnimations.transformPanelWrap,\n                matSelectAnimations.transformPanel\n            ] }, changeDetection: 0 });\n    return MatSelect;\n})();\nconst MatSelect_BaseFactory = /*@__PURE__*/ /*@__PURE__*/ core[\"Ub\" /* getInheritedFactory */](select_MatSelect);\nlet select_MatSelectModule = /*@__PURE__*/ (() => {\n    class MatSelectModule {\n    }\n    MatSelectModule.mod = /*@__PURE__*/ core[\"Kb\" /* defineNgModule */]({ type: MatSelectModule });\n    MatSelectModule.inj = /*@__PURE__*/ core[\"Jb\" /* defineInjector */]({ factory: function MatSelectModule_Factory(t) { return new (t || MatSelectModule)(); }, providers: [MAT_SELECT_SCROLL_STRATEGY_PROVIDER], imports: [[\n                common[\"b\" /* CommonModule */],\n                overlay_OverlayModule,\n                core_MatOptionModule,\n                core_MatCommonModule,\n            ], scrolling_CdkScrollableModule,\n            form_field_MatFormFieldModule,\n            core_MatOptionModule,\n            core_MatCommonModule] });\n    return MatSelectModule;\n})();\n/*@__PURE__*/ (function () {\n    (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](select_MatSelectModule, { declarations: function () { return [select_MatSelect, select_MatSelectTrigger]; }, imports: function () {\n            return [common[\"b\" /* CommonModule */],\n                overlay_OverlayModule,\n                core_MatOptionModule,\n                core_MatCommonModule];\n        }, exports: function () {\n            return [scrolling_CdkScrollableModule,\n                form_field_MatFormFieldModule, select_MatSelect, select_MatSelectTrigger, core_MatOptionModule,\n                core_MatCommonModule];\n        } });\n})();\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=select.js.map\n\n// CONCATENATED MODULE: ./src/app/modules/auth/registration/components/email-mobile-verification/email-mobile-verification.component.ts\n\r\n\r\nlet email_mobile_verification_component_EmailMobileVerificationComponent = /*@__PURE__*/ (() => {\r\n    class EmailMobileVerificationComponent {\r\n        constructor() { }\r\n        ngOnInit() {\r\n            console.log('item', this.item);\r\n        }\r\n    }\r\n    EmailMobileVerificationComponent.fac = function EmailMobileVerificationComponent_Factory(t) { return new (t || EmailMobileVerificationComponent)(); };\r\n    EmailMobileVerificationComponent.cmp = core[\"Gb\" /* defineComponent */]({ type: EmailMobileVerificationComponent, selectors: [[\"app-email-mobile-verification\"]], inputs: { item: \"item\" }, decls: 13, vars: 0, consts: [[1, \"_m0\", \"_forgotTextColor\"], [1, \"_mt\", \"_inputLabel\"], [\"placeholder\", \"Mobile OTP\", \"type\", \"tel\", \"maxlength\", \"4\", 1, \"_inputBox\"], [\"placeholder\", \"Email OTP\", \"type\", \"tel\", \"maxlength\", \"4\", 1, \"_inputBox\"], [1, \"_mt\", \"_textCen\"], [\"mat-button\", \"\", 1, \"button\", \"_width100\"]], template: function EmailMobileVerificationComponent_Template(rf, ctx) {\r\n            if (rf & 1) {\r\n                core[\"Sb\" /* elementStart */](0, \"h3\", 0);\r\n                core[\"uc\" /* text */](1, \"OTP Verify\");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Sb\" /* elementStart */](2, \"div\");\r\n                core[\"Sb\" /* elementStart */](3, \"label\", 1);\r\n                core[\"uc\" /* text */](4, \"Mobile OTP\");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Nb\" /* element */](5, \"input\", 2);\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Sb\" /* elementStart */](6, \"div\");\r\n                core[\"Sb\" /* elementStart */](7, \"label\", 1);\r\n                core[\"uc\" /* text */](8, \"Email OTP\");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Nb\" /* element */](9, \"input\", 3);\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Sb\" /* elementStart */](10, \"div\", 4);\r\n                core[\"Sb\" /* elementStart */](11, \"button\", 5);\r\n                core[\"uc\" /* text */](12, \" Verify OTP ( Email and Mobilenumber ) \");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n            }\r\n        }, directives: [button_MatButton], styles: [\"\"] });\r\n    return EmailMobileVerificationComponent;\r\n})();\r\n\n// CONCATENATED MODULE: ./src/app/modules/auth/registration/registration.component.ts\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction RegistrationComponent_div_8_div_8_div_1_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Company name is required \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_8_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\", 23);\r\n        core[\"sc\" /* template */](1, RegistrationComponent_div_8_div_8_div_1_Template, 2, 0, \"div\", 24);\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r3 = core[\"bc\" /* nextContext */](2);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r3.f.companyName.errors == null ? null : ctx_r3.f.companyName.errors.required);\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_13_div_1_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \"Email is required\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_13_div_2_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Email must be a valid email address \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_13_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\", 23);\r\n        core[\"sc\" /* template */](1, RegistrationComponent_div_8_div_13_div_1_Template, 2, 0, \"div\", 24);\r\n        core[\"sc\" /* template */](2, RegistrationComponent_div_8_div_13_div_2_Template, 2, 0, \"div\", 24);\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r4 = core[\"bc\" /* nextContext */](2);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r4.f.email.errors.required);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r4.f.email.errors.email);\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_18_div_1_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Mobile Number is required \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_18_div_2_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Please enter valid mobile number \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_18_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\", 23);\r\n        core[\"sc\" /* template */](1, RegistrationComponent_div_8_div_18_div_1_Template, 2, 0, \"div\", 24);\r\n        core[\"sc\" /* template */](2, RegistrationComponent_div_8_div_18_div_2_Template, 2, 0, \"div\", 24);\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r5 = core[\"bc\" /* nextContext */](2);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r5.f.mobileNumber.errors.required);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r5.f.mobileNumber.errors.pattern == null ? null : ctx_r5.f.mobileNumber.errors.pattern.requiredPattern);\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_mat_option_23_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"mat-option\", 25);\r\n        core[\"uc\" /* text */](1);\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const sol_r15 = ctx.$implicit;\r\n        core[\"ec\" /* property */](\"value\", sol_r15.solution_id);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"vc\" /* textInterpolate */](sol_r15 == null ? null : sol_r15.solution_name);\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_24_div_1_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Solution is required \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_24_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\", 23);\r\n        core[\"sc\" /* template */](1, RegistrationComponent_div_8_div_24_div_1_Template, 2, 0, \"div\", 24);\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r7 = core[\"bc\" /* nextContext */](2);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r7.f.solution.errors.required);\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_29_div_1_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Password is required \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_29_div_2_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Password must be at least 6 characters \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_29_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\", 23);\r\n        core[\"sc\" /* template */](1, RegistrationComponent_div_8_div_29_div_1_Template, 2, 0, \"div\", 24);\r\n        core[\"sc\" /* template */](2, RegistrationComponent_div_8_div_29_div_2_Template, 2, 0, \"div\", 24);\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r8 = core[\"bc\" /* nextContext */](2);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r8.f.password.errors.required);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r8.f.password.errors.minlength);\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_34_div_1_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Confirm Password is required \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_34_div_2_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"uc\" /* text */](1, \" Passwords must match \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_div_34_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Sb\" /* elementStart */](0, \"div\", 23);\r\n        core[\"sc\" /* template */](1, RegistrationComponent_div_8_div_34_div_1_Template, 2, 0, \"div\", 24);\r\n        core[\"sc\" /* template */](2, RegistrationComponent_div_8_div_34_div_2_Template, 2, 0, \"div\", 24);\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r9 = core[\"bc\" /* nextContext */](2);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r9.f.confirmPassword.errors.required);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r9.f.confirmPassword.errors.mustMatch);\r\n    }\r\n}\r\nfunction RegistrationComponent_div_8_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        const _r22 = core[\"Tb\" /* getCurrentView */]();\r\n        core[\"Sb\" /* elementStart */](0, \"div\");\r\n        core[\"Sb\" /* elementStart */](1, \"form\", 8);\r\n        core[\"Sb\" /* elementStart */](2, \"h3\", 9);\r\n        core[\"uc\" /* text */](3, \"Sign up\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](4, \"div\");\r\n        core[\"Sb\" /* elementStart */](5, \"label\", 10);\r\n        core[\"uc\" /* text */](6, \"Company name\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Nb\" /* element */](7, \"input\", 11);\r\n        core[\"sc\" /* template */](8, RegistrationComponent_div_8_div_8_Template, 2, 1, \"div\", 12);\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](9, \"div\");\r\n        core[\"Sb\" /* elementStart */](10, \"label\", 10);\r\n        core[\"uc\" /* text */](11, \"Email\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Nb\" /* element */](12, \"input\", 13);\r\n        core[\"sc\" /* template */](13, RegistrationComponent_div_8_div_13_Template, 3, 2, \"div\", 12);\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](14, \"div\");\r\n        core[\"Sb\" /* elementStart */](15, \"label\", 10);\r\n        core[\"uc\" /* text */](16, \"Mobile Number\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Nb\" /* element */](17, \"input\", 14);\r\n        core[\"sc\" /* template */](18, RegistrationComponent_div_8_div_18_Template, 3, 2, \"div\", 12);\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](19, \"div\");\r\n        core[\"Sb\" /* elementStart */](20, \"label\", 10);\r\n        core[\"uc\" /* text */](21, \"Solution\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](22, \"mat-select\", 15);\r\n        core[\"sc\" /* template */](23, RegistrationComponent_div_8_mat_option_23_Template, 2, 2, \"mat-option\", 16);\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"sc\" /* template */](24, RegistrationComponent_div_8_div_24_Template, 2, 1, \"div\", 12);\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](25, \"div\");\r\n        core[\"Sb\" /* elementStart */](26, \"label\", 10);\r\n        core[\"uc\" /* text */](27, \"Password\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Nb\" /* element */](28, \"input\", 17);\r\n        core[\"sc\" /* template */](29, RegistrationComponent_div_8_div_29_Template, 3, 2, \"div\", 12);\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](30, \"div\");\r\n        core[\"Sb\" /* elementStart */](31, \"label\", 10);\r\n        core[\"uc\" /* text */](32, \"Confirm Password\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Nb\" /* element */](33, \"input\", 18);\r\n        core[\"sc\" /* template */](34, RegistrationComponent_div_8_div_34_Template, 3, 2, \"div\", 12);\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](35, \"div\", 19);\r\n        core[\"Sb\" /* elementStart */](36, \"button\", 20);\r\n        core[\"Zb\" /* listener */](\"click\", function RegistrationComponent_div_8_Template_button_click_36_listener() { core[\"mc\" /* restoreView */](_r22); const ctx_r21 = core[\"bc\" /* nextContext */](); return ctx_r21.signInSumbit(); });\r\n        core[\"uc\" /* text */](37, \" Sign in \");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Sb\" /* elementStart */](38, \"div\", 21);\r\n        core[\"uc\" /* text */](39, \" Already have login and password?\");\r\n        core[\"Sb\" /* elementStart */](40, \"span\", 22);\r\n        core[\"uc\" /* text */](41, \"\\u00A0Sign in\");\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n        core[\"Rb\" /* elementEnd */]();\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r0 = core[\"bc\" /* nextContext */]();\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"formGroup\", ctx_r0.signInForm);\r\n        core[\"Ab\" /* advance */](7);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r0.submitted && (ctx_r0.f.companyName == null ? null : ctx_r0.f.companyName.errors));\r\n        core[\"Ab\" /* advance */](5);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r0.submitted && ctx_r0.f.email.errors);\r\n        core[\"Ab\" /* advance */](5);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r0.submitted && ctx_r0.f.mobileNumber.errors);\r\n        core[\"Ab\" /* advance */](5);\r\n        core[\"ec\" /* property */](\"ngForOf\", ctx_r0.solutionListData);\r\n        core[\"Ab\" /* advance */](1);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r0.submitted && ctx_r0.f.solution.errors);\r\n        core[\"Ab\" /* advance */](5);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r0.submitted && ctx_r0.f.password.errors);\r\n        core[\"Ab\" /* advance */](5);\r\n        core[\"ec\" /* property */](\"ngIf\", ctx_r0.submitted && ctx_r0.f.confirmPassword.errors);\r\n    }\r\n}\r\nfunction RegistrationComponent_ng_template_9_Template(rf, ctx) {\r\n    if (rf & 1) {\r\n        core[\"Nb\" /* element */](0, \"app-email-mobile-verification\", 26);\r\n    }\r\n    if (rf & 2) {\r\n        const ctx_r2 = core[\"bc\" /* nextContext */]();\r\n        core[\"ec\" /* property */](\"item\", ctx_r2.solutionListData);\r\n    }\r\n}\r\nlet registration_component_RegistrationComponent = /*@__PURE__*/ (() => {\r\n    class RegistrationComponent {\r\n        constructor(endPoints, toastMessage, formBuilder) {\r\n            this.endPoints = endPoints;\r\n            this.toastMessage = toastMessage;\r\n            this.formBuilder = formBuilder;\r\n            this.signBasicDetailsStatus = false;\r\n            this.submitted = false;\r\n            this.solutionListData = [\r\n                {\r\n                    solution_id: 1,\r\n                    solution_key: 'rIbXOMaLTg3rTLv3',\r\n                    solution_name: 'Food Delivery',\r\n                },\r\n            ];\r\n            // console.log('endPoints', this.endPoints.serverEndPoint.login);\r\n            // this.toastMessage.addSingle();\r\n        }\r\n        ngOnInit() {\r\n            this.signInForm = this.formBuilder.group({\r\n                companyName: ['', fesm2015_forms[\"k\" /* Validators */].required],\r\n                email: ['', [fesm2015_forms[\"k\" /* Validators */].required, fesm2015_forms[\"k\" /* Validators */].email]],\r\n                mobileNumber: [\r\n                    '',\r\n                    [\r\n                        fesm2015_forms[\"k\" /* Validators */].required,\r\n                        fesm2015_forms[\"k\" /* Validators */].pattern('^((\\\\+91-?)|0)?[0-9]{10}$'),\r\n                    ],\r\n                ],\r\n                solution: ['', fesm2015_forms[\"k\" /* Validators */].required],\r\n                password: ['', [fesm2015_forms[\"k\" /* Validators */].required, fesm2015_forms[\"k\" /* Validators */].minLength(6)]],\r\n                confirmPassword: ['', fesm2015_forms[\"k\" /* Validators */].required],\r\n            }, {\r\n                validator: MustMatch('password', 'confirmPassword'),\r\n            });\r\n        }\r\n        // convenience getter for easy access to form fields\r\n        get f() {\r\n            var _a;\r\n            return (_a = this.signInForm) === null || _a === void 0 ? void 0 : _a.controls;\r\n        }\r\n        signInSumbit() {\r\n            var _a;\r\n            console.log('form', this.signInForm);\r\n            this.submitted = true;\r\n            // this.toastMessage.addSingle();\r\n            if ((_a = this.signInForm) === null || _a === void 0 ? void 0 : _a.valid) {\r\n                this.signBasicDetailsStatus = true;\r\n            }\r\n        }\r\n    }\r\n    RegistrationComponent.fac = function RegistrationComponent_Factory(t) { return new (t || RegistrationComponent)(core[\"Mb\" /* directiveInject */](endPoints), core[\"Mb\" /* directiveInject */](app_component[\"a\" /* AppComponent */]), core[\"Mb\" /* directiveInject */](fesm2015_forms[\"b\" /* FormBuilder */])); };\r\n    RegistrationComponent.cmp = core[\"Gb\" /* defineComponent */]({ type: RegistrationComponent, selectors: [[\"app-registration\"]], decls: 11, vars: 2, consts: [[1, \"row\", \"_width100\", 2, \"height\", \"100%\", \"margin\", \"0px\"], [1, \"col-xl-5\", \"col-lg-5\", \"col-md-5\", \"col-sm-12\", \"col-xs-12\", \"_imgDiv\"], [\"src\", \"/assets/Register-Img.png\", 2, \"width\", \"100%\"], [1, \"col-xl-7\", \"col-lg-7\", \"col-md-7\", \"col-sm-12\", \"col-xs-12\"], [1, \"_rightSideContainer\"], [1, \"_m0\", \"_fw700\"], [4, \"ngIf\", \"ngIfElse\"], [\"verifyOTP\", \"\"], [3, \"formGroup\"], [1, \"_m0\", \"_forgotTextColor\"], [1, \"_mt\", \"_inputLabel\"], [\"placeholder\", \"Company name\", \"formControlName\", \"companyName\", \"type\", \"text\", 1, \"_inputBox\"], [\"class\", \"_alertTextColor\", 4, \"ngIf\"], [\"placeholder\", \"Email\", \"formControlName\", \"email\", \"type\", \"text\", 1, \"_inputBox\"], [\"placeholder\", \"Mobile Number\", \"formControlName\", \"mobileNumber\", \"type\", \"tel\", 1, \"_inputBox\"], [\"formControlName\", \"solution\", \"placeholder\", \"Solution\", 1, \"_inputBox\"], [3, \"value\", 4, \"ngFor\", \"ngForOf\"], [\"placeholder\", \"Password\", \"formControlName\", \"password\", \"type\", \"password\", 1, \"_inputBox\"], [\"placeholder\", \"Confirm Password\", \"formControlName\", \"confirmPassword\", \"type\", \"password\", 1, \"_inputBox\"], [1, \"_mt\", \"_textCen\"], [\"mat-button\", \"\", 1, \"button\", \"_width100\", 3, \"click\"], [1, \"_textStart\", \"_mt\"], [\"routerLink\", \"/login\", 1, \"_cursorPointer\", \"_primaryTextColor\"], [1, \"_alertTextColor\"], [4, \"ngIf\"], [3, \"value\"], [3, \"item\"]], template: function RegistrationComponent_Template(rf, ctx) {\r\n            if (rf & 1) {\r\n                core[\"Sb\" /* elementStart */](0, \"div\", 0);\r\n                core[\"Sb\" /* elementStart */](1, \"div\", 1);\r\n                core[\"Nb\" /* element */](2, \"img\", 2);\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Sb\" /* elementStart */](3, \"div\", 3);\r\n                core[\"Sb\" /* elementStart */](4, \"div\", 4);\r\n                core[\"Sb\" /* elementStart */](5, \"div\");\r\n                core[\"Sb\" /* elementStart */](6, \"h1\", 5);\r\n                core[\"uc\" /* text */](7, \"ConvoBot360\");\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"sc\" /* template */](8, RegistrationComponent_div_8_Template, 42, 8, \"div\", 6);\r\n                core[\"sc\" /* template */](9, RegistrationComponent_ng_template_9_Template, 1, 1, \"ng-template\", null, 7, core[\"tc\" /* templateRefExtractor */]);\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n                core[\"Rb\" /* elementEnd */]();\r\n            }\r\n            if (rf & 2) {\r\n                const _r1 = core[\"lc\" /* reference */](10);\r\n                core[\"Ab\" /* advance */](8);\r\n                core[\"ec\" /* property */](\"ngIf\", !ctx.signBasicDetailsStatus)(\"ngIfElse\", _r1);\r\n            }\r\n        }, directives: [common[\"j\" /* NgIf */], fesm2015_forms[\"l\" /* angular_packages_forms_forms_y */], fesm2015_forms[\"h\" /* NgControlStatusGroup */], fesm2015_forms[\"d\" /* FormGroupDirective */], fesm2015_forms[\"a\" /* DefaultValueAccessor */], fesm2015_forms[\"g\" /* NgControlStatus */], fesm2015_forms[\"c\" /* FormControlName */], select_MatSelect, common[\"i\" /* NgForOf */], button_MatButton, router[\"a\" /* RouterLink */], core_MatOption, email_mobile_verification_component_EmailMobileVerificationComponent], styles: [\"._rightSideContainer[_ngcontent-%COMP%]{width:500px;margin:30px auto}._imgDiv[_ngcontent-%COMP%]{padding:0}@media (max-width:500px){._rightSideContainer[_ngcontent-%COMP%]{width:auto;margin:30px auto}}@media (max-width:768px){._imgDiv[_ngcontent-%COMP%]{display:none}}\"] });\r\n    return RegistrationComponent;\r\n})();\r\n\n// CONCATENATED MODULE: ./src/app/modules/auth/auth-routing.module.ts\n\r\n\r\n\r\n\r\n\r\n\r\nconst routes = [\r\n    {\r\n        path: 'login',\r\n        component: login_component_LoginComponent,\r\n    },\r\n    {\r\n        path: 'forgot-password',\r\n        component: forgot_password_component_ForgotPasswordComponent,\r\n    },\r\n    {\r\n        path: 'registration',\r\n        component: registration_component_RegistrationComponent,\r\n    },\r\n    { path: '', redirectTo: 'login', pathMatch: 'full' },\r\n    { path: '**', redirectTo: 'login', pathMatch: 'full' },\r\n];\r\nlet auth_routing_module_AuthRoutingModule = /*@__PURE__*/ (() => {\r\n    class AuthRoutingModule {\r\n    }\r\n    AuthRoutingModule.mod = core[\"Kb\" /* defineNgModule */]({ type: AuthRoutingModule });\r\n    AuthRoutingModule.inj = core[\"Jb\" /* defineInjector */]({ factory: function AuthRoutingModule_Factory(t) { return new (t || AuthRoutingModule)(); }, imports: [[router[\"b\" /* RouterModule */].forChild(routes)], router[\"b\" /* RouterModule */]] });\r\n    return AuthRoutingModule;\r\n})();\r\n\n// EXTERNAL MODULE: ./node_modules/primeng-lts/__ivy_ngcc__/fesm2015/primeng-lts-dom.js\nvar primeng_lts_dom = __webpack_require__(\"P/hZ\");\n\n// CONCATENATED MODULE: ./node_modules/primeng-lts/__ivy_ngcc__/fesm2015/primeng-lts-button.js\n\n\n\n\n\nconst primeng_lts_button_c0 = function (a1, a2) { return { \"ui-clickable\": true, \"ui-button-icon-left\": a1, \"ui-button-icon-right\": a2 }; };\nfunction Button_span_2_Template(rf, ctx) {\n    if (rf & 1) {\n        core[\"Nb\" /* element */](0, \"span\", 3);\n    }\n    if (rf & 2) {\n        const ctx_r0 = core[\"bc\" /* nextContext */]();\n        core[\"Cb\" /* classMap */](ctx_r0.icon);\n        core[\"ec\" /* property */](\"ngClass\", core[\"gc\" /* pureFunction2 */](4, primeng_lts_button_c0, ctx_r0.iconPos === \"left\", ctx_r0.iconPos === \"right\"));\n        core[\"Bb\" /* attribute */](\"aria-hidden\", true);\n    }\n}\nconst primeng_lts_button_c1 = function (a1, a2, a3, a4, a5, a6) { return { \"ui-button ui-widget ui-state-default ui-corner-all\": true, \"ui-button-icon-only\": a1, \"ui-button-text-icon-left\": a2, \"ui-button-text-icon-right\": a3, \"ui-button-text-only\": a4, \"ui-button-text-empty\": a5, \"ui-state-disabled\": a6 }; };\nconst primeng_lts_button_c2 = [\"*\"];\nvar __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n        r = Reflect.decorate(decorators, target, key, desc);\n    else\n        for (var i = decorators.length - 1; i >= 0; i--)\n            if (d = decorators[i])\n                r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nlet primeng_lts_button_ButtonDirective = /*@__PURE__*/ (() => {\n    let ButtonDirective = class ButtonDirective {\n        constructor(el) {\n            this.el = el;\n            this.iconPos = 'left';\n            this.cornerStyleClass = 'ui-corner-all';\n        }\n        ngAfterViewInit() {\n            this._initialStyleClass = this.el.nativeElement.className;\n            primeng_lts_dom[\"a\" /* DomHandler */].addMultipleClasses(this.el.nativeElement, this.getStyleClass());\n            if (this.icon) {\n                let iconElement = document.createElement(\"span\");\n                iconElement.setAttribute(\"aria-hidden\", \"true\");\n                let iconPosClass = (this.iconPos == 'right') ? 'ui-button-icon-right' : 'ui-button-icon-left';\n                iconElement.className = iconPosClass + ' ui-clickable ' + this.icon;\n                this.el.nativeElement.appendChild(iconElement);\n            }\n            let labelElement = document.createElement(\"span\");\n            if (this.icon && !this.label) {\n                labelElement.setAttribute('aria-hidden', 'true');\n            }\n            labelElement.className = 'ui-button-text ui-clickable';\n            labelElement.appendChild(document.createTextNode(this.label || 'ui-btn'));\n            this.el.nativeElement.appendChild(labelElement);\n            this.initialized = true;\n        }\n        getStyleClass() {\n            let styleClass = 'ui-button ui-widget ui-state-default ' + this.cornerStyleClass;\n            if (this.icon) {\n                if (this.label != null && this.label != undefined && this.label != \"\") {\n                    if (this.iconPos == 'left')\n                        styleClass = styleClass + ' ui-button-text-icon-left';\n                    else\n                        styleClass = styleClass + ' ui-button-text-icon-right';\n                }\n                else {\n                    styleClass = styleClass + ' ui-button-icon-only';\n                }\n            }\n            else {\n                if (this.label) {\n                    styleClass = styleClass + ' ui-button-text-only';\n                }\n                else {\n                    styleClass = styleClass + ' ui-button-text-empty';\n                }\n            }\n            return styleClass;\n        }\n        setStyleClass() {\n            let styleClass = this.getStyleClass();\n            this.el.nativeElement.className = styleClass + ' ' + this._initialStyleClass;\n        }\n        get label() {\n            return this._label;\n        }\n        set label(val) {\n            this._label = val;\n            if (this.initialized) {\n                primeng_lts_dom[\"a\" /* DomHandler */].findSingle(this.el.nativeElement, '.ui-button-text').textContent = this._label || 'ui-btn';\n                if (!this.icon) {\n                    if (this._label) {\n                        primeng_lts_dom[\"a\" /* DomHandler */].removeClass(this.el.nativeElement, 'ui-button-text-empty');\n                        primeng_lts_dom[\"a\" /* DomHandler */].addClass(this.el.nativeElement, 'ui-button-text-only');\n                    }\n                    else {\n                        primeng_lts_dom[\"a\" /* DomHandler */].addClass(this.el.nativeElement, 'ui-button-text-empty');\n                        primeng_lts_dom[\"a\" /* DomHandler */].removeClass(this.el.nativeElement, 'ui-button-text-only');\n                    }\n                }\n                this.setStyleClass();\n            }\n        }\n        get icon() {\n            return this._icon;\n        }\n        set icon(val) {\n            this._icon = val;\n            if (this.initialized) {\n                let iconPosClass = (this.iconPos == 'right') ? 'ui-button-icon-right' : 'ui-button-icon-left';\n                primeng_lts_dom[\"a\" /* DomHandler */].findSingle(this.el.nativeElement, '.ui-clickable').className =\n                    iconPosClass + ' ui-clickable ' + this.icon;\n                this.setStyleClass();\n            }\n        }\n        ngOnDestroy() {\n            while (this.el.nativeElement.hasChildNodes()) {\n                this.el.nativeElement.removeChild(this.el.nativeElement.lastChild);\n            }\n            this.initialized = false;\n        }\n    };\n    ButtonDirective.fac = function ButtonDirective_Factory(t) { return new (t || ButtonDirective)(core[\"Mb\" /* directiveInject */](core[\"l\" /* ElementRef */])); };\n    ButtonDirective.dir = core[\"Hb\" /* defineDirective */]({ type: ButtonDirective, selectors: [[\"\", \"pButton\", \"\"]], inputs: { iconPos: \"iconPos\", cornerStyleClass: \"cornerStyleClass\", label: \"label\", icon: \"icon\" } });\n    return ButtonDirective;\n})();\nlet primeng_lts_button_Button = /*@__PURE__*/ (() => {\n    let Button = class Button {\n        constructor() {\n            this.iconPos = 'left';\n            this.onClick = new core[\"n\" /* EventEmitter */]();\n            this.onFocus = new core[\"n\" /* EventEmitter */]();\n            this.onBlur = new core[\"n\" /* EventEmitter */]();\n        }\n    };\n    Button.fac = function Button_Factory(t) { return new (t || Button)(); };\n    Button.cmp = core[\"Gb\" /* defineComponent */]({ type: Button, selectors: [[\"p-button\"]], inputs: { iconPos: \"iconPos\", type: \"type\", icon: \"icon\", label: \"label\", disabled: \"disabled\", style: \"style\", styleClass: \"styleClass\" }, outputs: { onClick: \"onClick\", onFocus: \"onFocus\", onBlur: \"onBlur\" }, ngContentSelectors: primeng_lts_button_c2, decls: 5, vars: 16, consts: [[3, \"ngStyle\", \"disabled\", \"ngClass\", \"click\", \"focus\", \"blur\"], [3, \"ngClass\", \"class\", 4, \"ngIf\"], [1, \"ui-button-text\", \"ui-clickable\"], [3, \"ngClass\"]], template: function Button_Template(rf, ctx) {\n            if (rf & 1) {\n                core[\"dc\" /* projectionDef */]();\n                core[\"Sb\" /* elementStart */](0, \"button\", 0);\n                core[\"Zb\" /* listener */](\"click\", function Button_Template_button_click_0_listener($event) { return ctx.onClick.emit($event); })(\"focus\", function Button_Template_button_focus_0_listener($event) { return ctx.onFocus.emit($event); })(\"blur\", function Button_Template_button_blur_0_listener($event) { return ctx.onBlur.emit($event); });\n                core[\"cc\" /* projection */](1);\n                core[\"sc\" /* template */](2, Button_span_2_Template, 1, 7, \"span\", 1);\n                core[\"Sb\" /* elementStart */](3, \"span\", 2);\n                core[\"uc\" /* text */](4);\n                core[\"Rb\" /* elementEnd */]();\n                core[\"Rb\" /* elementEnd */]();\n            }\n            if (rf & 2) {\n                core[\"Cb\" /* classMap */](ctx.styleClass);\n                core[\"ec\" /* property */](\"ngStyle\", ctx.style)(\"disabled\", ctx.disabled)(\"ngClass\", core[\"ic\" /* pureFunction6 */](9, primeng_lts_button_c1, ctx.icon && !ctx.label, ctx.icon && ctx.label && ctx.iconPos === \"left\", ctx.icon && ctx.label && ctx.iconPos === \"right\", !ctx.icon && ctx.label, !ctx.icon && !ctx.label, ctx.disabled));\n                core[\"Bb\" /* attribute */](\"type\", ctx.type);\n                core[\"Ab\" /* advance */](2);\n                core[\"ec\" /* property */](\"ngIf\", ctx.icon);\n                core[\"Ab\" /* advance */](1);\n                core[\"Bb\" /* attribute */](\"aria-hidden\", ctx.icon && !ctx.label);\n                core[\"Ab\" /* advance */](1);\n                core[\"vc\" /* textInterpolate */](ctx.label || \"ui-btn\");\n            }\n        }, directives: [common[\"k\" /* NgStyle */], common[\"h\" /* NgClass */], common[\"j\" /* NgIf */]], encapsulation: 2 });\n    return Button;\n})();\nlet primeng_lts_button_ButtonModule = /*@__PURE__*/ (() => {\n    let ButtonModule = class ButtonModule {\n    };\n    ButtonModule.mod = core[\"Kb\" /* defineNgModule */]({ type: ButtonModule });\n    ButtonModule.inj = core[\"Jb\" /* defineInjector */]({ factory: function ButtonModule_Factory(t) { return new (t || ButtonModule)(); }, imports: [[common[\"b\" /* CommonModule */]]] });\n    return ButtonModule;\n})();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && core[\"oc\" /* setNgModuleScope */](primeng_lts_button_ButtonModule, { declarations: function () { return [primeng_lts_button_ButtonDirective, primeng_lts_button_Button]; }, imports: function () { return [common[\"b\" /* CommonModule */]]; }, exports: function () { return [primeng_lts_button_ButtonDirective, primeng_lts_button_Button]; } }); })();\n/**\n * Generated bundle index. Do not edit.\n */\n\n//# sourceMappingURL=primeng-lts-button.js.map\n\n// EXTERNAL MODULE: ./node_modules/primeng-lts/__ivy_ngcc__/fesm2015/primeng-lts-toast.js\nvar primeng_lts_toast = __webpack_require__(\"arS9\");\n\n// CONCATENATED MODULE: ./src/app/modules/auth/auth.module.ts\n\r\n\r\n\r\n// UI components\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nlet auth_module_AuthModule = /*@__PURE__*/ (() => {\r\n    class AuthModule {\r\n    }\r\n    AuthModule.mod = core[\"Kb\" /* defineNgModule */]({ type: AuthModule });\r\n    AuthModule.inj = core[\"Jb\" /* defineInjector */]({ factory: function AuthModule_Factory(t) { return new (t || AuthModule)(); }, providers: [endPoints, app_component[\"a\" /* AppComponent */]], imports: [[\r\n                common[\"b\" /* CommonModule */],\r\n                auth_routing_module_AuthRoutingModule,\r\n                tabs_MatTabsModule,\r\n                button_MatButtonModule,\r\n                fesm2015_forms[\"j\" /* ReactiveFormsModule */],\r\n                select_MatSelectModule,\r\n                fesm2015_forms[\"e\" /* FormsModule */],\r\n                primeng_lts_button_ButtonModule,\r\n                primeng_lts_toast[\"b\" /* ToastModule */],\r\n            ]] });\r\n    return AuthModule;\r\n})();\r\n\n\n/***/ })\n\n}]);","inputSourceMap":null}